// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gkt.proto

package google.keytransparency.v1;

public final class Gkt {
  private Gkt() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface GetUserRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.keytransparency.v1.GetUserRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * directory_id identifies the directory in which the user lives.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     * @return The directoryId.
     */
    java.lang.String getDirectoryId();
    /**
     * <pre>
     * directory_id identifies the directory in which the user lives.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     * @return The bytes for directoryId.
     */
    com.google.protobuf.ByteString
        getDirectoryIdBytes();

    /**
     * <pre>
     * user_id is the user identifier, the format for which is defined by the
     * application.
     * </pre>
     *
     * <code>string user_id = 2;</code>
     * @return The userId.
     */
    java.lang.String getUserId();
    /**
     * <pre>
     * user_id is the user identifier, the format for which is defined by the
     * application.
     * </pre>
     *
     * <code>string user_id = 2;</code>
     * @return The bytes for userId.
     */
    com.google.protobuf.ByteString
        getUserIdBytes();

    /**
     * <pre>
     * last_verified is the last log root the client verified.
     * Omitting this field will omit the log consistency proof from the response.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
     * @return Whether the lastVerified field is set.
     */
    boolean hasLastVerified();
    /**
     * <pre>
     * last_verified is the last log root the client verified.
     * Omitting this field will omit the log consistency proof from the response.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
     * @return The lastVerified.
     */
    google.keytransparency.v1.Gkt.LogRootRequest getLastVerified();
  }
  /**
   * <pre>
   * Gets the leaf entry for a user.
   * </pre>
   *
   * Protobuf type {@code google.keytransparency.v1.GetUserRequest}
   */
  public  static final class GetUserRequest extends
      com.google.protobuf.GeneratedMessageLite<
          GetUserRequest, GetUserRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:google.keytransparency.v1.GetUserRequest)
      GetUserRequestOrBuilder {
    private GetUserRequest() {
      directoryId_ = "";
      userId_ = "";
    }
    public static final int DIRECTORY_ID_FIELD_NUMBER = 1;
    private java.lang.String directoryId_;
    /**
     * <pre>
     * directory_id identifies the directory in which the user lives.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     * @return The directoryId.
     */
    @java.lang.Override
    public java.lang.String getDirectoryId() {
      return directoryId_;
    }
    /**
     * <pre>
     * directory_id identifies the directory in which the user lives.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     * @return The bytes for directoryId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDirectoryIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(directoryId_);
    }
    /**
     * <pre>
     * directory_id identifies the directory in which the user lives.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     * @param value The directoryId to set.
     */
    private void setDirectoryId(
        java.lang.String value) {
      value.getClass();
  
      directoryId_ = value;
    }
    /**
     * <pre>
     * directory_id identifies the directory in which the user lives.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     */
    private void clearDirectoryId() {
      
      directoryId_ = getDefaultInstance().getDirectoryId();
    }
    /**
     * <pre>
     * directory_id identifies the directory in which the user lives.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     * @param value The bytes for directoryId to set.
     */
    private void setDirectoryIdBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      directoryId_ = value.toStringUtf8();
      
    }

    public static final int USER_ID_FIELD_NUMBER = 2;
    private java.lang.String userId_;
    /**
     * <pre>
     * user_id is the user identifier, the format for which is defined by the
     * application.
     * </pre>
     *
     * <code>string user_id = 2;</code>
     * @return The userId.
     */
    @java.lang.Override
    public java.lang.String getUserId() {
      return userId_;
    }
    /**
     * <pre>
     * user_id is the user identifier, the format for which is defined by the
     * application.
     * </pre>
     *
     * <code>string user_id = 2;</code>
     * @return The bytes for userId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getUserIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(userId_);
    }
    /**
     * <pre>
     * user_id is the user identifier, the format for which is defined by the
     * application.
     * </pre>
     *
     * <code>string user_id = 2;</code>
     * @param value The userId to set.
     */
    private void setUserId(
        java.lang.String value) {
      value.getClass();
  
      userId_ = value;
    }
    /**
     * <pre>
     * user_id is the user identifier, the format for which is defined by the
     * application.
     * </pre>
     *
     * <code>string user_id = 2;</code>
     */
    private void clearUserId() {
      
      userId_ = getDefaultInstance().getUserId();
    }
    /**
     * <pre>
     * user_id is the user identifier, the format for which is defined by the
     * application.
     * </pre>
     *
     * <code>string user_id = 2;</code>
     * @param value The bytes for userId to set.
     */
    private void setUserIdBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      userId_ = value.toStringUtf8();
      
    }

    public static final int LAST_VERIFIED_FIELD_NUMBER = 4;
    private google.keytransparency.v1.Gkt.LogRootRequest lastVerified_;
    /**
     * <pre>
     * last_verified is the last log root the client verified.
     * Omitting this field will omit the log consistency proof from the response.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
     */
    @java.lang.Override
    public boolean hasLastVerified() {
      return lastVerified_ != null;
    }
    /**
     * <pre>
     * last_verified is the last log root the client verified.
     * Omitting this field will omit the log consistency proof from the response.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
     */
    @java.lang.Override
    public google.keytransparency.v1.Gkt.LogRootRequest getLastVerified() {
      return lastVerified_ == null ? google.keytransparency.v1.Gkt.LogRootRequest.getDefaultInstance() : lastVerified_;
    }
    /**
     * <pre>
     * last_verified is the last log root the client verified.
     * Omitting this field will omit the log consistency proof from the response.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
     */
    private void setLastVerified(google.keytransparency.v1.Gkt.LogRootRequest value) {
      value.getClass();
  lastVerified_ = value;
      
      }
    /**
     * <pre>
     * last_verified is the last log root the client verified.
     * Omitting this field will omit the log consistency proof from the response.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeLastVerified(google.keytransparency.v1.Gkt.LogRootRequest value) {
      value.getClass();
  if (lastVerified_ != null &&
          lastVerified_ != google.keytransparency.v1.Gkt.LogRootRequest.getDefaultInstance()) {
        lastVerified_ =
          google.keytransparency.v1.Gkt.LogRootRequest.newBuilder(lastVerified_).mergeFrom(value).buildPartial();
      } else {
        lastVerified_ = value;
      }
      
    }
    /**
     * <pre>
     * last_verified is the last log root the client verified.
     * Omitting this field will omit the log consistency proof from the response.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
     */
    private void clearLastVerified() {  lastVerified_ = null;
      
    }

    public static google.keytransparency.v1.Gkt.GetUserRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.GetUserRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.GetUserRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.GetUserRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.GetUserRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.GetUserRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.GetUserRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.GetUserRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.GetUserRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.GetUserRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.GetUserRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.GetUserRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.keytransparency.v1.Gkt.GetUserRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Gets the leaf entry for a user.
     * </pre>
     *
     * Protobuf type {@code google.keytransparency.v1.GetUserRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.keytransparency.v1.Gkt.GetUserRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.keytransparency.v1.GetUserRequest)
        google.keytransparency.v1.Gkt.GetUserRequestOrBuilder {
      // Construct using google.keytransparency.v1.Gkt.GetUserRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * directory_id identifies the directory in which the user lives.
       * </pre>
       *
       * <code>string directory_id = 1;</code>
       * @return The directoryId.
       */
      @java.lang.Override
      public java.lang.String getDirectoryId() {
        return instance.getDirectoryId();
      }
      /**
       * <pre>
       * directory_id identifies the directory in which the user lives.
       * </pre>
       *
       * <code>string directory_id = 1;</code>
       * @return The bytes for directoryId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDirectoryIdBytes() {
        return instance.getDirectoryIdBytes();
      }
      /**
       * <pre>
       * directory_id identifies the directory in which the user lives.
       * </pre>
       *
       * <code>string directory_id = 1;</code>
       * @param value The directoryId to set.
       * @return This builder for chaining.
       */
      public Builder setDirectoryId(
          java.lang.String value) {
        copyOnWrite();
        instance.setDirectoryId(value);
        return this;
      }
      /**
       * <pre>
       * directory_id identifies the directory in which the user lives.
       * </pre>
       *
       * <code>string directory_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDirectoryId() {
        copyOnWrite();
        instance.clearDirectoryId();
        return this;
      }
      /**
       * <pre>
       * directory_id identifies the directory in which the user lives.
       * </pre>
       *
       * <code>string directory_id = 1;</code>
       * @param value The bytes for directoryId to set.
       * @return This builder for chaining.
       */
      public Builder setDirectoryIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDirectoryIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * user_id is the user identifier, the format for which is defined by the
       * application.
       * </pre>
       *
       * <code>string user_id = 2;</code>
       * @return The userId.
       */
      @java.lang.Override
      public java.lang.String getUserId() {
        return instance.getUserId();
      }
      /**
       * <pre>
       * user_id is the user identifier, the format for which is defined by the
       * application.
       * </pre>
       *
       * <code>string user_id = 2;</code>
       * @return The bytes for userId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getUserIdBytes() {
        return instance.getUserIdBytes();
      }
      /**
       * <pre>
       * user_id is the user identifier, the format for which is defined by the
       * application.
       * </pre>
       *
       * <code>string user_id = 2;</code>
       * @param value The userId to set.
       * @return This builder for chaining.
       */
      public Builder setUserId(
          java.lang.String value) {
        copyOnWrite();
        instance.setUserId(value);
        return this;
      }
      /**
       * <pre>
       * user_id is the user identifier, the format for which is defined by the
       * application.
       * </pre>
       *
       * <code>string user_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearUserId() {
        copyOnWrite();
        instance.clearUserId();
        return this;
      }
      /**
       * <pre>
       * user_id is the user identifier, the format for which is defined by the
       * application.
       * </pre>
       *
       * <code>string user_id = 2;</code>
       * @param value The bytes for userId to set.
       * @return This builder for chaining.
       */
      public Builder setUserIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setUserIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * last_verified is the last log root the client verified.
       * Omitting this field will omit the log consistency proof from the response.
       * </pre>
       *
       * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
       */
      @java.lang.Override
      public boolean hasLastVerified() {
        return instance.hasLastVerified();
      }
      /**
       * <pre>
       * last_verified is the last log root the client verified.
       * Omitting this field will omit the log consistency proof from the response.
       * </pre>
       *
       * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
       */
      @java.lang.Override
      public google.keytransparency.v1.Gkt.LogRootRequest getLastVerified() {
        return instance.getLastVerified();
      }
      /**
       * <pre>
       * last_verified is the last log root the client verified.
       * Omitting this field will omit the log consistency proof from the response.
       * </pre>
       *
       * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
       */
      public Builder setLastVerified(google.keytransparency.v1.Gkt.LogRootRequest value) {
        copyOnWrite();
        instance.setLastVerified(value);
        return this;
        }
      /**
       * <pre>
       * last_verified is the last log root the client verified.
       * Omitting this field will omit the log consistency proof from the response.
       * </pre>
       *
       * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
       */
      public Builder setLastVerified(
          google.keytransparency.v1.Gkt.LogRootRequest.Builder builderForValue) {
        copyOnWrite();
        instance.setLastVerified(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * last_verified is the last log root the client verified.
       * Omitting this field will omit the log consistency proof from the response.
       * </pre>
       *
       * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
       */
      public Builder mergeLastVerified(google.keytransparency.v1.Gkt.LogRootRequest value) {
        copyOnWrite();
        instance.mergeLastVerified(value);
        return this;
      }
      /**
       * <pre>
       * last_verified is the last log root the client verified.
       * Omitting this field will omit the log consistency proof from the response.
       * </pre>
       *
       * <code>.google.keytransparency.v1.LogRootRequest last_verified = 4;</code>
       */
      public Builder clearLastVerified() {  copyOnWrite();
        instance.clearLastVerified();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.keytransparency.v1.GetUserRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.keytransparency.v1.Gkt.GetUserRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "directoryId_",
              "userId_",
              "lastVerified_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0004\u0003\u0000\u0000\u0000\u0001\u0208\u0002\u0208" +
                "\u0004\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.keytransparency.v1.Gkt.GetUserRequest> parser = PARSER;
          if (parser == null) {
            synchronized (google.keytransparency.v1.Gkt.GetUserRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.keytransparency.v1.Gkt.GetUserRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.keytransparency.v1.GetUserRequest)
    private static final google.keytransparency.v1.Gkt.GetUserRequest DEFAULT_INSTANCE;
    static {
      GetUserRequest defaultInstance = new GetUserRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GetUserRequest.class, defaultInstance);
    }

    public static google.keytransparency.v1.Gkt.GetUserRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GetUserRequest> PARSER;

    public static com.google.protobuf.Parser<GetUserRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface LogRootRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.keytransparency.v1.LogRootRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * root_hash is the root hash of the last log root the client verified.
     * </pre>
     *
     * <code>bytes root_hash = 1;</code>
     * @return The rootHash.
     */
    com.google.protobuf.ByteString getRootHash();

    /**
     * <pre>
     * tree_size is the tree size of the last log root the client verified.
     * </pre>
     *
     * <code>int64 tree_size = 2;</code>
     * @return The treeSize.
     */
    long getTreeSize();
  }
  /**
   * <pre>
   * LogRootRequest contains the information needed to request and verify LogRoot.
   * </pre>
   *
   * Protobuf type {@code google.keytransparency.v1.LogRootRequest}
   */
  public  static final class LogRootRequest extends
      com.google.protobuf.GeneratedMessageLite<
          LogRootRequest, LogRootRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:google.keytransparency.v1.LogRootRequest)
      LogRootRequestOrBuilder {
    private LogRootRequest() {
      rootHash_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int ROOT_HASH_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString rootHash_;
    /**
     * <pre>
     * root_hash is the root hash of the last log root the client verified.
     * </pre>
     *
     * <code>bytes root_hash = 1;</code>
     * @return The rootHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getRootHash() {
      return rootHash_;
    }
    /**
     * <pre>
     * root_hash is the root hash of the last log root the client verified.
     * </pre>
     *
     * <code>bytes root_hash = 1;</code>
     * @param value The rootHash to set.
     */
    private void setRootHash(com.google.protobuf.ByteString value) {
      value.getClass();
  
      rootHash_ = value;
    }
    /**
     * <pre>
     * root_hash is the root hash of the last log root the client verified.
     * </pre>
     *
     * <code>bytes root_hash = 1;</code>
     */
    private void clearRootHash() {
      
      rootHash_ = getDefaultInstance().getRootHash();
    }

    public static final int TREE_SIZE_FIELD_NUMBER = 2;
    private long treeSize_;
    /**
     * <pre>
     * tree_size is the tree size of the last log root the client verified.
     * </pre>
     *
     * <code>int64 tree_size = 2;</code>
     * @return The treeSize.
     */
    @java.lang.Override
    public long getTreeSize() {
      return treeSize_;
    }
    /**
     * <pre>
     * tree_size is the tree size of the last log root the client verified.
     * </pre>
     *
     * <code>int64 tree_size = 2;</code>
     * @param value The treeSize to set.
     */
    private void setTreeSize(long value) {
      
      treeSize_ = value;
    }
    /**
     * <pre>
     * tree_size is the tree size of the last log root the client verified.
     * </pre>
     *
     * <code>int64 tree_size = 2;</code>
     */
    private void clearTreeSize() {
      
      treeSize_ = 0L;
    }

    public static google.keytransparency.v1.Gkt.LogRootRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.LogRootRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.LogRootRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.LogRootRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.LogRootRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.LogRootRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.LogRootRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.LogRootRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.LogRootRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.LogRootRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.LogRootRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.LogRootRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.keytransparency.v1.Gkt.LogRootRequest prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * LogRootRequest contains the information needed to request and verify LogRoot.
     * </pre>
     *
     * Protobuf type {@code google.keytransparency.v1.LogRootRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.keytransparency.v1.Gkt.LogRootRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.keytransparency.v1.LogRootRequest)
        google.keytransparency.v1.Gkt.LogRootRequestOrBuilder {
      // Construct using google.keytransparency.v1.Gkt.LogRootRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * root_hash is the root hash of the last log root the client verified.
       * </pre>
       *
       * <code>bytes root_hash = 1;</code>
       * @return The rootHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getRootHash() {
        return instance.getRootHash();
      }
      /**
       * <pre>
       * root_hash is the root hash of the last log root the client verified.
       * </pre>
       *
       * <code>bytes root_hash = 1;</code>
       * @param value The rootHash to set.
       * @return This builder for chaining.
       */
      public Builder setRootHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRootHash(value);
        return this;
      }
      /**
       * <pre>
       * root_hash is the root hash of the last log root the client verified.
       * </pre>
       *
       * <code>bytes root_hash = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRootHash() {
        copyOnWrite();
        instance.clearRootHash();
        return this;
      }

      /**
       * <pre>
       * tree_size is the tree size of the last log root the client verified.
       * </pre>
       *
       * <code>int64 tree_size = 2;</code>
       * @return The treeSize.
       */
      @java.lang.Override
      public long getTreeSize() {
        return instance.getTreeSize();
      }
      /**
       * <pre>
       * tree_size is the tree size of the last log root the client verified.
       * </pre>
       *
       * <code>int64 tree_size = 2;</code>
       * @param value The treeSize to set.
       * @return This builder for chaining.
       */
      public Builder setTreeSize(long value) {
        copyOnWrite();
        instance.setTreeSize(value);
        return this;
      }
      /**
       * <pre>
       * tree_size is the tree size of the last log root the client verified.
       * </pre>
       *
       * <code>int64 tree_size = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearTreeSize() {
        copyOnWrite();
        instance.clearTreeSize();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.keytransparency.v1.LogRootRequest)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.keytransparency.v1.Gkt.LogRootRequest();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "rootHash_",
              "treeSize_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\n\u0002\u0002" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.keytransparency.v1.Gkt.LogRootRequest> parser = PARSER;
          if (parser == null) {
            synchronized (google.keytransparency.v1.Gkt.LogRootRequest.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.keytransparency.v1.Gkt.LogRootRequest>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.keytransparency.v1.LogRootRequest)
    private static final google.keytransparency.v1.Gkt.LogRootRequest DEFAULT_INSTANCE;
    static {
      LogRootRequest defaultInstance = new LogRootRequest();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        LogRootRequest.class, defaultInstance);
    }

    public static google.keytransparency.v1.Gkt.LogRootRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<LogRootRequest> PARSER;

    public static com.google.protobuf.Parser<LogRootRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GetUserResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.keytransparency.v1.GetUserResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * revision is the most recently published revision.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Revision revision = 1;</code>
     * @return Whether the revision field is set.
     */
    boolean hasRevision();
    /**
     * <pre>
     * revision is the most recently published revision.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Revision revision = 1;</code>
     * @return The revision.
     */
    google.keytransparency.v1.Gkt.Revision getRevision();

    /**
     * <pre>
     * leaf is the leaf entry for the requested user.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
     * @return Whether the leaf field is set.
     */
    boolean hasLeaf();
    /**
     * <pre>
     * leaf is the leaf entry for the requested user.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
     * @return The leaf.
     */
    google.keytransparency.v1.Gkt.MapLeaf getLeaf();
  }
  /**
   * <pre>
   * Contains the leaf entry for a user at the most recently published revision.
   * </pre>
   *
   * Protobuf type {@code google.keytransparency.v1.GetUserResponse}
   */
  public  static final class GetUserResponse extends
      com.google.protobuf.GeneratedMessageLite<
          GetUserResponse, GetUserResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:google.keytransparency.v1.GetUserResponse)
      GetUserResponseOrBuilder {
    private GetUserResponse() {
    }
    public static final int REVISION_FIELD_NUMBER = 1;
    private google.keytransparency.v1.Gkt.Revision revision_;
    /**
     * <pre>
     * revision is the most recently published revision.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Revision revision = 1;</code>
     */
    @java.lang.Override
    public boolean hasRevision() {
      return revision_ != null;
    }
    /**
     * <pre>
     * revision is the most recently published revision.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Revision revision = 1;</code>
     */
    @java.lang.Override
    public google.keytransparency.v1.Gkt.Revision getRevision() {
      return revision_ == null ? google.keytransparency.v1.Gkt.Revision.getDefaultInstance() : revision_;
    }
    /**
     * <pre>
     * revision is the most recently published revision.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Revision revision = 1;</code>
     */
    private void setRevision(google.keytransparency.v1.Gkt.Revision value) {
      value.getClass();
  revision_ = value;
      
      }
    /**
     * <pre>
     * revision is the most recently published revision.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Revision revision = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeRevision(google.keytransparency.v1.Gkt.Revision value) {
      value.getClass();
  if (revision_ != null &&
          revision_ != google.keytransparency.v1.Gkt.Revision.getDefaultInstance()) {
        revision_ =
          google.keytransparency.v1.Gkt.Revision.newBuilder(revision_).mergeFrom(value).buildPartial();
      } else {
        revision_ = value;
      }
      
    }
    /**
     * <pre>
     * revision is the most recently published revision.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Revision revision = 1;</code>
     */
    private void clearRevision() {  revision_ = null;
      
    }

    public static final int LEAF_FIELD_NUMBER = 2;
    private google.keytransparency.v1.Gkt.MapLeaf leaf_;
    /**
     * <pre>
     * leaf is the leaf entry for the requested user.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
     */
    @java.lang.Override
    public boolean hasLeaf() {
      return leaf_ != null;
    }
    /**
     * <pre>
     * leaf is the leaf entry for the requested user.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
     */
    @java.lang.Override
    public google.keytransparency.v1.Gkt.MapLeaf getLeaf() {
      return leaf_ == null ? google.keytransparency.v1.Gkt.MapLeaf.getDefaultInstance() : leaf_;
    }
    /**
     * <pre>
     * leaf is the leaf entry for the requested user.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
     */
    private void setLeaf(google.keytransparency.v1.Gkt.MapLeaf value) {
      value.getClass();
  leaf_ = value;
      
      }
    /**
     * <pre>
     * leaf is the leaf entry for the requested user.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeLeaf(google.keytransparency.v1.Gkt.MapLeaf value) {
      value.getClass();
  if (leaf_ != null &&
          leaf_ != google.keytransparency.v1.Gkt.MapLeaf.getDefaultInstance()) {
        leaf_ =
          google.keytransparency.v1.Gkt.MapLeaf.newBuilder(leaf_).mergeFrom(value).buildPartial();
      } else {
        leaf_ = value;
      }
      
    }
    /**
     * <pre>
     * leaf is the leaf entry for the requested user.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
     */
    private void clearLeaf() {  leaf_ = null;
      
    }

    public static google.keytransparency.v1.Gkt.GetUserResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.GetUserResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.GetUserResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.GetUserResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.GetUserResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.GetUserResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.GetUserResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.GetUserResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.GetUserResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.GetUserResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.GetUserResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.GetUserResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.keytransparency.v1.Gkt.GetUserResponse prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Contains the leaf entry for a user at the most recently published revision.
     * </pre>
     *
     * Protobuf type {@code google.keytransparency.v1.GetUserResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.keytransparency.v1.Gkt.GetUserResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.keytransparency.v1.GetUserResponse)
        google.keytransparency.v1.Gkt.GetUserResponseOrBuilder {
      // Construct using google.keytransparency.v1.Gkt.GetUserResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * revision is the most recently published revision.
       * </pre>
       *
       * <code>.google.keytransparency.v1.Revision revision = 1;</code>
       */
      @java.lang.Override
      public boolean hasRevision() {
        return instance.hasRevision();
      }
      /**
       * <pre>
       * revision is the most recently published revision.
       * </pre>
       *
       * <code>.google.keytransparency.v1.Revision revision = 1;</code>
       */
      @java.lang.Override
      public google.keytransparency.v1.Gkt.Revision getRevision() {
        return instance.getRevision();
      }
      /**
       * <pre>
       * revision is the most recently published revision.
       * </pre>
       *
       * <code>.google.keytransparency.v1.Revision revision = 1;</code>
       */
      public Builder setRevision(google.keytransparency.v1.Gkt.Revision value) {
        copyOnWrite();
        instance.setRevision(value);
        return this;
        }
      /**
       * <pre>
       * revision is the most recently published revision.
       * </pre>
       *
       * <code>.google.keytransparency.v1.Revision revision = 1;</code>
       */
      public Builder setRevision(
          google.keytransparency.v1.Gkt.Revision.Builder builderForValue) {
        copyOnWrite();
        instance.setRevision(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * revision is the most recently published revision.
       * </pre>
       *
       * <code>.google.keytransparency.v1.Revision revision = 1;</code>
       */
      public Builder mergeRevision(google.keytransparency.v1.Gkt.Revision value) {
        copyOnWrite();
        instance.mergeRevision(value);
        return this;
      }
      /**
       * <pre>
       * revision is the most recently published revision.
       * </pre>
       *
       * <code>.google.keytransparency.v1.Revision revision = 1;</code>
       */
      public Builder clearRevision() {  copyOnWrite();
        instance.clearRevision();
        return this;
      }

      /**
       * <pre>
       * leaf is the leaf entry for the requested user.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
       */
      @java.lang.Override
      public boolean hasLeaf() {
        return instance.hasLeaf();
      }
      /**
       * <pre>
       * leaf is the leaf entry for the requested user.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
       */
      @java.lang.Override
      public google.keytransparency.v1.Gkt.MapLeaf getLeaf() {
        return instance.getLeaf();
      }
      /**
       * <pre>
       * leaf is the leaf entry for the requested user.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
       */
      public Builder setLeaf(google.keytransparency.v1.Gkt.MapLeaf value) {
        copyOnWrite();
        instance.setLeaf(value);
        return this;
        }
      /**
       * <pre>
       * leaf is the leaf entry for the requested user.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
       */
      public Builder setLeaf(
          google.keytransparency.v1.Gkt.MapLeaf.Builder builderForValue) {
        copyOnWrite();
        instance.setLeaf(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * leaf is the leaf entry for the requested user.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
       */
      public Builder mergeLeaf(google.keytransparency.v1.Gkt.MapLeaf value) {
        copyOnWrite();
        instance.mergeLeaf(value);
        return this;
      }
      /**
       * <pre>
       * leaf is the leaf entry for the requested user.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapLeaf leaf = 2;</code>
       */
      public Builder clearLeaf() {  copyOnWrite();
        instance.clearLeaf();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.keytransparency.v1.GetUserResponse)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.keytransparency.v1.Gkt.GetUserResponse();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "revision_",
              "leaf_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\t\u0002\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.keytransparency.v1.Gkt.GetUserResponse> parser = PARSER;
          if (parser == null) {
            synchronized (google.keytransparency.v1.Gkt.GetUserResponse.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.keytransparency.v1.Gkt.GetUserResponse>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.keytransparency.v1.GetUserResponse)
    private static final google.keytransparency.v1.Gkt.GetUserResponse DEFAULT_INSTANCE;
    static {
      GetUserResponse defaultInstance = new GetUserResponse();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GetUserResponse.class, defaultInstance);
    }

    public static google.keytransparency.v1.Gkt.GetUserResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GetUserResponse> PARSER;

    public static com.google.protobuf.Parser<GetUserResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RevisionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.keytransparency.v1.Revision)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * directory_id is the directory identifier.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     * @return The directoryId.
     */
    java.lang.String getDirectoryId();
    /**
     * <pre>
     * directory_id is the directory identifier.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     * @return The bytes for directoryId.
     */
    com.google.protobuf.ByteString
        getDirectoryIdBytes();

    /**
     * <pre>
     * map_root contains the map root and its inclusion in the log.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
     * @return Whether the mapRoot field is set.
     */
    boolean hasMapRoot();
    /**
     * <pre>
     * map_root contains the map root and its inclusion in the log.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
     * @return The mapRoot.
     */
    google.keytransparency.v1.Gkt.MapRoot getMapRoot();

    /**
     * <pre>
     * latest_log_root contains the most recent log root and its consistency
     * proof to the client's last seen log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
     * @return Whether the latestLogRoot field is set.
     */
    boolean hasLatestLogRoot();
    /**
     * <pre>
     * latest_log_root contains the most recent log root and its consistency
     * proof to the client's last seen log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
     * @return The latestLogRoot.
     */
    google.keytransparency.v1.Gkt.LogRoot getLatestLogRoot();
  }
  /**
   * <pre>
   * Revision represents a snapshot of the entire key directory and
   * a diff of what changed between this revision and the previous revision.
   * </pre>
   *
   * Protobuf type {@code google.keytransparency.v1.Revision}
   */
  public  static final class Revision extends
      com.google.protobuf.GeneratedMessageLite<
          Revision, Revision.Builder> implements
      // @@protoc_insertion_point(message_implements:google.keytransparency.v1.Revision)
      RevisionOrBuilder {
    private Revision() {
      directoryId_ = "";
    }
    public static final int DIRECTORY_ID_FIELD_NUMBER = 1;
    private java.lang.String directoryId_;
    /**
     * <pre>
     * directory_id is the directory identifier.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     * @return The directoryId.
     */
    @java.lang.Override
    public java.lang.String getDirectoryId() {
      return directoryId_;
    }
    /**
     * <pre>
     * directory_id is the directory identifier.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     * @return The bytes for directoryId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDirectoryIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(directoryId_);
    }
    /**
     * <pre>
     * directory_id is the directory identifier.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     * @param value The directoryId to set.
     */
    private void setDirectoryId(
        java.lang.String value) {
      value.getClass();
  
      directoryId_ = value;
    }
    /**
     * <pre>
     * directory_id is the directory identifier.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     */
    private void clearDirectoryId() {
      
      directoryId_ = getDefaultInstance().getDirectoryId();
    }
    /**
     * <pre>
     * directory_id is the directory identifier.
     * </pre>
     *
     * <code>string directory_id = 1;</code>
     * @param value The bytes for directoryId to set.
     */
    private void setDirectoryIdBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      directoryId_ = value.toStringUtf8();
      
    }

    public static final int MAP_ROOT_FIELD_NUMBER = 5;
    private google.keytransparency.v1.Gkt.MapRoot mapRoot_;
    /**
     * <pre>
     * map_root contains the map root and its inclusion in the log.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
     */
    @java.lang.Override
    public boolean hasMapRoot() {
      return mapRoot_ != null;
    }
    /**
     * <pre>
     * map_root contains the map root and its inclusion in the log.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
     */
    @java.lang.Override
    public google.keytransparency.v1.Gkt.MapRoot getMapRoot() {
      return mapRoot_ == null ? google.keytransparency.v1.Gkt.MapRoot.getDefaultInstance() : mapRoot_;
    }
    /**
     * <pre>
     * map_root contains the map root and its inclusion in the log.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
     */
    private void setMapRoot(google.keytransparency.v1.Gkt.MapRoot value) {
      value.getClass();
  mapRoot_ = value;
      
      }
    /**
     * <pre>
     * map_root contains the map root and its inclusion in the log.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeMapRoot(google.keytransparency.v1.Gkt.MapRoot value) {
      value.getClass();
  if (mapRoot_ != null &&
          mapRoot_ != google.keytransparency.v1.Gkt.MapRoot.getDefaultInstance()) {
        mapRoot_ =
          google.keytransparency.v1.Gkt.MapRoot.newBuilder(mapRoot_).mergeFrom(value).buildPartial();
      } else {
        mapRoot_ = value;
      }
      
    }
    /**
     * <pre>
     * map_root contains the map root and its inclusion in the log.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
     */
    private void clearMapRoot() {  mapRoot_ = null;
      
    }

    public static final int LATEST_LOG_ROOT_FIELD_NUMBER = 6;
    private google.keytransparency.v1.Gkt.LogRoot latestLogRoot_;
    /**
     * <pre>
     * latest_log_root contains the most recent log root and its consistency
     * proof to the client's last seen log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
     */
    @java.lang.Override
    public boolean hasLatestLogRoot() {
      return latestLogRoot_ != null;
    }
    /**
     * <pre>
     * latest_log_root contains the most recent log root and its consistency
     * proof to the client's last seen log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
     */
    @java.lang.Override
    public google.keytransparency.v1.Gkt.LogRoot getLatestLogRoot() {
      return latestLogRoot_ == null ? google.keytransparency.v1.Gkt.LogRoot.getDefaultInstance() : latestLogRoot_;
    }
    /**
     * <pre>
     * latest_log_root contains the most recent log root and its consistency
     * proof to the client's last seen log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
     */
    private void setLatestLogRoot(google.keytransparency.v1.Gkt.LogRoot value) {
      value.getClass();
  latestLogRoot_ = value;
      
      }
    /**
     * <pre>
     * latest_log_root contains the most recent log root and its consistency
     * proof to the client's last seen log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeLatestLogRoot(google.keytransparency.v1.Gkt.LogRoot value) {
      value.getClass();
  if (latestLogRoot_ != null &&
          latestLogRoot_ != google.keytransparency.v1.Gkt.LogRoot.getDefaultInstance()) {
        latestLogRoot_ =
          google.keytransparency.v1.Gkt.LogRoot.newBuilder(latestLogRoot_).mergeFrom(value).buildPartial();
      } else {
        latestLogRoot_ = value;
      }
      
    }
    /**
     * <pre>
     * latest_log_root contains the most recent log root and its consistency
     * proof to the client's last seen log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
     */
    private void clearLatestLogRoot() {  latestLogRoot_ = null;
      
    }

    public static google.keytransparency.v1.Gkt.Revision parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.Revision parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.Revision parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.Revision parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.Revision parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.Revision parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.Revision parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.Revision parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.Revision parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.Revision parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.Revision parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.Revision parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.keytransparency.v1.Gkt.Revision prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Revision represents a snapshot of the entire key directory and
     * a diff of what changed between this revision and the previous revision.
     * </pre>
     *
     * Protobuf type {@code google.keytransparency.v1.Revision}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.keytransparency.v1.Gkt.Revision, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.keytransparency.v1.Revision)
        google.keytransparency.v1.Gkt.RevisionOrBuilder {
      // Construct using google.keytransparency.v1.Gkt.Revision.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * directory_id is the directory identifier.
       * </pre>
       *
       * <code>string directory_id = 1;</code>
       * @return The directoryId.
       */
      @java.lang.Override
      public java.lang.String getDirectoryId() {
        return instance.getDirectoryId();
      }
      /**
       * <pre>
       * directory_id is the directory identifier.
       * </pre>
       *
       * <code>string directory_id = 1;</code>
       * @return The bytes for directoryId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDirectoryIdBytes() {
        return instance.getDirectoryIdBytes();
      }
      /**
       * <pre>
       * directory_id is the directory identifier.
       * </pre>
       *
       * <code>string directory_id = 1;</code>
       * @param value The directoryId to set.
       * @return This builder for chaining.
       */
      public Builder setDirectoryId(
          java.lang.String value) {
        copyOnWrite();
        instance.setDirectoryId(value);
        return this;
      }
      /**
       * <pre>
       * directory_id is the directory identifier.
       * </pre>
       *
       * <code>string directory_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDirectoryId() {
        copyOnWrite();
        instance.clearDirectoryId();
        return this;
      }
      /**
       * <pre>
       * directory_id is the directory identifier.
       * </pre>
       *
       * <code>string directory_id = 1;</code>
       * @param value The bytes for directoryId to set.
       * @return This builder for chaining.
       */
      public Builder setDirectoryIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDirectoryIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * map_root contains the map root and its inclusion in the log.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
       */
      @java.lang.Override
      public boolean hasMapRoot() {
        return instance.hasMapRoot();
      }
      /**
       * <pre>
       * map_root contains the map root and its inclusion in the log.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
       */
      @java.lang.Override
      public google.keytransparency.v1.Gkt.MapRoot getMapRoot() {
        return instance.getMapRoot();
      }
      /**
       * <pre>
       * map_root contains the map root and its inclusion in the log.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
       */
      public Builder setMapRoot(google.keytransparency.v1.Gkt.MapRoot value) {
        copyOnWrite();
        instance.setMapRoot(value);
        return this;
        }
      /**
       * <pre>
       * map_root contains the map root and its inclusion in the log.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
       */
      public Builder setMapRoot(
          google.keytransparency.v1.Gkt.MapRoot.Builder builderForValue) {
        copyOnWrite();
        instance.setMapRoot(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * map_root contains the map root and its inclusion in the log.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
       */
      public Builder mergeMapRoot(google.keytransparency.v1.Gkt.MapRoot value) {
        copyOnWrite();
        instance.mergeMapRoot(value);
        return this;
      }
      /**
       * <pre>
       * map_root contains the map root and its inclusion in the log.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapRoot map_root = 5;</code>
       */
      public Builder clearMapRoot() {  copyOnWrite();
        instance.clearMapRoot();
        return this;
      }

      /**
       * <pre>
       * latest_log_root contains the most recent log root and its consistency
       * proof to the client's last seen log root.
       * </pre>
       *
       * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
       */
      @java.lang.Override
      public boolean hasLatestLogRoot() {
        return instance.hasLatestLogRoot();
      }
      /**
       * <pre>
       * latest_log_root contains the most recent log root and its consistency
       * proof to the client's last seen log root.
       * </pre>
       *
       * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
       */
      @java.lang.Override
      public google.keytransparency.v1.Gkt.LogRoot getLatestLogRoot() {
        return instance.getLatestLogRoot();
      }
      /**
       * <pre>
       * latest_log_root contains the most recent log root and its consistency
       * proof to the client's last seen log root.
       * </pre>
       *
       * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
       */
      public Builder setLatestLogRoot(google.keytransparency.v1.Gkt.LogRoot value) {
        copyOnWrite();
        instance.setLatestLogRoot(value);
        return this;
        }
      /**
       * <pre>
       * latest_log_root contains the most recent log root and its consistency
       * proof to the client's last seen log root.
       * </pre>
       *
       * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
       */
      public Builder setLatestLogRoot(
          google.keytransparency.v1.Gkt.LogRoot.Builder builderForValue) {
        copyOnWrite();
        instance.setLatestLogRoot(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * latest_log_root contains the most recent log root and its consistency
       * proof to the client's last seen log root.
       * </pre>
       *
       * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
       */
      public Builder mergeLatestLogRoot(google.keytransparency.v1.Gkt.LogRoot value) {
        copyOnWrite();
        instance.mergeLatestLogRoot(value);
        return this;
      }
      /**
       * <pre>
       * latest_log_root contains the most recent log root and its consistency
       * proof to the client's last seen log root.
       * </pre>
       *
       * <code>.google.keytransparency.v1.LogRoot latest_log_root = 6;</code>
       */
      public Builder clearLatestLogRoot() {  copyOnWrite();
        instance.clearLatestLogRoot();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.keytransparency.v1.Revision)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.keytransparency.v1.Gkt.Revision();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "directoryId_",
              "mapRoot_",
              "latestLogRoot_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0006\u0003\u0000\u0000\u0000\u0001\u0208\u0005\t" +
                "\u0006\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.keytransparency.v1.Gkt.Revision> parser = PARSER;
          if (parser == null) {
            synchronized (google.keytransparency.v1.Gkt.Revision.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.keytransparency.v1.Gkt.Revision>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.keytransparency.v1.Revision)
    private static final google.keytransparency.v1.Gkt.Revision DEFAULT_INSTANCE;
    static {
      Revision defaultInstance = new Revision();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Revision.class, defaultInstance);
    }

    public static google.keytransparency.v1.Gkt.Revision getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Revision> PARSER;

    public static com.google.protobuf.Parser<Revision> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MapRootOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.keytransparency.v1.MapRoot)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * map_root contains the signed map root for the sparse Merkle Tree.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
     * @return Whether the mapRoot field is set.
     */
    boolean hasMapRoot();
    /**
     * <pre>
     * map_root contains the signed map root for the sparse Merkle Tree.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
     * @return The mapRoot.
     */
    google.keytransparency.v1.Gkt.SignedMapRoot getMapRoot();

    /**
     * <pre>
     * log_inclusion proves that map_root is part of log_root at
     * index=map_root.MapRevision.
     * </pre>
     *
     * <code>repeated bytes log_inclusion = 2;</code>
     * @return A list containing the logInclusion.
     */
    java.util.List<com.google.protobuf.ByteString> getLogInclusionList();
    /**
     * <pre>
     * log_inclusion proves that map_root is part of log_root at
     * index=map_root.MapRevision.
     * </pre>
     *
     * <code>repeated bytes log_inclusion = 2;</code>
     * @return The count of logInclusion.
     */
    int getLogInclusionCount();
    /**
     * <pre>
     * log_inclusion proves that map_root is part of log_root at
     * index=map_root.MapRevision.
     * </pre>
     *
     * <code>repeated bytes log_inclusion = 2;</code>
     * @param index The index of the element to return.
     * @return The logInclusion at the given index.
     */
    com.google.protobuf.ByteString getLogInclusion(int index);
  }
  /**
   * <pre>
   * MapRoot contains the map root and its inclusion proof in the log.
   * </pre>
   *
   * Protobuf type {@code google.keytransparency.v1.MapRoot}
   */
  public  static final class MapRoot extends
      com.google.protobuf.GeneratedMessageLite<
          MapRoot, MapRoot.Builder> implements
      // @@protoc_insertion_point(message_implements:google.keytransparency.v1.MapRoot)
      MapRootOrBuilder {
    private MapRoot() {
      logInclusion_ = emptyProtobufList();
    }
    public static final int MAP_ROOT_FIELD_NUMBER = 1;
    private google.keytransparency.v1.Gkt.SignedMapRoot mapRoot_;
    /**
     * <pre>
     * map_root contains the signed map root for the sparse Merkle Tree.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
     */
    @java.lang.Override
    public boolean hasMapRoot() {
      return mapRoot_ != null;
    }
    /**
     * <pre>
     * map_root contains the signed map root for the sparse Merkle Tree.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
     */
    @java.lang.Override
    public google.keytransparency.v1.Gkt.SignedMapRoot getMapRoot() {
      return mapRoot_ == null ? google.keytransparency.v1.Gkt.SignedMapRoot.getDefaultInstance() : mapRoot_;
    }
    /**
     * <pre>
     * map_root contains the signed map root for the sparse Merkle Tree.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
     */
    private void setMapRoot(google.keytransparency.v1.Gkt.SignedMapRoot value) {
      value.getClass();
  mapRoot_ = value;
      
      }
    /**
     * <pre>
     * map_root contains the signed map root for the sparse Merkle Tree.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeMapRoot(google.keytransparency.v1.Gkt.SignedMapRoot value) {
      value.getClass();
  if (mapRoot_ != null &&
          mapRoot_ != google.keytransparency.v1.Gkt.SignedMapRoot.getDefaultInstance()) {
        mapRoot_ =
          google.keytransparency.v1.Gkt.SignedMapRoot.newBuilder(mapRoot_).mergeFrom(value).buildPartial();
      } else {
        mapRoot_ = value;
      }
      
    }
    /**
     * <pre>
     * map_root contains the signed map root for the sparse Merkle Tree.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
     */
    private void clearMapRoot() {  mapRoot_ = null;
      
    }

    public static final int LOG_INCLUSION_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> logInclusion_;
    /**
     * <pre>
     * log_inclusion proves that map_root is part of log_root at
     * index=map_root.MapRevision.
     * </pre>
     *
     * <code>repeated bytes log_inclusion = 2;</code>
     * @return A list containing the logInclusion.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getLogInclusionList() {
      return logInclusion_;
    }
    /**
     * <pre>
     * log_inclusion proves that map_root is part of log_root at
     * index=map_root.MapRevision.
     * </pre>
     *
     * <code>repeated bytes log_inclusion = 2;</code>
     * @return The count of logInclusion.
     */
    @java.lang.Override
    public int getLogInclusionCount() {
      return logInclusion_.size();
    }
    /**
     * <pre>
     * log_inclusion proves that map_root is part of log_root at
     * index=map_root.MapRevision.
     * </pre>
     *
     * <code>repeated bytes log_inclusion = 2;</code>
     * @param index The index of the element to return.
     * @return The logInclusion at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLogInclusion(int index) {
      return logInclusion_.get(index);
    }
    private void ensureLogInclusionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> tmp = logInclusion_;
      if (!tmp.isModifiable()) {
        logInclusion_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * log_inclusion proves that map_root is part of log_root at
     * index=map_root.MapRevision.
     * </pre>
     *
     * <code>repeated bytes log_inclusion = 2;</code>
     * @param index The index to set the value at.
     * @param value The logInclusion to set.
     */
    private void setLogInclusion(
        int index, com.google.protobuf.ByteString value) {
      value.getClass();
  ensureLogInclusionIsMutable();
      logInclusion_.set(index, value);
    }
    /**
     * <pre>
     * log_inclusion proves that map_root is part of log_root at
     * index=map_root.MapRevision.
     * </pre>
     *
     * <code>repeated bytes log_inclusion = 2;</code>
     * @param value The logInclusion to add.
     */
    private void addLogInclusion(com.google.protobuf.ByteString value) {
      value.getClass();
  ensureLogInclusionIsMutable();
      logInclusion_.add(value);
    }
    /**
     * <pre>
     * log_inclusion proves that map_root is part of log_root at
     * index=map_root.MapRevision.
     * </pre>
     *
     * <code>repeated bytes log_inclusion = 2;</code>
     * @param values The logInclusion to add.
     */
    private void addAllLogInclusion(
        java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
      ensureLogInclusionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, logInclusion_);
    }
    /**
     * <pre>
     * log_inclusion proves that map_root is part of log_root at
     * index=map_root.MapRevision.
     * </pre>
     *
     * <code>repeated bytes log_inclusion = 2;</code>
     */
    private void clearLogInclusion() {
      logInclusion_ = emptyProtobufList();
    }

    public static google.keytransparency.v1.Gkt.MapRoot parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.MapRoot parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapRoot parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.MapRoot parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapRoot parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.MapRoot parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapRoot parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.MapRoot parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapRoot parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.MapRoot parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapRoot parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.MapRoot parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.keytransparency.v1.Gkt.MapRoot prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * MapRoot contains the map root and its inclusion proof in the log.
     * </pre>
     *
     * Protobuf type {@code google.keytransparency.v1.MapRoot}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.keytransparency.v1.Gkt.MapRoot, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.keytransparency.v1.MapRoot)
        google.keytransparency.v1.Gkt.MapRootOrBuilder {
      // Construct using google.keytransparency.v1.Gkt.MapRoot.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * map_root contains the signed map root for the sparse Merkle Tree.
       * </pre>
       *
       * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
       */
      @java.lang.Override
      public boolean hasMapRoot() {
        return instance.hasMapRoot();
      }
      /**
       * <pre>
       * map_root contains the signed map root for the sparse Merkle Tree.
       * </pre>
       *
       * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
       */
      @java.lang.Override
      public google.keytransparency.v1.Gkt.SignedMapRoot getMapRoot() {
        return instance.getMapRoot();
      }
      /**
       * <pre>
       * map_root contains the signed map root for the sparse Merkle Tree.
       * </pre>
       *
       * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
       */
      public Builder setMapRoot(google.keytransparency.v1.Gkt.SignedMapRoot value) {
        copyOnWrite();
        instance.setMapRoot(value);
        return this;
        }
      /**
       * <pre>
       * map_root contains the signed map root for the sparse Merkle Tree.
       * </pre>
       *
       * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
       */
      public Builder setMapRoot(
          google.keytransparency.v1.Gkt.SignedMapRoot.Builder builderForValue) {
        copyOnWrite();
        instance.setMapRoot(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * map_root contains the signed map root for the sparse Merkle Tree.
       * </pre>
       *
       * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
       */
      public Builder mergeMapRoot(google.keytransparency.v1.Gkt.SignedMapRoot value) {
        copyOnWrite();
        instance.mergeMapRoot(value);
        return this;
      }
      /**
       * <pre>
       * map_root contains the signed map root for the sparse Merkle Tree.
       * </pre>
       *
       * <code>.google.keytransparency.v1.SignedMapRoot map_root = 1;</code>
       */
      public Builder clearMapRoot() {  copyOnWrite();
        instance.clearMapRoot();
        return this;
      }

      /**
       * <pre>
       * log_inclusion proves that map_root is part of log_root at
       * index=map_root.MapRevision.
       * </pre>
       *
       * <code>repeated bytes log_inclusion = 2;</code>
       * @return A list containing the logInclusion.
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.ByteString>
          getLogInclusionList() {
        return java.util.Collections.unmodifiableList(
            instance.getLogInclusionList());
      }
      /**
       * <pre>
       * log_inclusion proves that map_root is part of log_root at
       * index=map_root.MapRevision.
       * </pre>
       *
       * <code>repeated bytes log_inclusion = 2;</code>
       * @return The count of logInclusion.
       */
      @java.lang.Override
      public int getLogInclusionCount() {
        return instance.getLogInclusionCount();
      }
      /**
       * <pre>
       * log_inclusion proves that map_root is part of log_root at
       * index=map_root.MapRevision.
       * </pre>
       *
       * <code>repeated bytes log_inclusion = 2;</code>
       * @param index The index of the element to return.
       * @return The logInclusion at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLogInclusion(int index) {
        return instance.getLogInclusion(index);
      }
      /**
       * <pre>
       * log_inclusion proves that map_root is part of log_root at
       * index=map_root.MapRevision.
       * </pre>
       *
       * <code>repeated bytes log_inclusion = 2;</code>
       * @param value The logInclusion to set.
       * @return This builder for chaining.
       */
      public Builder setLogInclusion(
          int index, com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLogInclusion(index, value);
        return this;
      }
      /**
       * <pre>
       * log_inclusion proves that map_root is part of log_root at
       * index=map_root.MapRevision.
       * </pre>
       *
       * <code>repeated bytes log_inclusion = 2;</code>
       * @param value The logInclusion to add.
       * @return This builder for chaining.
       */
      public Builder addLogInclusion(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addLogInclusion(value);
        return this;
      }
      /**
       * <pre>
       * log_inclusion proves that map_root is part of log_root at
       * index=map_root.MapRevision.
       * </pre>
       *
       * <code>repeated bytes log_inclusion = 2;</code>
       * @param values The logInclusion to add.
       * @return This builder for chaining.
       */
      public Builder addAllLogInclusion(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.addAllLogInclusion(values);
        return this;
      }
      /**
       * <pre>
       * log_inclusion proves that map_root is part of log_root at
       * index=map_root.MapRevision.
       * </pre>
       *
       * <code>repeated bytes log_inclusion = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLogInclusion() {
        copyOnWrite();
        instance.clearLogInclusion();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.keytransparency.v1.MapRoot)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.keytransparency.v1.Gkt.MapRoot();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "mapRoot_",
              "logInclusion_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0001\u0000\u0001\t\u0002\u001c" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.keytransparency.v1.Gkt.MapRoot> parser = PARSER;
          if (parser == null) {
            synchronized (google.keytransparency.v1.Gkt.MapRoot.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.keytransparency.v1.Gkt.MapRoot>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.keytransparency.v1.MapRoot)
    private static final google.keytransparency.v1.Gkt.MapRoot DEFAULT_INSTANCE;
    static {
      MapRoot defaultInstance = new MapRoot();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MapRoot.class, defaultInstance);
    }

    public static google.keytransparency.v1.Gkt.MapRoot getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MapRoot> PARSER;

    public static com.google.protobuf.Parser<MapRoot> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface LogRootOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.keytransparency.v1.LogRoot)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * log_root is the latest globally consistent log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
     * @return Whether the logRoot field is set.
     */
    boolean hasLogRoot();
    /**
     * <pre>
     * log_root is the latest globally consistent log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
     * @return The logRoot.
     */
    google.keytransparency.v1.Gkt.SignedLogRoot getLogRoot();

    /**
     * <pre>
     * log_consistency proves that log_root is consistent with previously seen
     * roots.
     * </pre>
     *
     * <code>repeated bytes log_consistency = 2;</code>
     * @return A list containing the logConsistency.
     */
    java.util.List<com.google.protobuf.ByteString> getLogConsistencyList();
    /**
     * <pre>
     * log_consistency proves that log_root is consistent with previously seen
     * roots.
     * </pre>
     *
     * <code>repeated bytes log_consistency = 2;</code>
     * @return The count of logConsistency.
     */
    int getLogConsistencyCount();
    /**
     * <pre>
     * log_consistency proves that log_root is consistent with previously seen
     * roots.
     * </pre>
     *
     * <code>repeated bytes log_consistency = 2;</code>
     * @param index The index of the element to return.
     * @return The logConsistency at the given index.
     */
    com.google.protobuf.ByteString getLogConsistency(int index);
  }
  /**
   * <pre>
   * LogRoot contains the latest log root and its consistency proof.
   * </pre>
   *
   * Protobuf type {@code google.keytransparency.v1.LogRoot}
   */
  public  static final class LogRoot extends
      com.google.protobuf.GeneratedMessageLite<
          LogRoot, LogRoot.Builder> implements
      // @@protoc_insertion_point(message_implements:google.keytransparency.v1.LogRoot)
      LogRootOrBuilder {
    private LogRoot() {
      logConsistency_ = emptyProtobufList();
    }
    public static final int LOG_ROOT_FIELD_NUMBER = 1;
    private google.keytransparency.v1.Gkt.SignedLogRoot logRoot_;
    /**
     * <pre>
     * log_root is the latest globally consistent log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
     */
    @java.lang.Override
    public boolean hasLogRoot() {
      return logRoot_ != null;
    }
    /**
     * <pre>
     * log_root is the latest globally consistent log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
     */
    @java.lang.Override
    public google.keytransparency.v1.Gkt.SignedLogRoot getLogRoot() {
      return logRoot_ == null ? google.keytransparency.v1.Gkt.SignedLogRoot.getDefaultInstance() : logRoot_;
    }
    /**
     * <pre>
     * log_root is the latest globally consistent log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
     */
    private void setLogRoot(google.keytransparency.v1.Gkt.SignedLogRoot value) {
      value.getClass();
  logRoot_ = value;
      
      }
    /**
     * <pre>
     * log_root is the latest globally consistent log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeLogRoot(google.keytransparency.v1.Gkt.SignedLogRoot value) {
      value.getClass();
  if (logRoot_ != null &&
          logRoot_ != google.keytransparency.v1.Gkt.SignedLogRoot.getDefaultInstance()) {
        logRoot_ =
          google.keytransparency.v1.Gkt.SignedLogRoot.newBuilder(logRoot_).mergeFrom(value).buildPartial();
      } else {
        logRoot_ = value;
      }
      
    }
    /**
     * <pre>
     * log_root is the latest globally consistent log root.
     * </pre>
     *
     * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
     */
    private void clearLogRoot() {  logRoot_ = null;
      
    }

    public static final int LOG_CONSISTENCY_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> logConsistency_;
    /**
     * <pre>
     * log_consistency proves that log_root is consistent with previously seen
     * roots.
     * </pre>
     *
     * <code>repeated bytes log_consistency = 2;</code>
     * @return A list containing the logConsistency.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getLogConsistencyList() {
      return logConsistency_;
    }
    /**
     * <pre>
     * log_consistency proves that log_root is consistent with previously seen
     * roots.
     * </pre>
     *
     * <code>repeated bytes log_consistency = 2;</code>
     * @return The count of logConsistency.
     */
    @java.lang.Override
    public int getLogConsistencyCount() {
      return logConsistency_.size();
    }
    /**
     * <pre>
     * log_consistency proves that log_root is consistent with previously seen
     * roots.
     * </pre>
     *
     * <code>repeated bytes log_consistency = 2;</code>
     * @param index The index of the element to return.
     * @return The logConsistency at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLogConsistency(int index) {
      return logConsistency_.get(index);
    }
    private void ensureLogConsistencyIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> tmp = logConsistency_;
      if (!tmp.isModifiable()) {
        logConsistency_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * log_consistency proves that log_root is consistent with previously seen
     * roots.
     * </pre>
     *
     * <code>repeated bytes log_consistency = 2;</code>
     * @param index The index to set the value at.
     * @param value The logConsistency to set.
     */
    private void setLogConsistency(
        int index, com.google.protobuf.ByteString value) {
      value.getClass();
  ensureLogConsistencyIsMutable();
      logConsistency_.set(index, value);
    }
    /**
     * <pre>
     * log_consistency proves that log_root is consistent with previously seen
     * roots.
     * </pre>
     *
     * <code>repeated bytes log_consistency = 2;</code>
     * @param value The logConsistency to add.
     */
    private void addLogConsistency(com.google.protobuf.ByteString value) {
      value.getClass();
  ensureLogConsistencyIsMutable();
      logConsistency_.add(value);
    }
    /**
     * <pre>
     * log_consistency proves that log_root is consistent with previously seen
     * roots.
     * </pre>
     *
     * <code>repeated bytes log_consistency = 2;</code>
     * @param values The logConsistency to add.
     */
    private void addAllLogConsistency(
        java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
      ensureLogConsistencyIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, logConsistency_);
    }
    /**
     * <pre>
     * log_consistency proves that log_root is consistent with previously seen
     * roots.
     * </pre>
     *
     * <code>repeated bytes log_consistency = 2;</code>
     */
    private void clearLogConsistency() {
      logConsistency_ = emptyProtobufList();
    }

    public static google.keytransparency.v1.Gkt.LogRoot parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.LogRoot parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.LogRoot parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.LogRoot parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.LogRoot parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.LogRoot parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.LogRoot parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.LogRoot parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.LogRoot parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.LogRoot parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.LogRoot parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.LogRoot parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.keytransparency.v1.Gkt.LogRoot prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * LogRoot contains the latest log root and its consistency proof.
     * </pre>
     *
     * Protobuf type {@code google.keytransparency.v1.LogRoot}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.keytransparency.v1.Gkt.LogRoot, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.keytransparency.v1.LogRoot)
        google.keytransparency.v1.Gkt.LogRootOrBuilder {
      // Construct using google.keytransparency.v1.Gkt.LogRoot.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * log_root is the latest globally consistent log root.
       * </pre>
       *
       * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
       */
      @java.lang.Override
      public boolean hasLogRoot() {
        return instance.hasLogRoot();
      }
      /**
       * <pre>
       * log_root is the latest globally consistent log root.
       * </pre>
       *
       * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
       */
      @java.lang.Override
      public google.keytransparency.v1.Gkt.SignedLogRoot getLogRoot() {
        return instance.getLogRoot();
      }
      /**
       * <pre>
       * log_root is the latest globally consistent log root.
       * </pre>
       *
       * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
       */
      public Builder setLogRoot(google.keytransparency.v1.Gkt.SignedLogRoot value) {
        copyOnWrite();
        instance.setLogRoot(value);
        return this;
        }
      /**
       * <pre>
       * log_root is the latest globally consistent log root.
       * </pre>
       *
       * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
       */
      public Builder setLogRoot(
          google.keytransparency.v1.Gkt.SignedLogRoot.Builder builderForValue) {
        copyOnWrite();
        instance.setLogRoot(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * log_root is the latest globally consistent log root.
       * </pre>
       *
       * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
       */
      public Builder mergeLogRoot(google.keytransparency.v1.Gkt.SignedLogRoot value) {
        copyOnWrite();
        instance.mergeLogRoot(value);
        return this;
      }
      /**
       * <pre>
       * log_root is the latest globally consistent log root.
       * </pre>
       *
       * <code>.google.keytransparency.v1.SignedLogRoot log_root = 1;</code>
       */
      public Builder clearLogRoot() {  copyOnWrite();
        instance.clearLogRoot();
        return this;
      }

      /**
       * <pre>
       * log_consistency proves that log_root is consistent with previously seen
       * roots.
       * </pre>
       *
       * <code>repeated bytes log_consistency = 2;</code>
       * @return A list containing the logConsistency.
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.ByteString>
          getLogConsistencyList() {
        return java.util.Collections.unmodifiableList(
            instance.getLogConsistencyList());
      }
      /**
       * <pre>
       * log_consistency proves that log_root is consistent with previously seen
       * roots.
       * </pre>
       *
       * <code>repeated bytes log_consistency = 2;</code>
       * @return The count of logConsistency.
       */
      @java.lang.Override
      public int getLogConsistencyCount() {
        return instance.getLogConsistencyCount();
      }
      /**
       * <pre>
       * log_consistency proves that log_root is consistent with previously seen
       * roots.
       * </pre>
       *
       * <code>repeated bytes log_consistency = 2;</code>
       * @param index The index of the element to return.
       * @return The logConsistency at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLogConsistency(int index) {
        return instance.getLogConsistency(index);
      }
      /**
       * <pre>
       * log_consistency proves that log_root is consistent with previously seen
       * roots.
       * </pre>
       *
       * <code>repeated bytes log_consistency = 2;</code>
       * @param value The logConsistency to set.
       * @return This builder for chaining.
       */
      public Builder setLogConsistency(
          int index, com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLogConsistency(index, value);
        return this;
      }
      /**
       * <pre>
       * log_consistency proves that log_root is consistent with previously seen
       * roots.
       * </pre>
       *
       * <code>repeated bytes log_consistency = 2;</code>
       * @param value The logConsistency to add.
       * @return This builder for chaining.
       */
      public Builder addLogConsistency(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addLogConsistency(value);
        return this;
      }
      /**
       * <pre>
       * log_consistency proves that log_root is consistent with previously seen
       * roots.
       * </pre>
       *
       * <code>repeated bytes log_consistency = 2;</code>
       * @param values The logConsistency to add.
       * @return This builder for chaining.
       */
      public Builder addAllLogConsistency(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.addAllLogConsistency(values);
        return this;
      }
      /**
       * <pre>
       * log_consistency proves that log_root is consistent with previously seen
       * roots.
       * </pre>
       *
       * <code>repeated bytes log_consistency = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLogConsistency() {
        copyOnWrite();
        instance.clearLogConsistency();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.keytransparency.v1.LogRoot)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.keytransparency.v1.Gkt.LogRoot();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "logRoot_",
              "logConsistency_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0001\u0000\u0001\t\u0002\u001c" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.keytransparency.v1.Gkt.LogRoot> parser = PARSER;
          if (parser == null) {
            synchronized (google.keytransparency.v1.Gkt.LogRoot.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.keytransparency.v1.Gkt.LogRoot>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.keytransparency.v1.LogRoot)
    private static final google.keytransparency.v1.Gkt.LogRoot DEFAULT_INSTANCE;
    static {
      LogRoot defaultInstance = new LogRoot();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        LogRoot.class, defaultInstance);
    }

    public static google.keytransparency.v1.Gkt.LogRoot getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<LogRoot> PARSER;

    public static com.google.protobuf.Parser<LogRoot> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MapLeafOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.keytransparency.v1.MapLeaf)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * vrf_proof is the proof for the VRF on user_id.
     * </pre>
     *
     * <code>bytes vrf_proof = 1;</code>
     * @return The vrfProof.
     */
    com.google.protobuf.ByteString getVrfProof();

    /**
     * <pre>
     * map_inclusion is an inclusion proof for the map leaf in an accompanying
     * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
     * stores a serialized Entry proto.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
     * @return Whether the mapInclusion field is set.
     */
    boolean hasMapInclusion();
    /**
     * <pre>
     * map_inclusion is an inclusion proof for the map leaf in an accompanying
     * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
     * stores a serialized Entry proto.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
     * @return The mapInclusion.
     */
    google.keytransparency.v1.Gkt.MapLeafInclusion getMapInclusion();

    /**
     * <pre>
     * committed contains the data and nonce used to make a cryptographic
     * commitment, which is stored in the commitment field of the serialized Entry
     * proto from map_inclusion.
     * Note: committed can also be found serialized in
     * map_inclusion.leaf.extra_data.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Committed committed = 3;</code>
     * @return Whether the committed field is set.
     */
    boolean hasCommitted();
    /**
     * <pre>
     * committed contains the data and nonce used to make a cryptographic
     * commitment, which is stored in the commitment field of the serialized Entry
     * proto from map_inclusion.
     * Note: committed can also be found serialized in
     * map_inclusion.leaf.extra_data.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Committed committed = 3;</code>
     * @return The committed.
     */
    google.keytransparency.v1.Gkt.Committed getCommitted();
  }
  /**
   * <pre>
   * Leaf entry for a user.
   * </pre>
   *
   * Protobuf type {@code google.keytransparency.v1.MapLeaf}
   */
  public  static final class MapLeaf extends
      com.google.protobuf.GeneratedMessageLite<
          MapLeaf, MapLeaf.Builder> implements
      // @@protoc_insertion_point(message_implements:google.keytransparency.v1.MapLeaf)
      MapLeafOrBuilder {
    private MapLeaf() {
      vrfProof_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int VRF_PROOF_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString vrfProof_;
    /**
     * <pre>
     * vrf_proof is the proof for the VRF on user_id.
     * </pre>
     *
     * <code>bytes vrf_proof = 1;</code>
     * @return The vrfProof.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getVrfProof() {
      return vrfProof_;
    }
    /**
     * <pre>
     * vrf_proof is the proof for the VRF on user_id.
     * </pre>
     *
     * <code>bytes vrf_proof = 1;</code>
     * @param value The vrfProof to set.
     */
    private void setVrfProof(com.google.protobuf.ByteString value) {
      value.getClass();
  
      vrfProof_ = value;
    }
    /**
     * <pre>
     * vrf_proof is the proof for the VRF on user_id.
     * </pre>
     *
     * <code>bytes vrf_proof = 1;</code>
     */
    private void clearVrfProof() {
      
      vrfProof_ = getDefaultInstance().getVrfProof();
    }

    public static final int MAP_INCLUSION_FIELD_NUMBER = 2;
    private google.keytransparency.v1.Gkt.MapLeafInclusion mapInclusion_;
    /**
     * <pre>
     * map_inclusion is an inclusion proof for the map leaf in an accompanying
     * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
     * stores a serialized Entry proto.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
     */
    @java.lang.Override
    public boolean hasMapInclusion() {
      return mapInclusion_ != null;
    }
    /**
     * <pre>
     * map_inclusion is an inclusion proof for the map leaf in an accompanying
     * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
     * stores a serialized Entry proto.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
     */
    @java.lang.Override
    public google.keytransparency.v1.Gkt.MapLeafInclusion getMapInclusion() {
      return mapInclusion_ == null ? google.keytransparency.v1.Gkt.MapLeafInclusion.getDefaultInstance() : mapInclusion_;
    }
    /**
     * <pre>
     * map_inclusion is an inclusion proof for the map leaf in an accompanying
     * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
     * stores a serialized Entry proto.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
     */
    private void setMapInclusion(google.keytransparency.v1.Gkt.MapLeafInclusion value) {
      value.getClass();
  mapInclusion_ = value;
      
      }
    /**
     * <pre>
     * map_inclusion is an inclusion proof for the map leaf in an accompanying
     * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
     * stores a serialized Entry proto.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeMapInclusion(google.keytransparency.v1.Gkt.MapLeafInclusion value) {
      value.getClass();
  if (mapInclusion_ != null &&
          mapInclusion_ != google.keytransparency.v1.Gkt.MapLeafInclusion.getDefaultInstance()) {
        mapInclusion_ =
          google.keytransparency.v1.Gkt.MapLeafInclusion.newBuilder(mapInclusion_).mergeFrom(value).buildPartial();
      } else {
        mapInclusion_ = value;
      }
      
    }
    /**
     * <pre>
     * map_inclusion is an inclusion proof for the map leaf in an accompanying
     * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
     * stores a serialized Entry proto.
     * </pre>
     *
     * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
     */
    private void clearMapInclusion() {  mapInclusion_ = null;
      
    }

    public static final int COMMITTED_FIELD_NUMBER = 3;
    private google.keytransparency.v1.Gkt.Committed committed_;
    /**
     * <pre>
     * committed contains the data and nonce used to make a cryptographic
     * commitment, which is stored in the commitment field of the serialized Entry
     * proto from map_inclusion.
     * Note: committed can also be found serialized in
     * map_inclusion.leaf.extra_data.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Committed committed = 3;</code>
     */
    @java.lang.Override
    public boolean hasCommitted() {
      return committed_ != null;
    }
    /**
     * <pre>
     * committed contains the data and nonce used to make a cryptographic
     * commitment, which is stored in the commitment field of the serialized Entry
     * proto from map_inclusion.
     * Note: committed can also be found serialized in
     * map_inclusion.leaf.extra_data.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Committed committed = 3;</code>
     */
    @java.lang.Override
    public google.keytransparency.v1.Gkt.Committed getCommitted() {
      return committed_ == null ? google.keytransparency.v1.Gkt.Committed.getDefaultInstance() : committed_;
    }
    /**
     * <pre>
     * committed contains the data and nonce used to make a cryptographic
     * commitment, which is stored in the commitment field of the serialized Entry
     * proto from map_inclusion.
     * Note: committed can also be found serialized in
     * map_inclusion.leaf.extra_data.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Committed committed = 3;</code>
     */
    private void setCommitted(google.keytransparency.v1.Gkt.Committed value) {
      value.getClass();
  committed_ = value;
      
      }
    /**
     * <pre>
     * committed contains the data and nonce used to make a cryptographic
     * commitment, which is stored in the commitment field of the serialized Entry
     * proto from map_inclusion.
     * Note: committed can also be found serialized in
     * map_inclusion.leaf.extra_data.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Committed committed = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeCommitted(google.keytransparency.v1.Gkt.Committed value) {
      value.getClass();
  if (committed_ != null &&
          committed_ != google.keytransparency.v1.Gkt.Committed.getDefaultInstance()) {
        committed_ =
          google.keytransparency.v1.Gkt.Committed.newBuilder(committed_).mergeFrom(value).buildPartial();
      } else {
        committed_ = value;
      }
      
    }
    /**
     * <pre>
     * committed contains the data and nonce used to make a cryptographic
     * commitment, which is stored in the commitment field of the serialized Entry
     * proto from map_inclusion.
     * Note: committed can also be found serialized in
     * map_inclusion.leaf.extra_data.
     * </pre>
     *
     * <code>.google.keytransparency.v1.Committed committed = 3;</code>
     */
    private void clearCommitted() {  committed_ = null;
      
    }

    public static google.keytransparency.v1.Gkt.MapLeaf parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.MapLeaf parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapLeaf parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.MapLeaf parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapLeaf parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.MapLeaf parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapLeaf parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.MapLeaf parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapLeaf parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.MapLeaf parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapLeaf parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.MapLeaf parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.keytransparency.v1.Gkt.MapLeaf prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Leaf entry for a user.
     * </pre>
     *
     * Protobuf type {@code google.keytransparency.v1.MapLeaf}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.keytransparency.v1.Gkt.MapLeaf, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.keytransparency.v1.MapLeaf)
        google.keytransparency.v1.Gkt.MapLeafOrBuilder {
      // Construct using google.keytransparency.v1.Gkt.MapLeaf.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * vrf_proof is the proof for the VRF on user_id.
       * </pre>
       *
       * <code>bytes vrf_proof = 1;</code>
       * @return The vrfProof.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getVrfProof() {
        return instance.getVrfProof();
      }
      /**
       * <pre>
       * vrf_proof is the proof for the VRF on user_id.
       * </pre>
       *
       * <code>bytes vrf_proof = 1;</code>
       * @param value The vrfProof to set.
       * @return This builder for chaining.
       */
      public Builder setVrfProof(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setVrfProof(value);
        return this;
      }
      /**
       * <pre>
       * vrf_proof is the proof for the VRF on user_id.
       * </pre>
       *
       * <code>bytes vrf_proof = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearVrfProof() {
        copyOnWrite();
        instance.clearVrfProof();
        return this;
      }

      /**
       * <pre>
       * map_inclusion is an inclusion proof for the map leaf in an accompanying
       * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
       * stores a serialized Entry proto.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
       */
      @java.lang.Override
      public boolean hasMapInclusion() {
        return instance.hasMapInclusion();
      }
      /**
       * <pre>
       * map_inclusion is an inclusion proof for the map leaf in an accompanying
       * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
       * stores a serialized Entry proto.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
       */
      @java.lang.Override
      public google.keytransparency.v1.Gkt.MapLeafInclusion getMapInclusion() {
        return instance.getMapInclusion();
      }
      /**
       * <pre>
       * map_inclusion is an inclusion proof for the map leaf in an accompanying
       * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
       * stores a serialized Entry proto.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
       */
      public Builder setMapInclusion(google.keytransparency.v1.Gkt.MapLeafInclusion value) {
        copyOnWrite();
        instance.setMapInclusion(value);
        return this;
        }
      /**
       * <pre>
       * map_inclusion is an inclusion proof for the map leaf in an accompanying
       * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
       * stores a serialized Entry proto.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
       */
      public Builder setMapInclusion(
          google.keytransparency.v1.Gkt.MapLeafInclusion.Builder builderForValue) {
        copyOnWrite();
        instance.setMapInclusion(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * map_inclusion is an inclusion proof for the map leaf in an accompanying
       * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
       * stores a serialized Entry proto.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
       */
      public Builder mergeMapInclusion(google.keytransparency.v1.Gkt.MapLeafInclusion value) {
        copyOnWrite();
        instance.mergeMapInclusion(value);
        return this;
      }
      /**
       * <pre>
       * map_inclusion is an inclusion proof for the map leaf in an accompanying
       * trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
       * stores a serialized Entry proto.
       * </pre>
       *
       * <code>.google.keytransparency.v1.MapLeafInclusion map_inclusion = 2;</code>
       */
      public Builder clearMapInclusion() {  copyOnWrite();
        instance.clearMapInclusion();
        return this;
      }

      /**
       * <pre>
       * committed contains the data and nonce used to make a cryptographic
       * commitment, which is stored in the commitment field of the serialized Entry
       * proto from map_inclusion.
       * Note: committed can also be found serialized in
       * map_inclusion.leaf.extra_data.
       * </pre>
       *
       * <code>.google.keytransparency.v1.Committed committed = 3;</code>
       */
      @java.lang.Override
      public boolean hasCommitted() {
        return instance.hasCommitted();
      }
      /**
       * <pre>
       * committed contains the data and nonce used to make a cryptographic
       * commitment, which is stored in the commitment field of the serialized Entry
       * proto from map_inclusion.
       * Note: committed can also be found serialized in
       * map_inclusion.leaf.extra_data.
       * </pre>
       *
       * <code>.google.keytransparency.v1.Committed committed = 3;</code>
       */
      @java.lang.Override
      public google.keytransparency.v1.Gkt.Committed getCommitted() {
        return instance.getCommitted();
      }
      /**
       * <pre>
       * committed contains the data and nonce used to make a cryptographic
       * commitment, which is stored in the commitment field of the serialized Entry
       * proto from map_inclusion.
       * Note: committed can also be found serialized in
       * map_inclusion.leaf.extra_data.
       * </pre>
       *
       * <code>.google.keytransparency.v1.Committed committed = 3;</code>
       */
      public Builder setCommitted(google.keytransparency.v1.Gkt.Committed value) {
        copyOnWrite();
        instance.setCommitted(value);
        return this;
        }
      /**
       * <pre>
       * committed contains the data and nonce used to make a cryptographic
       * commitment, which is stored in the commitment field of the serialized Entry
       * proto from map_inclusion.
       * Note: committed can also be found serialized in
       * map_inclusion.leaf.extra_data.
       * </pre>
       *
       * <code>.google.keytransparency.v1.Committed committed = 3;</code>
       */
      public Builder setCommitted(
          google.keytransparency.v1.Gkt.Committed.Builder builderForValue) {
        copyOnWrite();
        instance.setCommitted(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * committed contains the data and nonce used to make a cryptographic
       * commitment, which is stored in the commitment field of the serialized Entry
       * proto from map_inclusion.
       * Note: committed can also be found serialized in
       * map_inclusion.leaf.extra_data.
       * </pre>
       *
       * <code>.google.keytransparency.v1.Committed committed = 3;</code>
       */
      public Builder mergeCommitted(google.keytransparency.v1.Gkt.Committed value) {
        copyOnWrite();
        instance.mergeCommitted(value);
        return this;
      }
      /**
       * <pre>
       * committed contains the data and nonce used to make a cryptographic
       * commitment, which is stored in the commitment field of the serialized Entry
       * proto from map_inclusion.
       * Note: committed can also be found serialized in
       * map_inclusion.leaf.extra_data.
       * </pre>
       *
       * <code>.google.keytransparency.v1.Committed committed = 3;</code>
       */
      public Builder clearCommitted() {  copyOnWrite();
        instance.clearCommitted();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.keytransparency.v1.MapLeaf)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.keytransparency.v1.Gkt.MapLeaf();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "vrfProof_",
              "mapInclusion_",
              "committed_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0000\u0000\u0001\n\u0002\t\u0003" +
                "\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.keytransparency.v1.Gkt.MapLeaf> parser = PARSER;
          if (parser == null) {
            synchronized (google.keytransparency.v1.Gkt.MapLeaf.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.keytransparency.v1.Gkt.MapLeaf>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.keytransparency.v1.MapLeaf)
    private static final google.keytransparency.v1.Gkt.MapLeaf DEFAULT_INSTANCE;
    static {
      MapLeaf defaultInstance = new MapLeaf();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MapLeaf.class, defaultInstance);
    }

    public static google.keytransparency.v1.Gkt.MapLeaf getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MapLeaf> PARSER;

    public static com.google.protobuf.Parser<MapLeaf> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface CommittedOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.keytransparency.v1.Committed)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * key is the 16 byte random commitment key.
     * </pre>
     *
     * <code>bytes key = 1;</code>
     * @return The key.
     */
    com.google.protobuf.ByteString getKey();

    /**
     * <pre>
     * data is the data being committed to.
     * </pre>
     *
     * <code>bytes data = 2;</code>
     * @return The data.
     */
    com.google.protobuf.ByteString getData();
  }
  /**
   * <pre>
   * Committed represents the data committed to in a cryptographic commitment.
   * commitment = HMAC_SHA512_256(key, data)
   * </pre>
   *
   * Protobuf type {@code google.keytransparency.v1.Committed}
   */
  public  static final class Committed extends
      com.google.protobuf.GeneratedMessageLite<
          Committed, Committed.Builder> implements
      // @@protoc_insertion_point(message_implements:google.keytransparency.v1.Committed)
      CommittedOrBuilder {
    private Committed() {
      key_ = com.google.protobuf.ByteString.EMPTY;
      data_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int KEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString key_;
    /**
     * <pre>
     * key is the 16 byte random commitment key.
     * </pre>
     *
     * <code>bytes key = 1;</code>
     * @return The key.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getKey() {
      return key_;
    }
    /**
     * <pre>
     * key is the 16 byte random commitment key.
     * </pre>
     *
     * <code>bytes key = 1;</code>
     * @param value The key to set.
     */
    private void setKey(com.google.protobuf.ByteString value) {
      value.getClass();
  
      key_ = value;
    }
    /**
     * <pre>
     * key is the 16 byte random commitment key.
     * </pre>
     *
     * <code>bytes key = 1;</code>
     */
    private void clearKey() {
      
      key_ = getDefaultInstance().getKey();
    }

    public static final int DATA_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString data_;
    /**
     * <pre>
     * data is the data being committed to.
     * </pre>
     *
     * <code>bytes data = 2;</code>
     * @return The data.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getData() {
      return data_;
    }
    /**
     * <pre>
     * data is the data being committed to.
     * </pre>
     *
     * <code>bytes data = 2;</code>
     * @param value The data to set.
     */
    private void setData(com.google.protobuf.ByteString value) {
      value.getClass();
  
      data_ = value;
    }
    /**
     * <pre>
     * data is the data being committed to.
     * </pre>
     *
     * <code>bytes data = 2;</code>
     */
    private void clearData() {
      
      data_ = getDefaultInstance().getData();
    }

    public static google.keytransparency.v1.Gkt.Committed parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.Committed parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.Committed parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.Committed parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.Committed parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.Committed parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.Committed parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.Committed parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.Committed parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.Committed parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.Committed parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.Committed parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.keytransparency.v1.Gkt.Committed prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Committed represents the data committed to in a cryptographic commitment.
     * commitment = HMAC_SHA512_256(key, data)
     * </pre>
     *
     * Protobuf type {@code google.keytransparency.v1.Committed}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.keytransparency.v1.Gkt.Committed, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.keytransparency.v1.Committed)
        google.keytransparency.v1.Gkt.CommittedOrBuilder {
      // Construct using google.keytransparency.v1.Gkt.Committed.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * key is the 16 byte random commitment key.
       * </pre>
       *
       * <code>bytes key = 1;</code>
       * @return The key.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getKey() {
        return instance.getKey();
      }
      /**
       * <pre>
       * key is the 16 byte random commitment key.
       * </pre>
       *
       * <code>bytes key = 1;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setKey(value);
        return this;
      }
      /**
       * <pre>
       * key is the 16 byte random commitment key.
       * </pre>
       *
       * <code>bytes key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        copyOnWrite();
        instance.clearKey();
        return this;
      }

      /**
       * <pre>
       * data is the data being committed to.
       * </pre>
       *
       * <code>bytes data = 2;</code>
       * @return The data.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getData() {
        return instance.getData();
      }
      /**
       * <pre>
       * data is the data being committed to.
       * </pre>
       *
       * <code>bytes data = 2;</code>
       * @param value The data to set.
       * @return This builder for chaining.
       */
      public Builder setData(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setData(value);
        return this;
      }
      /**
       * <pre>
       * data is the data being committed to.
       * </pre>
       *
       * <code>bytes data = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearData() {
        copyOnWrite();
        instance.clearData();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.keytransparency.v1.Committed)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.keytransparency.v1.Gkt.Committed();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "key_",
              "data_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\n\u0002\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.keytransparency.v1.Gkt.Committed> parser = PARSER;
          if (parser == null) {
            synchronized (google.keytransparency.v1.Gkt.Committed.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.keytransparency.v1.Gkt.Committed>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.keytransparency.v1.Committed)
    private static final google.keytransparency.v1.Gkt.Committed DEFAULT_INSTANCE;
    static {
      Committed defaultInstance = new Committed();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Committed.class, defaultInstance);
    }

    public static google.keytransparency.v1.Gkt.Committed getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Committed> PARSER;

    public static com.google.protobuf.Parser<Committed> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SignedLogRootOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.keytransparency.v1.SignedLogRoot)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * key_hint is a hint to identify the public key for signature verification.
     * key_hint is not authenticated and may be incorrect or missing, in which
     * case all known public keys may be used to verify the signature.
     * When directly communicating with a Trillian gRPC server, the key_hint will
     * typically contain the LogID encoded as a big-endian 64-bit integer;
     * however, in other contexts the key_hint is likely to have different
     * contents (e.g. it could be a GUID, a URL + TreeID, or it could be
     * derived from the public key itself).
     * </pre>
     *
     * <code>bytes key_hint = 7;</code>
     * @return The keyHint.
     */
    com.google.protobuf.ByteString getKeyHint();

    /**
     * <pre>
     * log_root holds the TLS-serialization of the following structure (described
     * in RFC5246 notation): Clients should validate log_root_signature with
     * VerifySignedLogRoot before deserializing log_root.
     * enum { v1(1), (65535)} Version;
     * struct {
     *   uint64 tree_size;
     *   opaque root_hash&lt;0..128&gt;;
     *   uint64 timestamp_nanos;
     *   uint64 revision;
     *   opaque metadata&lt;0..65535&gt;;
     * } LogRootV1;
     * struct {
     *   Version version;
     *   select(version) {
     *     case v1: LogRootV1;
     *   }
     * } LogRoot;
     * A serialized v1 log root will therefore be laid out as:
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
     * | ver=1 |          tree_size            |len|    root_hash      |
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
     * |        timestamp_nanos        |      revision                 |
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
     * +---+---+---+---+---+-....---+
     * |  len  |    metadata        |
     * +---+---+---+---+---+-....---+
     * (with all integers encoded big-endian).
     * </pre>
     *
     * <code>bytes log_root = 8;</code>
     * @return The logRoot.
     */
    com.google.protobuf.ByteString getLogRoot();

    /**
     * <pre>
     * log_root_signature is the raw signature over log_root.
     * </pre>
     *
     * <code>bytes log_root_signature = 9;</code>
     * @return The logRootSignature.
     */
    com.google.protobuf.ByteString getLogRootSignature();
  }
  /**
   * <pre>
   * SignedLogRoot represents a commitment by a Log to a particular tree.
   * </pre>
   *
   * Protobuf type {@code google.keytransparency.v1.SignedLogRoot}
   */
  public  static final class SignedLogRoot extends
      com.google.protobuf.GeneratedMessageLite<
          SignedLogRoot, SignedLogRoot.Builder> implements
      // @@protoc_insertion_point(message_implements:google.keytransparency.v1.SignedLogRoot)
      SignedLogRootOrBuilder {
    private SignedLogRoot() {
      keyHint_ = com.google.protobuf.ByteString.EMPTY;
      logRoot_ = com.google.protobuf.ByteString.EMPTY;
      logRootSignature_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int KEY_HINT_FIELD_NUMBER = 7;
    private com.google.protobuf.ByteString keyHint_;
    /**
     * <pre>
     * key_hint is a hint to identify the public key for signature verification.
     * key_hint is not authenticated and may be incorrect or missing, in which
     * case all known public keys may be used to verify the signature.
     * When directly communicating with a Trillian gRPC server, the key_hint will
     * typically contain the LogID encoded as a big-endian 64-bit integer;
     * however, in other contexts the key_hint is likely to have different
     * contents (e.g. it could be a GUID, a URL + TreeID, or it could be
     * derived from the public key itself).
     * </pre>
     *
     * <code>bytes key_hint = 7;</code>
     * @return The keyHint.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getKeyHint() {
      return keyHint_;
    }
    /**
     * <pre>
     * key_hint is a hint to identify the public key for signature verification.
     * key_hint is not authenticated and may be incorrect or missing, in which
     * case all known public keys may be used to verify the signature.
     * When directly communicating with a Trillian gRPC server, the key_hint will
     * typically contain the LogID encoded as a big-endian 64-bit integer;
     * however, in other contexts the key_hint is likely to have different
     * contents (e.g. it could be a GUID, a URL + TreeID, or it could be
     * derived from the public key itself).
     * </pre>
     *
     * <code>bytes key_hint = 7;</code>
     * @param value The keyHint to set.
     */
    private void setKeyHint(com.google.protobuf.ByteString value) {
      value.getClass();
  
      keyHint_ = value;
    }
    /**
     * <pre>
     * key_hint is a hint to identify the public key for signature verification.
     * key_hint is not authenticated and may be incorrect or missing, in which
     * case all known public keys may be used to verify the signature.
     * When directly communicating with a Trillian gRPC server, the key_hint will
     * typically contain the LogID encoded as a big-endian 64-bit integer;
     * however, in other contexts the key_hint is likely to have different
     * contents (e.g. it could be a GUID, a URL + TreeID, or it could be
     * derived from the public key itself).
     * </pre>
     *
     * <code>bytes key_hint = 7;</code>
     */
    private void clearKeyHint() {
      
      keyHint_ = getDefaultInstance().getKeyHint();
    }

    public static final int LOG_ROOT_FIELD_NUMBER = 8;
    private com.google.protobuf.ByteString logRoot_;
    /**
     * <pre>
     * log_root holds the TLS-serialization of the following structure (described
     * in RFC5246 notation): Clients should validate log_root_signature with
     * VerifySignedLogRoot before deserializing log_root.
     * enum { v1(1), (65535)} Version;
     * struct {
     *   uint64 tree_size;
     *   opaque root_hash&lt;0..128&gt;;
     *   uint64 timestamp_nanos;
     *   uint64 revision;
     *   opaque metadata&lt;0..65535&gt;;
     * } LogRootV1;
     * struct {
     *   Version version;
     *   select(version) {
     *     case v1: LogRootV1;
     *   }
     * } LogRoot;
     * A serialized v1 log root will therefore be laid out as:
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
     * | ver=1 |          tree_size            |len|    root_hash      |
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
     * |        timestamp_nanos        |      revision                 |
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
     * +---+---+---+---+---+-....---+
     * |  len  |    metadata        |
     * +---+---+---+---+---+-....---+
     * (with all integers encoded big-endian).
     * </pre>
     *
     * <code>bytes log_root = 8;</code>
     * @return The logRoot.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLogRoot() {
      return logRoot_;
    }
    /**
     * <pre>
     * log_root holds the TLS-serialization of the following structure (described
     * in RFC5246 notation): Clients should validate log_root_signature with
     * VerifySignedLogRoot before deserializing log_root.
     * enum { v1(1), (65535)} Version;
     * struct {
     *   uint64 tree_size;
     *   opaque root_hash&lt;0..128&gt;;
     *   uint64 timestamp_nanos;
     *   uint64 revision;
     *   opaque metadata&lt;0..65535&gt;;
     * } LogRootV1;
     * struct {
     *   Version version;
     *   select(version) {
     *     case v1: LogRootV1;
     *   }
     * } LogRoot;
     * A serialized v1 log root will therefore be laid out as:
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
     * | ver=1 |          tree_size            |len|    root_hash      |
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
     * |        timestamp_nanos        |      revision                 |
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
     * +---+---+---+---+---+-....---+
     * |  len  |    metadata        |
     * +---+---+---+---+---+-....---+
     * (with all integers encoded big-endian).
     * </pre>
     *
     * <code>bytes log_root = 8;</code>
     * @param value The logRoot to set.
     */
    private void setLogRoot(com.google.protobuf.ByteString value) {
      value.getClass();
  
      logRoot_ = value;
    }
    /**
     * <pre>
     * log_root holds the TLS-serialization of the following structure (described
     * in RFC5246 notation): Clients should validate log_root_signature with
     * VerifySignedLogRoot before deserializing log_root.
     * enum { v1(1), (65535)} Version;
     * struct {
     *   uint64 tree_size;
     *   opaque root_hash&lt;0..128&gt;;
     *   uint64 timestamp_nanos;
     *   uint64 revision;
     *   opaque metadata&lt;0..65535&gt;;
     * } LogRootV1;
     * struct {
     *   Version version;
     *   select(version) {
     *     case v1: LogRootV1;
     *   }
     * } LogRoot;
     * A serialized v1 log root will therefore be laid out as:
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
     * | ver=1 |          tree_size            |len|    root_hash      |
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
     * |        timestamp_nanos        |      revision                 |
     * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
     * +---+---+---+---+---+-....---+
     * |  len  |    metadata        |
     * +---+---+---+---+---+-....---+
     * (with all integers encoded big-endian).
     * </pre>
     *
     * <code>bytes log_root = 8;</code>
     */
    private void clearLogRoot() {
      
      logRoot_ = getDefaultInstance().getLogRoot();
    }

    public static final int LOG_ROOT_SIGNATURE_FIELD_NUMBER = 9;
    private com.google.protobuf.ByteString logRootSignature_;
    /**
     * <pre>
     * log_root_signature is the raw signature over log_root.
     * </pre>
     *
     * <code>bytes log_root_signature = 9;</code>
     * @return The logRootSignature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLogRootSignature() {
      return logRootSignature_;
    }
    /**
     * <pre>
     * log_root_signature is the raw signature over log_root.
     * </pre>
     *
     * <code>bytes log_root_signature = 9;</code>
     * @param value The logRootSignature to set.
     */
    private void setLogRootSignature(com.google.protobuf.ByteString value) {
      value.getClass();
  
      logRootSignature_ = value;
    }
    /**
     * <pre>
     * log_root_signature is the raw signature over log_root.
     * </pre>
     *
     * <code>bytes log_root_signature = 9;</code>
     */
    private void clearLogRootSignature() {
      
      logRootSignature_ = getDefaultInstance().getLogRootSignature();
    }

    public static google.keytransparency.v1.Gkt.SignedLogRoot parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.SignedLogRoot parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.SignedLogRoot parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.SignedLogRoot parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.SignedLogRoot parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.SignedLogRoot parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.SignedLogRoot parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.SignedLogRoot parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.SignedLogRoot parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.SignedLogRoot parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.SignedLogRoot parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.SignedLogRoot parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.keytransparency.v1.Gkt.SignedLogRoot prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * SignedLogRoot represents a commitment by a Log to a particular tree.
     * </pre>
     *
     * Protobuf type {@code google.keytransparency.v1.SignedLogRoot}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.keytransparency.v1.Gkt.SignedLogRoot, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.keytransparency.v1.SignedLogRoot)
        google.keytransparency.v1.Gkt.SignedLogRootOrBuilder {
      // Construct using google.keytransparency.v1.Gkt.SignedLogRoot.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * key_hint is a hint to identify the public key for signature verification.
       * key_hint is not authenticated and may be incorrect or missing, in which
       * case all known public keys may be used to verify the signature.
       * When directly communicating with a Trillian gRPC server, the key_hint will
       * typically contain the LogID encoded as a big-endian 64-bit integer;
       * however, in other contexts the key_hint is likely to have different
       * contents (e.g. it could be a GUID, a URL + TreeID, or it could be
       * derived from the public key itself).
       * </pre>
       *
       * <code>bytes key_hint = 7;</code>
       * @return The keyHint.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getKeyHint() {
        return instance.getKeyHint();
      }
      /**
       * <pre>
       * key_hint is a hint to identify the public key for signature verification.
       * key_hint is not authenticated and may be incorrect or missing, in which
       * case all known public keys may be used to verify the signature.
       * When directly communicating with a Trillian gRPC server, the key_hint will
       * typically contain the LogID encoded as a big-endian 64-bit integer;
       * however, in other contexts the key_hint is likely to have different
       * contents (e.g. it could be a GUID, a URL + TreeID, or it could be
       * derived from the public key itself).
       * </pre>
       *
       * <code>bytes key_hint = 7;</code>
       * @param value The keyHint to set.
       * @return This builder for chaining.
       */
      public Builder setKeyHint(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setKeyHint(value);
        return this;
      }
      /**
       * <pre>
       * key_hint is a hint to identify the public key for signature verification.
       * key_hint is not authenticated and may be incorrect or missing, in which
       * case all known public keys may be used to verify the signature.
       * When directly communicating with a Trillian gRPC server, the key_hint will
       * typically contain the LogID encoded as a big-endian 64-bit integer;
       * however, in other contexts the key_hint is likely to have different
       * contents (e.g. it could be a GUID, a URL + TreeID, or it could be
       * derived from the public key itself).
       * </pre>
       *
       * <code>bytes key_hint = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyHint() {
        copyOnWrite();
        instance.clearKeyHint();
        return this;
      }

      /**
       * <pre>
       * log_root holds the TLS-serialization of the following structure (described
       * in RFC5246 notation): Clients should validate log_root_signature with
       * VerifySignedLogRoot before deserializing log_root.
       * enum { v1(1), (65535)} Version;
       * struct {
       *   uint64 tree_size;
       *   opaque root_hash&lt;0..128&gt;;
       *   uint64 timestamp_nanos;
       *   uint64 revision;
       *   opaque metadata&lt;0..65535&gt;;
       * } LogRootV1;
       * struct {
       *   Version version;
       *   select(version) {
       *     case v1: LogRootV1;
       *   }
       * } LogRoot;
       * A serialized v1 log root will therefore be laid out as:
       * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
       * | ver=1 |          tree_size            |len|    root_hash      |
       * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
       * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
       * |        timestamp_nanos        |      revision                 |
       * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
       * +---+---+---+---+---+-....---+
       * |  len  |    metadata        |
       * +---+---+---+---+---+-....---+
       * (with all integers encoded big-endian).
       * </pre>
       *
       * <code>bytes log_root = 8;</code>
       * @return The logRoot.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLogRoot() {
        return instance.getLogRoot();
      }
      /**
       * <pre>
       * log_root holds the TLS-serialization of the following structure (described
       * in RFC5246 notation): Clients should validate log_root_signature with
       * VerifySignedLogRoot before deserializing log_root.
       * enum { v1(1), (65535)} Version;
       * struct {
       *   uint64 tree_size;
       *   opaque root_hash&lt;0..128&gt;;
       *   uint64 timestamp_nanos;
       *   uint64 revision;
       *   opaque metadata&lt;0..65535&gt;;
       * } LogRootV1;
       * struct {
       *   Version version;
       *   select(version) {
       *     case v1: LogRootV1;
       *   }
       * } LogRoot;
       * A serialized v1 log root will therefore be laid out as:
       * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
       * | ver=1 |          tree_size            |len|    root_hash      |
       * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
       * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
       * |        timestamp_nanos        |      revision                 |
       * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
       * +---+---+---+---+---+-....---+
       * |  len  |    metadata        |
       * +---+---+---+---+---+-....---+
       * (with all integers encoded big-endian).
       * </pre>
       *
       * <code>bytes log_root = 8;</code>
       * @param value The logRoot to set.
       * @return This builder for chaining.
       */
      public Builder setLogRoot(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLogRoot(value);
        return this;
      }
      /**
       * <pre>
       * log_root holds the TLS-serialization of the following structure (described
       * in RFC5246 notation): Clients should validate log_root_signature with
       * VerifySignedLogRoot before deserializing log_root.
       * enum { v1(1), (65535)} Version;
       * struct {
       *   uint64 tree_size;
       *   opaque root_hash&lt;0..128&gt;;
       *   uint64 timestamp_nanos;
       *   uint64 revision;
       *   opaque metadata&lt;0..65535&gt;;
       * } LogRootV1;
       * struct {
       *   Version version;
       *   select(version) {
       *     case v1: LogRootV1;
       *   }
       * } LogRoot;
       * A serialized v1 log root will therefore be laid out as:
       * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
       * | ver=1 |          tree_size            |len|    root_hash      |
       * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+-....--+
       * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
       * |        timestamp_nanos        |      revision                 |
       * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
       * +---+---+---+---+---+-....---+
       * |  len  |    metadata        |
       * +---+---+---+---+---+-....---+
       * (with all integers encoded big-endian).
       * </pre>
       *
       * <code>bytes log_root = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearLogRoot() {
        copyOnWrite();
        instance.clearLogRoot();
        return this;
      }

      /**
       * <pre>
       * log_root_signature is the raw signature over log_root.
       * </pre>
       *
       * <code>bytes log_root_signature = 9;</code>
       * @return The logRootSignature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLogRootSignature() {
        return instance.getLogRootSignature();
      }
      /**
       * <pre>
       * log_root_signature is the raw signature over log_root.
       * </pre>
       *
       * <code>bytes log_root_signature = 9;</code>
       * @param value The logRootSignature to set.
       * @return This builder for chaining.
       */
      public Builder setLogRootSignature(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLogRootSignature(value);
        return this;
      }
      /**
       * <pre>
       * log_root_signature is the raw signature over log_root.
       * </pre>
       *
       * <code>bytes log_root_signature = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearLogRootSignature() {
        copyOnWrite();
        instance.clearLogRootSignature();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.keytransparency.v1.SignedLogRoot)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.keytransparency.v1.Gkt.SignedLogRoot();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "keyHint_",
              "logRoot_",
              "logRootSignature_",
            };
            java.lang.String info =
                "\u0000\u0003\u0000\u0000\u0007\t\u0003\u0000\u0000\u0000\u0007\n\b\n\t\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.keytransparency.v1.Gkt.SignedLogRoot> parser = PARSER;
          if (parser == null) {
            synchronized (google.keytransparency.v1.Gkt.SignedLogRoot.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.keytransparency.v1.Gkt.SignedLogRoot>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.keytransparency.v1.SignedLogRoot)
    private static final google.keytransparency.v1.Gkt.SignedLogRoot DEFAULT_INSTANCE;
    static {
      SignedLogRoot defaultInstance = new SignedLogRoot();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SignedLogRoot.class, defaultInstance);
    }

    public static google.keytransparency.v1.Gkt.SignedLogRoot getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SignedLogRoot> PARSER;

    public static com.google.protobuf.Parser<SignedLogRoot> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SignedMapRootOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.keytransparency.v1.SignedMapRoot)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * map_root holds the TLS-serialization of the following structure (described
     * in RFC5246 notation): Clients should validate signature with
     * VerifySignedMapRoot before deserializing map_root.
     * enum { v1(1), (65535)} Version;
     * struct {
     *   opaque root_hash&lt;0..128&gt;;
     *   uint64 timestamp_nanos;
     *   uint64 revision;
     *   opaque metadata&lt;0..65535&gt;;
     * } MapRootV1;
     * struct {
     *   Version version;
     *   select(version) {
     *     case v1: MapRootV1;
     *   }
     * } MapRoot;
     * </pre>
     *
     * <code>bytes map_root = 9;</code>
     * @return The mapRoot.
     */
    com.google.protobuf.ByteString getMapRoot();

    /**
     * <pre>
     * Signature is the raw signature over MapRoot.
     * </pre>
     *
     * <code>bytes signature = 4;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();
  }
  /**
   * <pre>
   * SignedMapRoot represents a commitment by a Map to a particular tree.
   * </pre>
   *
   * Protobuf type {@code google.keytransparency.v1.SignedMapRoot}
   */
  public  static final class SignedMapRoot extends
      com.google.protobuf.GeneratedMessageLite<
          SignedMapRoot, SignedMapRoot.Builder> implements
      // @@protoc_insertion_point(message_implements:google.keytransparency.v1.SignedMapRoot)
      SignedMapRootOrBuilder {
    private SignedMapRoot() {
      mapRoot_ = com.google.protobuf.ByteString.EMPTY;
      signature_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int MAP_ROOT_FIELD_NUMBER = 9;
    private com.google.protobuf.ByteString mapRoot_;
    /**
     * <pre>
     * map_root holds the TLS-serialization of the following structure (described
     * in RFC5246 notation): Clients should validate signature with
     * VerifySignedMapRoot before deserializing map_root.
     * enum { v1(1), (65535)} Version;
     * struct {
     *   opaque root_hash&lt;0..128&gt;;
     *   uint64 timestamp_nanos;
     *   uint64 revision;
     *   opaque metadata&lt;0..65535&gt;;
     * } MapRootV1;
     * struct {
     *   Version version;
     *   select(version) {
     *     case v1: MapRootV1;
     *   }
     * } MapRoot;
     * </pre>
     *
     * <code>bytes map_root = 9;</code>
     * @return The mapRoot.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getMapRoot() {
      return mapRoot_;
    }
    /**
     * <pre>
     * map_root holds the TLS-serialization of the following structure (described
     * in RFC5246 notation): Clients should validate signature with
     * VerifySignedMapRoot before deserializing map_root.
     * enum { v1(1), (65535)} Version;
     * struct {
     *   opaque root_hash&lt;0..128&gt;;
     *   uint64 timestamp_nanos;
     *   uint64 revision;
     *   opaque metadata&lt;0..65535&gt;;
     * } MapRootV1;
     * struct {
     *   Version version;
     *   select(version) {
     *     case v1: MapRootV1;
     *   }
     * } MapRoot;
     * </pre>
     *
     * <code>bytes map_root = 9;</code>
     * @param value The mapRoot to set.
     */
    private void setMapRoot(com.google.protobuf.ByteString value) {
      value.getClass();
  
      mapRoot_ = value;
    }
    /**
     * <pre>
     * map_root holds the TLS-serialization of the following structure (described
     * in RFC5246 notation): Clients should validate signature with
     * VerifySignedMapRoot before deserializing map_root.
     * enum { v1(1), (65535)} Version;
     * struct {
     *   opaque root_hash&lt;0..128&gt;;
     *   uint64 timestamp_nanos;
     *   uint64 revision;
     *   opaque metadata&lt;0..65535&gt;;
     * } MapRootV1;
     * struct {
     *   Version version;
     *   select(version) {
     *     case v1: MapRootV1;
     *   }
     * } MapRoot;
     * </pre>
     *
     * <code>bytes map_root = 9;</code>
     */
    private void clearMapRoot() {
      
      mapRoot_ = getDefaultInstance().getMapRoot();
    }

    public static final int SIGNATURE_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString signature_;
    /**
     * <pre>
     * Signature is the raw signature over MapRoot.
     * </pre>
     *
     * <code>bytes signature = 4;</code>
     * @return The signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }
    /**
     * <pre>
     * Signature is the raw signature over MapRoot.
     * </pre>
     *
     * <code>bytes signature = 4;</code>
     * @param value The signature to set.
     */
    private void setSignature(com.google.protobuf.ByteString value) {
      value.getClass();
  
      signature_ = value;
    }
    /**
     * <pre>
     * Signature is the raw signature over MapRoot.
     * </pre>
     *
     * <code>bytes signature = 4;</code>
     */
    private void clearSignature() {
      
      signature_ = getDefaultInstance().getSignature();
    }

    public static google.keytransparency.v1.Gkt.SignedMapRoot parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.SignedMapRoot parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.SignedMapRoot parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.SignedMapRoot parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.SignedMapRoot parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.SignedMapRoot parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.SignedMapRoot parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.SignedMapRoot parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.SignedMapRoot parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.SignedMapRoot parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.SignedMapRoot parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.SignedMapRoot parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.keytransparency.v1.Gkt.SignedMapRoot prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * SignedMapRoot represents a commitment by a Map to a particular tree.
     * </pre>
     *
     * Protobuf type {@code google.keytransparency.v1.SignedMapRoot}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.keytransparency.v1.Gkt.SignedMapRoot, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.keytransparency.v1.SignedMapRoot)
        google.keytransparency.v1.Gkt.SignedMapRootOrBuilder {
      // Construct using google.keytransparency.v1.Gkt.SignedMapRoot.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * map_root holds the TLS-serialization of the following structure (described
       * in RFC5246 notation): Clients should validate signature with
       * VerifySignedMapRoot before deserializing map_root.
       * enum { v1(1), (65535)} Version;
       * struct {
       *   opaque root_hash&lt;0..128&gt;;
       *   uint64 timestamp_nanos;
       *   uint64 revision;
       *   opaque metadata&lt;0..65535&gt;;
       * } MapRootV1;
       * struct {
       *   Version version;
       *   select(version) {
       *     case v1: MapRootV1;
       *   }
       * } MapRoot;
       * </pre>
       *
       * <code>bytes map_root = 9;</code>
       * @return The mapRoot.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getMapRoot() {
        return instance.getMapRoot();
      }
      /**
       * <pre>
       * map_root holds the TLS-serialization of the following structure (described
       * in RFC5246 notation): Clients should validate signature with
       * VerifySignedMapRoot before deserializing map_root.
       * enum { v1(1), (65535)} Version;
       * struct {
       *   opaque root_hash&lt;0..128&gt;;
       *   uint64 timestamp_nanos;
       *   uint64 revision;
       *   opaque metadata&lt;0..65535&gt;;
       * } MapRootV1;
       * struct {
       *   Version version;
       *   select(version) {
       *     case v1: MapRootV1;
       *   }
       * } MapRoot;
       * </pre>
       *
       * <code>bytes map_root = 9;</code>
       * @param value The mapRoot to set.
       * @return This builder for chaining.
       */
      public Builder setMapRoot(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMapRoot(value);
        return this;
      }
      /**
       * <pre>
       * map_root holds the TLS-serialization of the following structure (described
       * in RFC5246 notation): Clients should validate signature with
       * VerifySignedMapRoot before deserializing map_root.
       * enum { v1(1), (65535)} Version;
       * struct {
       *   opaque root_hash&lt;0..128&gt;;
       *   uint64 timestamp_nanos;
       *   uint64 revision;
       *   opaque metadata&lt;0..65535&gt;;
       * } MapRootV1;
       * struct {
       *   Version version;
       *   select(version) {
       *     case v1: MapRootV1;
       *   }
       * } MapRoot;
       * </pre>
       *
       * <code>bytes map_root = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearMapRoot() {
        copyOnWrite();
        instance.clearMapRoot();
        return this;
      }

      /**
       * <pre>
       * Signature is the raw signature over MapRoot.
       * </pre>
       *
       * <code>bytes signature = 4;</code>
       * @return The signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return instance.getSignature();
      }
      /**
       * <pre>
       * Signature is the raw signature over MapRoot.
       * </pre>
       *
       * <code>bytes signature = 4;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <pre>
       * Signature is the raw signature over MapRoot.
       * </pre>
       *
       * <code>bytes signature = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.keytransparency.v1.SignedMapRoot)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.keytransparency.v1.Gkt.SignedMapRoot();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "signature_",
              "mapRoot_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0004\t\u0002\u0000\u0000\u0000\u0004\n\t\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.keytransparency.v1.Gkt.SignedMapRoot> parser = PARSER;
          if (parser == null) {
            synchronized (google.keytransparency.v1.Gkt.SignedMapRoot.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.keytransparency.v1.Gkt.SignedMapRoot>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.keytransparency.v1.SignedMapRoot)
    private static final google.keytransparency.v1.Gkt.SignedMapRoot DEFAULT_INSTANCE;
    static {
      SignedMapRoot defaultInstance = new SignedMapRoot();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SignedMapRoot.class, defaultInstance);
    }

    public static google.keytransparency.v1.Gkt.SignedMapRoot getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SignedMapRoot> PARSER;

    public static com.google.protobuf.Parser<SignedMapRoot> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MapLeafInclusionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.keytransparency.v1.MapLeafInclusion)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
     * @return Whether the leaf field is set.
     */
    boolean hasLeaf();
    /**
     * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
     * @return The leaf.
     */
    google.keytransparency.v1.Gkt.TrillianMapLeaf getLeaf();

    /**
     * <pre>
     * inclusion holds the inclusion proof for this leaf in the map root. It
     * holds one entry for each level of the tree; combining each of these in
     * turn with the leaf's hash (according to the tree's hash strategy)
     * reproduces the root hash.  A nil entry for a particular level indicates
     * that the node in question has an empty subtree beneath it (and so its
     * associated hash value is hasher.HashEmpty(index, height) rather than
     * hasher.HashChildren(l_hash, r_hash)).
     * </pre>
     *
     * <code>repeated bytes inclusion = 2;</code>
     * @return A list containing the inclusion.
     */
    java.util.List<com.google.protobuf.ByteString> getInclusionList();
    /**
     * <pre>
     * inclusion holds the inclusion proof for this leaf in the map root. It
     * holds one entry for each level of the tree; combining each of these in
     * turn with the leaf's hash (according to the tree's hash strategy)
     * reproduces the root hash.  A nil entry for a particular level indicates
     * that the node in question has an empty subtree beneath it (and so its
     * associated hash value is hasher.HashEmpty(index, height) rather than
     * hasher.HashChildren(l_hash, r_hash)).
     * </pre>
     *
     * <code>repeated bytes inclusion = 2;</code>
     * @return The count of inclusion.
     */
    int getInclusionCount();
    /**
     * <pre>
     * inclusion holds the inclusion proof for this leaf in the map root. It
     * holds one entry for each level of the tree; combining each of these in
     * turn with the leaf's hash (according to the tree's hash strategy)
     * reproduces the root hash.  A nil entry for a particular level indicates
     * that the node in question has an empty subtree beneath it (and so its
     * associated hash value is hasher.HashEmpty(index, height) rather than
     * hasher.HashChildren(l_hash, r_hash)).
     * </pre>
     *
     * <code>repeated bytes inclusion = 2;</code>
     * @param index The index of the element to return.
     * @return The inclusion at the given index.
     */
    com.google.protobuf.ByteString getInclusion(int index);
  }
  /**
   * Protobuf type {@code google.keytransparency.v1.MapLeafInclusion}
   */
  public  static final class MapLeafInclusion extends
      com.google.protobuf.GeneratedMessageLite<
          MapLeafInclusion, MapLeafInclusion.Builder> implements
      // @@protoc_insertion_point(message_implements:google.keytransparency.v1.MapLeafInclusion)
      MapLeafInclusionOrBuilder {
    private MapLeafInclusion() {
      inclusion_ = emptyProtobufList();
    }
    public static final int LEAF_FIELD_NUMBER = 1;
    private google.keytransparency.v1.Gkt.TrillianMapLeaf leaf_;
    /**
     * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
     */
    @java.lang.Override
    public boolean hasLeaf() {
      return leaf_ != null;
    }
    /**
     * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
     */
    @java.lang.Override
    public google.keytransparency.v1.Gkt.TrillianMapLeaf getLeaf() {
      return leaf_ == null ? google.keytransparency.v1.Gkt.TrillianMapLeaf.getDefaultInstance() : leaf_;
    }
    /**
     * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
     */
    private void setLeaf(google.keytransparency.v1.Gkt.TrillianMapLeaf value) {
      value.getClass();
  leaf_ = value;
      
      }
    /**
     * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeLeaf(google.keytransparency.v1.Gkt.TrillianMapLeaf value) {
      value.getClass();
  if (leaf_ != null &&
          leaf_ != google.keytransparency.v1.Gkt.TrillianMapLeaf.getDefaultInstance()) {
        leaf_ =
          google.keytransparency.v1.Gkt.TrillianMapLeaf.newBuilder(leaf_).mergeFrom(value).buildPartial();
      } else {
        leaf_ = value;
      }
      
    }
    /**
     * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
     */
    private void clearLeaf() {  leaf_ = null;
      
    }

    public static final int INCLUSION_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> inclusion_;
    /**
     * <pre>
     * inclusion holds the inclusion proof for this leaf in the map root. It
     * holds one entry for each level of the tree; combining each of these in
     * turn with the leaf's hash (according to the tree's hash strategy)
     * reproduces the root hash.  A nil entry for a particular level indicates
     * that the node in question has an empty subtree beneath it (and so its
     * associated hash value is hasher.HashEmpty(index, height) rather than
     * hasher.HashChildren(l_hash, r_hash)).
     * </pre>
     *
     * <code>repeated bytes inclusion = 2;</code>
     * @return A list containing the inclusion.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getInclusionList() {
      return inclusion_;
    }
    /**
     * <pre>
     * inclusion holds the inclusion proof for this leaf in the map root. It
     * holds one entry for each level of the tree; combining each of these in
     * turn with the leaf's hash (according to the tree's hash strategy)
     * reproduces the root hash.  A nil entry for a particular level indicates
     * that the node in question has an empty subtree beneath it (and so its
     * associated hash value is hasher.HashEmpty(index, height) rather than
     * hasher.HashChildren(l_hash, r_hash)).
     * </pre>
     *
     * <code>repeated bytes inclusion = 2;</code>
     * @return The count of inclusion.
     */
    @java.lang.Override
    public int getInclusionCount() {
      return inclusion_.size();
    }
    /**
     * <pre>
     * inclusion holds the inclusion proof for this leaf in the map root. It
     * holds one entry for each level of the tree; combining each of these in
     * turn with the leaf's hash (according to the tree's hash strategy)
     * reproduces the root hash.  A nil entry for a particular level indicates
     * that the node in question has an empty subtree beneath it (and so its
     * associated hash value is hasher.HashEmpty(index, height) rather than
     * hasher.HashChildren(l_hash, r_hash)).
     * </pre>
     *
     * <code>repeated bytes inclusion = 2;</code>
     * @param index The index of the element to return.
     * @return The inclusion at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getInclusion(int index) {
      return inclusion_.get(index);
    }
    private void ensureInclusionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> tmp = inclusion_;
      if (!tmp.isModifiable()) {
        inclusion_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * inclusion holds the inclusion proof for this leaf in the map root. It
     * holds one entry for each level of the tree; combining each of these in
     * turn with the leaf's hash (according to the tree's hash strategy)
     * reproduces the root hash.  A nil entry for a particular level indicates
     * that the node in question has an empty subtree beneath it (and so its
     * associated hash value is hasher.HashEmpty(index, height) rather than
     * hasher.HashChildren(l_hash, r_hash)).
     * </pre>
     *
     * <code>repeated bytes inclusion = 2;</code>
     * @param index The index to set the value at.
     * @param value The inclusion to set.
     */
    private void setInclusion(
        int index, com.google.protobuf.ByteString value) {
      value.getClass();
  ensureInclusionIsMutable();
      inclusion_.set(index, value);
    }
    /**
     * <pre>
     * inclusion holds the inclusion proof for this leaf in the map root. It
     * holds one entry for each level of the tree; combining each of these in
     * turn with the leaf's hash (according to the tree's hash strategy)
     * reproduces the root hash.  A nil entry for a particular level indicates
     * that the node in question has an empty subtree beneath it (and so its
     * associated hash value is hasher.HashEmpty(index, height) rather than
     * hasher.HashChildren(l_hash, r_hash)).
     * </pre>
     *
     * <code>repeated bytes inclusion = 2;</code>
     * @param value The inclusion to add.
     */
    private void addInclusion(com.google.protobuf.ByteString value) {
      value.getClass();
  ensureInclusionIsMutable();
      inclusion_.add(value);
    }
    /**
     * <pre>
     * inclusion holds the inclusion proof for this leaf in the map root. It
     * holds one entry for each level of the tree; combining each of these in
     * turn with the leaf's hash (according to the tree's hash strategy)
     * reproduces the root hash.  A nil entry for a particular level indicates
     * that the node in question has an empty subtree beneath it (and so its
     * associated hash value is hasher.HashEmpty(index, height) rather than
     * hasher.HashChildren(l_hash, r_hash)).
     * </pre>
     *
     * <code>repeated bytes inclusion = 2;</code>
     * @param values The inclusion to add.
     */
    private void addAllInclusion(
        java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
      ensureInclusionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, inclusion_);
    }
    /**
     * <pre>
     * inclusion holds the inclusion proof for this leaf in the map root. It
     * holds one entry for each level of the tree; combining each of these in
     * turn with the leaf's hash (according to the tree's hash strategy)
     * reproduces the root hash.  A nil entry for a particular level indicates
     * that the node in question has an empty subtree beneath it (and so its
     * associated hash value is hasher.HashEmpty(index, height) rather than
     * hasher.HashChildren(l_hash, r_hash)).
     * </pre>
     *
     * <code>repeated bytes inclusion = 2;</code>
     */
    private void clearInclusion() {
      inclusion_ = emptyProtobufList();
    }

    public static google.keytransparency.v1.Gkt.MapLeafInclusion parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.MapLeafInclusion parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapLeafInclusion parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.MapLeafInclusion parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapLeafInclusion parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.MapLeafInclusion parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapLeafInclusion parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.MapLeafInclusion parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapLeafInclusion parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.MapLeafInclusion parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.MapLeafInclusion parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.MapLeafInclusion parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.keytransparency.v1.Gkt.MapLeafInclusion prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code google.keytransparency.v1.MapLeafInclusion}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.keytransparency.v1.Gkt.MapLeafInclusion, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.keytransparency.v1.MapLeafInclusion)
        google.keytransparency.v1.Gkt.MapLeafInclusionOrBuilder {
      // Construct using google.keytransparency.v1.Gkt.MapLeafInclusion.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
       */
      @java.lang.Override
      public boolean hasLeaf() {
        return instance.hasLeaf();
      }
      /**
       * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
       */
      @java.lang.Override
      public google.keytransparency.v1.Gkt.TrillianMapLeaf getLeaf() {
        return instance.getLeaf();
      }
      /**
       * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
       */
      public Builder setLeaf(google.keytransparency.v1.Gkt.TrillianMapLeaf value) {
        copyOnWrite();
        instance.setLeaf(value);
        return this;
        }
      /**
       * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
       */
      public Builder setLeaf(
          google.keytransparency.v1.Gkt.TrillianMapLeaf.Builder builderForValue) {
        copyOnWrite();
        instance.setLeaf(builderForValue.build());
        return this;
      }
      /**
       * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
       */
      public Builder mergeLeaf(google.keytransparency.v1.Gkt.TrillianMapLeaf value) {
        copyOnWrite();
        instance.mergeLeaf(value);
        return this;
      }
      /**
       * <code>.google.keytransparency.v1.TrillianMapLeaf leaf = 1;</code>
       */
      public Builder clearLeaf() {  copyOnWrite();
        instance.clearLeaf();
        return this;
      }

      /**
       * <pre>
       * inclusion holds the inclusion proof for this leaf in the map root. It
       * holds one entry for each level of the tree; combining each of these in
       * turn with the leaf's hash (according to the tree's hash strategy)
       * reproduces the root hash.  A nil entry for a particular level indicates
       * that the node in question has an empty subtree beneath it (and so its
       * associated hash value is hasher.HashEmpty(index, height) rather than
       * hasher.HashChildren(l_hash, r_hash)).
       * </pre>
       *
       * <code>repeated bytes inclusion = 2;</code>
       * @return A list containing the inclusion.
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.ByteString>
          getInclusionList() {
        return java.util.Collections.unmodifiableList(
            instance.getInclusionList());
      }
      /**
       * <pre>
       * inclusion holds the inclusion proof for this leaf in the map root. It
       * holds one entry for each level of the tree; combining each of these in
       * turn with the leaf's hash (according to the tree's hash strategy)
       * reproduces the root hash.  A nil entry for a particular level indicates
       * that the node in question has an empty subtree beneath it (and so its
       * associated hash value is hasher.HashEmpty(index, height) rather than
       * hasher.HashChildren(l_hash, r_hash)).
       * </pre>
       *
       * <code>repeated bytes inclusion = 2;</code>
       * @return The count of inclusion.
       */
      @java.lang.Override
      public int getInclusionCount() {
        return instance.getInclusionCount();
      }
      /**
       * <pre>
       * inclusion holds the inclusion proof for this leaf in the map root. It
       * holds one entry for each level of the tree; combining each of these in
       * turn with the leaf's hash (according to the tree's hash strategy)
       * reproduces the root hash.  A nil entry for a particular level indicates
       * that the node in question has an empty subtree beneath it (and so its
       * associated hash value is hasher.HashEmpty(index, height) rather than
       * hasher.HashChildren(l_hash, r_hash)).
       * </pre>
       *
       * <code>repeated bytes inclusion = 2;</code>
       * @param index The index of the element to return.
       * @return The inclusion at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getInclusion(int index) {
        return instance.getInclusion(index);
      }
      /**
       * <pre>
       * inclusion holds the inclusion proof for this leaf in the map root. It
       * holds one entry for each level of the tree; combining each of these in
       * turn with the leaf's hash (according to the tree's hash strategy)
       * reproduces the root hash.  A nil entry for a particular level indicates
       * that the node in question has an empty subtree beneath it (and so its
       * associated hash value is hasher.HashEmpty(index, height) rather than
       * hasher.HashChildren(l_hash, r_hash)).
       * </pre>
       *
       * <code>repeated bytes inclusion = 2;</code>
       * @param value The inclusion to set.
       * @return This builder for chaining.
       */
      public Builder setInclusion(
          int index, com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setInclusion(index, value);
        return this;
      }
      /**
       * <pre>
       * inclusion holds the inclusion proof for this leaf in the map root. It
       * holds one entry for each level of the tree; combining each of these in
       * turn with the leaf's hash (according to the tree's hash strategy)
       * reproduces the root hash.  A nil entry for a particular level indicates
       * that the node in question has an empty subtree beneath it (and so its
       * associated hash value is hasher.HashEmpty(index, height) rather than
       * hasher.HashChildren(l_hash, r_hash)).
       * </pre>
       *
       * <code>repeated bytes inclusion = 2;</code>
       * @param value The inclusion to add.
       * @return This builder for chaining.
       */
      public Builder addInclusion(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addInclusion(value);
        return this;
      }
      /**
       * <pre>
       * inclusion holds the inclusion proof for this leaf in the map root. It
       * holds one entry for each level of the tree; combining each of these in
       * turn with the leaf's hash (according to the tree's hash strategy)
       * reproduces the root hash.  A nil entry for a particular level indicates
       * that the node in question has an empty subtree beneath it (and so its
       * associated hash value is hasher.HashEmpty(index, height) rather than
       * hasher.HashChildren(l_hash, r_hash)).
       * </pre>
       *
       * <code>repeated bytes inclusion = 2;</code>
       * @param values The inclusion to add.
       * @return This builder for chaining.
       */
      public Builder addAllInclusion(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        copyOnWrite();
        instance.addAllInclusion(values);
        return this;
      }
      /**
       * <pre>
       * inclusion holds the inclusion proof for this leaf in the map root. It
       * holds one entry for each level of the tree; combining each of these in
       * turn with the leaf's hash (according to the tree's hash strategy)
       * reproduces the root hash.  A nil entry for a particular level indicates
       * that the node in question has an empty subtree beneath it (and so its
       * associated hash value is hasher.HashEmpty(index, height) rather than
       * hasher.HashChildren(l_hash, r_hash)).
       * </pre>
       *
       * <code>repeated bytes inclusion = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearInclusion() {
        copyOnWrite();
        instance.clearInclusion();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.keytransparency.v1.MapLeafInclusion)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.keytransparency.v1.Gkt.MapLeafInclusion();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "leaf_",
              "inclusion_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0001\u0000\u0001\t\u0002\u001c" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.keytransparency.v1.Gkt.MapLeafInclusion> parser = PARSER;
          if (parser == null) {
            synchronized (google.keytransparency.v1.Gkt.MapLeafInclusion.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.keytransparency.v1.Gkt.MapLeafInclusion>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.keytransparency.v1.MapLeafInclusion)
    private static final google.keytransparency.v1.Gkt.MapLeafInclusion DEFAULT_INSTANCE;
    static {
      MapLeafInclusion defaultInstance = new MapLeafInclusion();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MapLeafInclusion.class, defaultInstance);
    }

    public static google.keytransparency.v1.Gkt.MapLeafInclusion getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MapLeafInclusion> PARSER;

    public static com.google.protobuf.Parser<MapLeafInclusion> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TrillianMapLeafOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.keytransparency.v1.TrillianMapLeaf)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * index is the location of this leaf.
     * All indexes for a given Map must contain a constant number of bits.
     * These are not numeric indices. Note that this is typically derived using a
     * hash and thus the length of all indices in the map will match the number
     * of bits in the hash function.
     * </pre>
     *
     * <code>bytes index = 1;</code>
     * @return The index.
     */
    com.google.protobuf.ByteString getIndex();

    /**
     * <pre>
     * leaf_hash is the tree hash of leaf_value.  This does not need to be set
     * on SetMapLeavesRequest; the server will fill it in.
     * For an empty leaf (len(leaf_value)==0), there may be two possible values
     * for this hash:
     *  - If the leaf has never been set, it counts as an empty subtree and
     *    a nil value is used.
     *  - If the leaf has been explicitly set to a zero-length entry, it no
     *    longer counts as empty and the value of hasher.HashLeaf(index, nil)
     *    will be used.
     * </pre>
     *
     * <code>bytes leaf_hash = 2;</code>
     * @return The leafHash.
     */
    com.google.protobuf.ByteString getLeafHash();

    /**
     * <pre>
     * leaf_value is the data the tree commits to.
     * </pre>
     *
     * <code>bytes leaf_value = 3;</code>
     * @return The leafValue.
     */
    com.google.protobuf.ByteString getLeafValue();

    /**
     * <pre>
     * extra_data holds related contextual data, but is not covered by any hash.
     * </pre>
     *
     * <code>bytes extra_data = 4;</code>
     * @return The extraData.
     */
    com.google.protobuf.ByteString getExtraData();
  }
  /**
   * <pre>
   * renamed by rwest
   * TrillianMapLeaf represents the data behind Map leaves.
   * </pre>
   *
   * Protobuf type {@code google.keytransparency.v1.TrillianMapLeaf}
   */
  public  static final class TrillianMapLeaf extends
      com.google.protobuf.GeneratedMessageLite<
          TrillianMapLeaf, TrillianMapLeaf.Builder> implements
      // @@protoc_insertion_point(message_implements:google.keytransparency.v1.TrillianMapLeaf)
      TrillianMapLeafOrBuilder {
    private TrillianMapLeaf() {
      index_ = com.google.protobuf.ByteString.EMPTY;
      leafHash_ = com.google.protobuf.ByteString.EMPTY;
      leafValue_ = com.google.protobuf.ByteString.EMPTY;
      extraData_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int INDEX_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString index_;
    /**
     * <pre>
     * index is the location of this leaf.
     * All indexes for a given Map must contain a constant number of bits.
     * These are not numeric indices. Note that this is typically derived using a
     * hash and thus the length of all indices in the map will match the number
     * of bits in the hash function.
     * </pre>
     *
     * <code>bytes index = 1;</code>
     * @return The index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getIndex() {
      return index_;
    }
    /**
     * <pre>
     * index is the location of this leaf.
     * All indexes for a given Map must contain a constant number of bits.
     * These are not numeric indices. Note that this is typically derived using a
     * hash and thus the length of all indices in the map will match the number
     * of bits in the hash function.
     * </pre>
     *
     * <code>bytes index = 1;</code>
     * @param value The index to set.
     */
    private void setIndex(com.google.protobuf.ByteString value) {
      value.getClass();
  
      index_ = value;
    }
    /**
     * <pre>
     * index is the location of this leaf.
     * All indexes for a given Map must contain a constant number of bits.
     * These are not numeric indices. Note that this is typically derived using a
     * hash and thus the length of all indices in the map will match the number
     * of bits in the hash function.
     * </pre>
     *
     * <code>bytes index = 1;</code>
     */
    private void clearIndex() {
      
      index_ = getDefaultInstance().getIndex();
    }

    public static final int LEAF_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString leafHash_;
    /**
     * <pre>
     * leaf_hash is the tree hash of leaf_value.  This does not need to be set
     * on SetMapLeavesRequest; the server will fill it in.
     * For an empty leaf (len(leaf_value)==0), there may be two possible values
     * for this hash:
     *  - If the leaf has never been set, it counts as an empty subtree and
     *    a nil value is used.
     *  - If the leaf has been explicitly set to a zero-length entry, it no
     *    longer counts as empty and the value of hasher.HashLeaf(index, nil)
     *    will be used.
     * </pre>
     *
     * <code>bytes leaf_hash = 2;</code>
     * @return The leafHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLeafHash() {
      return leafHash_;
    }
    /**
     * <pre>
     * leaf_hash is the tree hash of leaf_value.  This does not need to be set
     * on SetMapLeavesRequest; the server will fill it in.
     * For an empty leaf (len(leaf_value)==0), there may be two possible values
     * for this hash:
     *  - If the leaf has never been set, it counts as an empty subtree and
     *    a nil value is used.
     *  - If the leaf has been explicitly set to a zero-length entry, it no
     *    longer counts as empty and the value of hasher.HashLeaf(index, nil)
     *    will be used.
     * </pre>
     *
     * <code>bytes leaf_hash = 2;</code>
     * @param value The leafHash to set.
     */
    private void setLeafHash(com.google.protobuf.ByteString value) {
      value.getClass();
  
      leafHash_ = value;
    }
    /**
     * <pre>
     * leaf_hash is the tree hash of leaf_value.  This does not need to be set
     * on SetMapLeavesRequest; the server will fill it in.
     * For an empty leaf (len(leaf_value)==0), there may be two possible values
     * for this hash:
     *  - If the leaf has never been set, it counts as an empty subtree and
     *    a nil value is used.
     *  - If the leaf has been explicitly set to a zero-length entry, it no
     *    longer counts as empty and the value of hasher.HashLeaf(index, nil)
     *    will be used.
     * </pre>
     *
     * <code>bytes leaf_hash = 2;</code>
     */
    private void clearLeafHash() {
      
      leafHash_ = getDefaultInstance().getLeafHash();
    }

    public static final int LEAF_VALUE_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString leafValue_;
    /**
     * <pre>
     * leaf_value is the data the tree commits to.
     * </pre>
     *
     * <code>bytes leaf_value = 3;</code>
     * @return The leafValue.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLeafValue() {
      return leafValue_;
    }
    /**
     * <pre>
     * leaf_value is the data the tree commits to.
     * </pre>
     *
     * <code>bytes leaf_value = 3;</code>
     * @param value The leafValue to set.
     */
    private void setLeafValue(com.google.protobuf.ByteString value) {
      value.getClass();
  
      leafValue_ = value;
    }
    /**
     * <pre>
     * leaf_value is the data the tree commits to.
     * </pre>
     *
     * <code>bytes leaf_value = 3;</code>
     */
    private void clearLeafValue() {
      
      leafValue_ = getDefaultInstance().getLeafValue();
    }

    public static final int EXTRA_DATA_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString extraData_;
    /**
     * <pre>
     * extra_data holds related contextual data, but is not covered by any hash.
     * </pre>
     *
     * <code>bytes extra_data = 4;</code>
     * @return The extraData.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getExtraData() {
      return extraData_;
    }
    /**
     * <pre>
     * extra_data holds related contextual data, but is not covered by any hash.
     * </pre>
     *
     * <code>bytes extra_data = 4;</code>
     * @param value The extraData to set.
     */
    private void setExtraData(com.google.protobuf.ByteString value) {
      value.getClass();
  
      extraData_ = value;
    }
    /**
     * <pre>
     * extra_data holds related contextual data, but is not covered by any hash.
     * </pre>
     *
     * <code>bytes extra_data = 4;</code>
     */
    private void clearExtraData() {
      
      extraData_ = getDefaultInstance().getExtraData();
    }

    public static google.keytransparency.v1.Gkt.TrillianMapLeaf parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.TrillianMapLeaf parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.TrillianMapLeaf parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.TrillianMapLeaf parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.TrillianMapLeaf parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.keytransparency.v1.Gkt.TrillianMapLeaf parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.TrillianMapLeaf parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.TrillianMapLeaf parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.TrillianMapLeaf parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.TrillianMapLeaf parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.keytransparency.v1.Gkt.TrillianMapLeaf parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.keytransparency.v1.Gkt.TrillianMapLeaf parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.keytransparency.v1.Gkt.TrillianMapLeaf prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * renamed by rwest
     * TrillianMapLeaf represents the data behind Map leaves.
     * </pre>
     *
     * Protobuf type {@code google.keytransparency.v1.TrillianMapLeaf}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.keytransparency.v1.Gkt.TrillianMapLeaf, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.keytransparency.v1.TrillianMapLeaf)
        google.keytransparency.v1.Gkt.TrillianMapLeafOrBuilder {
      // Construct using google.keytransparency.v1.Gkt.TrillianMapLeaf.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * index is the location of this leaf.
       * All indexes for a given Map must contain a constant number of bits.
       * These are not numeric indices. Note that this is typically derived using a
       * hash and thus the length of all indices in the map will match the number
       * of bits in the hash function.
       * </pre>
       *
       * <code>bytes index = 1;</code>
       * @return The index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getIndex() {
        return instance.getIndex();
      }
      /**
       * <pre>
       * index is the location of this leaf.
       * All indexes for a given Map must contain a constant number of bits.
       * These are not numeric indices. Note that this is typically derived using a
       * hash and thus the length of all indices in the map will match the number
       * of bits in the hash function.
       * </pre>
       *
       * <code>bytes index = 1;</code>
       * @param value The index to set.
       * @return This builder for chaining.
       */
      public Builder setIndex(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIndex(value);
        return this;
      }
      /**
       * <pre>
       * index is the location of this leaf.
       * All indexes for a given Map must contain a constant number of bits.
       * These are not numeric indices. Note that this is typically derived using a
       * hash and thus the length of all indices in the map will match the number
       * of bits in the hash function.
       * </pre>
       *
       * <code>bytes index = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearIndex() {
        copyOnWrite();
        instance.clearIndex();
        return this;
      }

      /**
       * <pre>
       * leaf_hash is the tree hash of leaf_value.  This does not need to be set
       * on SetMapLeavesRequest; the server will fill it in.
       * For an empty leaf (len(leaf_value)==0), there may be two possible values
       * for this hash:
       *  - If the leaf has never been set, it counts as an empty subtree and
       *    a nil value is used.
       *  - If the leaf has been explicitly set to a zero-length entry, it no
       *    longer counts as empty and the value of hasher.HashLeaf(index, nil)
       *    will be used.
       * </pre>
       *
       * <code>bytes leaf_hash = 2;</code>
       * @return The leafHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLeafHash() {
        return instance.getLeafHash();
      }
      /**
       * <pre>
       * leaf_hash is the tree hash of leaf_value.  This does not need to be set
       * on SetMapLeavesRequest; the server will fill it in.
       * For an empty leaf (len(leaf_value)==0), there may be two possible values
       * for this hash:
       *  - If the leaf has never been set, it counts as an empty subtree and
       *    a nil value is used.
       *  - If the leaf has been explicitly set to a zero-length entry, it no
       *    longer counts as empty and the value of hasher.HashLeaf(index, nil)
       *    will be used.
       * </pre>
       *
       * <code>bytes leaf_hash = 2;</code>
       * @param value The leafHash to set.
       * @return This builder for chaining.
       */
      public Builder setLeafHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLeafHash(value);
        return this;
      }
      /**
       * <pre>
       * leaf_hash is the tree hash of leaf_value.  This does not need to be set
       * on SetMapLeavesRequest; the server will fill it in.
       * For an empty leaf (len(leaf_value)==0), there may be two possible values
       * for this hash:
       *  - If the leaf has never been set, it counts as an empty subtree and
       *    a nil value is used.
       *  - If the leaf has been explicitly set to a zero-length entry, it no
       *    longer counts as empty and the value of hasher.HashLeaf(index, nil)
       *    will be used.
       * </pre>
       *
       * <code>bytes leaf_hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearLeafHash() {
        copyOnWrite();
        instance.clearLeafHash();
        return this;
      }

      /**
       * <pre>
       * leaf_value is the data the tree commits to.
       * </pre>
       *
       * <code>bytes leaf_value = 3;</code>
       * @return The leafValue.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLeafValue() {
        return instance.getLeafValue();
      }
      /**
       * <pre>
       * leaf_value is the data the tree commits to.
       * </pre>
       *
       * <code>bytes leaf_value = 3;</code>
       * @param value The leafValue to set.
       * @return This builder for chaining.
       */
      public Builder setLeafValue(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLeafValue(value);
        return this;
      }
      /**
       * <pre>
       * leaf_value is the data the tree commits to.
       * </pre>
       *
       * <code>bytes leaf_value = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearLeafValue() {
        copyOnWrite();
        instance.clearLeafValue();
        return this;
      }

      /**
       * <pre>
       * extra_data holds related contextual data, but is not covered by any hash.
       * </pre>
       *
       * <code>bytes extra_data = 4;</code>
       * @return The extraData.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getExtraData() {
        return instance.getExtraData();
      }
      /**
       * <pre>
       * extra_data holds related contextual data, but is not covered by any hash.
       * </pre>
       *
       * <code>bytes extra_data = 4;</code>
       * @param value The extraData to set.
       * @return This builder for chaining.
       */
      public Builder setExtraData(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setExtraData(value);
        return this;
      }
      /**
       * <pre>
       * extra_data holds related contextual data, but is not covered by any hash.
       * </pre>
       *
       * <code>bytes extra_data = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearExtraData() {
        copyOnWrite();
        instance.clearExtraData();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.keytransparency.v1.TrillianMapLeaf)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.keytransparency.v1.Gkt.TrillianMapLeaf();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "index_",
              "leafHash_",
              "leafValue_",
              "extraData_",
            };
            java.lang.String info =
                "\u0000\u0004\u0000\u0000\u0001\u0004\u0004\u0000\u0000\u0000\u0001\n\u0002\n\u0003" +
                "\n\u0004\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.keytransparency.v1.Gkt.TrillianMapLeaf> parser = PARSER;
          if (parser == null) {
            synchronized (google.keytransparency.v1.Gkt.TrillianMapLeaf.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.keytransparency.v1.Gkt.TrillianMapLeaf>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.keytransparency.v1.TrillianMapLeaf)
    private static final google.keytransparency.v1.Gkt.TrillianMapLeaf DEFAULT_INSTANCE;
    static {
      TrillianMapLeaf defaultInstance = new TrillianMapLeaf();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TrillianMapLeaf.class, defaultInstance);
    }

    public static google.keytransparency.v1.Gkt.TrillianMapLeaf getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TrillianMapLeaf> PARSER;

    public static com.google.protobuf.Parser<TrillianMapLeaf> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
