// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: storage/cloudspanner/spannerpb/spanner.proto

package google.trillian.spannerpb;

public final class Spanner {
  private Spanner() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  /**
   * <pre>
   * State of the Tree.
   * Mirrors trillian.TreeState.
   * </pre>
   *
   * Protobuf enum {@code spannerpb.TreeState}
   */
  public enum TreeState
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>UNKNOWN_TREE_STATE = 0;</code>
     */
    UNKNOWN_TREE_STATE(0),
    /**
     * <code>ACTIVE = 1;</code>
     */
    ACTIVE(1),
    /**
     * <code>FROZEN = 2;</code>
     */
    FROZEN(2),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>UNKNOWN_TREE_STATE = 0;</code>
     */
    public static final int UNKNOWN_TREE_STATE_VALUE = 0;
    /**
     * <code>ACTIVE = 1;</code>
     */
    public static final int ACTIVE_VALUE = 1;
    /**
     * <code>FROZEN = 2;</code>
     */
    public static final int FROZEN_VALUE = 2;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static TreeState valueOf(int value) {
      return forNumber(value);
    }

    public static TreeState forNumber(int value) {
      switch (value) {
        case 0: return UNKNOWN_TREE_STATE;
        case 1: return ACTIVE;
        case 2: return FROZEN;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<TreeState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        TreeState> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<TreeState>() {
            @java.lang.Override
            public TreeState findValueByNumber(int number) {
              return TreeState.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return TreeStateVerifier.INSTANCE;
    }

    private static final class TreeStateVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new TreeStateVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return TreeState.forNumber(number) != null;
            }
          };

    private final int value;

    private TreeState(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:spannerpb.TreeState)
  }

  /**
   * <pre>
   * Type of the Tree.
   * Mirrors trillian.TreeType.
   * </pre>
   *
   * Protobuf enum {@code spannerpb.TreeType}
   */
  public enum TreeType
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>UNKNOWN = 0;</code>
     */
    UNKNOWN(0),
    /**
     * <code>LOG = 1;</code>
     */
    LOG(1),
    /**
     * <code>MAP = 2;</code>
     */
    MAP(2),
    /**
     * <code>PREORDERED_LOG = 3;</code>
     */
    PREORDERED_LOG(3),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>UNKNOWN = 0;</code>
     */
    public static final int UNKNOWN_VALUE = 0;
    /**
     * <code>LOG = 1;</code>
     */
    public static final int LOG_VALUE = 1;
    /**
     * <code>MAP = 2;</code>
     */
    public static final int MAP_VALUE = 2;
    /**
     * <code>PREORDERED_LOG = 3;</code>
     */
    public static final int PREORDERED_LOG_VALUE = 3;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static TreeType valueOf(int value) {
      return forNumber(value);
    }

    public static TreeType forNumber(int value) {
      switch (value) {
        case 0: return UNKNOWN;
        case 1: return LOG;
        case 2: return MAP;
        case 3: return PREORDERED_LOG;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<TreeType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        TreeType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<TreeType>() {
            @java.lang.Override
            public TreeType findValueByNumber(int number) {
              return TreeType.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return TreeTypeVerifier.INSTANCE;
    }

    private static final class TreeTypeVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new TreeTypeVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return TreeType.forNumber(number) != null;
            }
          };

    private final int value;

    private TreeType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:spannerpb.TreeType)
  }

  /**
   * <pre>
   * Defines the preimage protection used for tree leaves / nodes.
   * Eg, RFC6962 dictates a 0x00 prefix for leaves and 0x01 for nodes.
   * Mirrors trillian.HashStrategy.
   * </pre>
   *
   * Protobuf enum {@code spannerpb.HashStrategy}
   */
  public enum HashStrategy
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>UNKNOWN_HASH_STRATEGY = 0;</code>
     */
    UNKNOWN_HASH_STRATEGY(0),
    /**
     * <code>RFC_6962 = 1;</code>
     */
    RFC_6962(1),
    /**
     * <code>TEST_MAP_HASHER = 2;</code>
     */
    TEST_MAP_HASHER(2),
    /**
     * <code>OBJECT_RFC6962_SHA256 = 3;</code>
     */
    OBJECT_RFC6962_SHA256(3),
    /**
     * <code>CONIKS_SHA512_256 = 4;</code>
     */
    CONIKS_SHA512_256(4),
    /**
     * <code>CONIKS_SHA256 = 5;</code>
     */
    CONIKS_SHA256(5),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>UNKNOWN_HASH_STRATEGY = 0;</code>
     */
    public static final int UNKNOWN_HASH_STRATEGY_VALUE = 0;
    /**
     * <code>RFC_6962 = 1;</code>
     */
    public static final int RFC_6962_VALUE = 1;
    /**
     * <code>TEST_MAP_HASHER = 2;</code>
     */
    public static final int TEST_MAP_HASHER_VALUE = 2;
    /**
     * <code>OBJECT_RFC6962_SHA256 = 3;</code>
     */
    public static final int OBJECT_RFC6962_SHA256_VALUE = 3;
    /**
     * <code>CONIKS_SHA512_256 = 4;</code>
     */
    public static final int CONIKS_SHA512_256_VALUE = 4;
    /**
     * <code>CONIKS_SHA256 = 5;</code>
     */
    public static final int CONIKS_SHA256_VALUE = 5;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static HashStrategy valueOf(int value) {
      return forNumber(value);
    }

    public static HashStrategy forNumber(int value) {
      switch (value) {
        case 0: return UNKNOWN_HASH_STRATEGY;
        case 1: return RFC_6962;
        case 2: return TEST_MAP_HASHER;
        case 3: return OBJECT_RFC6962_SHA256;
        case 4: return CONIKS_SHA512_256;
        case 5: return CONIKS_SHA256;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<HashStrategy>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        HashStrategy> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<HashStrategy>() {
            @java.lang.Override
            public HashStrategy findValueByNumber(int number) {
              return HashStrategy.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return HashStrategyVerifier.INSTANCE;
    }

    private static final class HashStrategyVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new HashStrategyVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return HashStrategy.forNumber(number) != null;
            }
          };

    private final int value;

    private HashStrategy(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:spannerpb.HashStrategy)
  }

  /**
   * <pre>
   * Supported hash algorithms.
   * The numbering space is the same as for TLS, given in RFC 5246 s7.4.1.4.1. See
   * http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-18.
   * Mirrors trillian.HashAlgorithm.
   * </pre>
   *
   * Protobuf enum {@code spannerpb.HashAlgorithm}
   */
  public enum HashAlgorithm
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     * No hash algorithm is used.
     * </pre>
     *
     * <code>NONE = 0;</code>
     */
    NONE(0),
    /**
     * <pre>
     * SHA256 is used.
     * </pre>
     *
     * <code>SHA256 = 4;</code>
     */
    SHA256(4),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * No hash algorithm is used.
     * </pre>
     *
     * <code>NONE = 0;</code>
     */
    public static final int NONE_VALUE = 0;
    /**
     * <pre>
     * SHA256 is used.
     * </pre>
     *
     * <code>SHA256 = 4;</code>
     */
    public static final int SHA256_VALUE = 4;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static HashAlgorithm valueOf(int value) {
      return forNumber(value);
    }

    public static HashAlgorithm forNumber(int value) {
      switch (value) {
        case 0: return NONE;
        case 4: return SHA256;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<HashAlgorithm>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        HashAlgorithm> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<HashAlgorithm>() {
            @java.lang.Override
            public HashAlgorithm findValueByNumber(int number) {
              return HashAlgorithm.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return HashAlgorithmVerifier.INSTANCE;
    }

    private static final class HashAlgorithmVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new HashAlgorithmVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return HashAlgorithm.forNumber(number) != null;
            }
          };

    private final int value;

    private HashAlgorithm(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:spannerpb.HashAlgorithm)
  }

  /**
   * <pre>
   * Supported signature algorithms.
   * The numbering space is the same as for TLS, given in RFC 5246 s7.4.1.4.1. See
   * http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-16.
   * Mirrors trillian.SignatureAlgorithm.
   * </pre>
   *
   * Protobuf enum {@code spannerpb.SignatureAlgorithm}
   */
  public enum SignatureAlgorithm
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     * Anonymous signature scheme.
     * </pre>
     *
     * <code>ANONYMOUS = 0;</code>
     */
    ANONYMOUS(0),
    /**
     * <pre>
     * RSA signature scheme.
     * </pre>
     *
     * <code>RSA = 1;</code>
     */
    RSA(1),
    /**
     * <pre>
     * ECDSA signature scheme.
     * </pre>
     *
     * <code>ECDSA = 3;</code>
     */
    ECDSA(3),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Anonymous signature scheme.
     * </pre>
     *
     * <code>ANONYMOUS = 0;</code>
     */
    public static final int ANONYMOUS_VALUE = 0;
    /**
     * <pre>
     * RSA signature scheme.
     * </pre>
     *
     * <code>RSA = 1;</code>
     */
    public static final int RSA_VALUE = 1;
    /**
     * <pre>
     * ECDSA signature scheme.
     * </pre>
     *
     * <code>ECDSA = 3;</code>
     */
    public static final int ECDSA_VALUE = 3;


    @java.lang.Override
    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The number of the enum to look for.
     * @return The enum associated with the given number.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static SignatureAlgorithm valueOf(int value) {
      return forNumber(value);
    }

    public static SignatureAlgorithm forNumber(int value) {
      switch (value) {
        case 0: return ANONYMOUS;
        case 1: return RSA;
        case 3: return ECDSA;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SignatureAlgorithm>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        SignatureAlgorithm> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<SignatureAlgorithm>() {
            @java.lang.Override
            public SignatureAlgorithm findValueByNumber(int number) {
              return SignatureAlgorithm.forNumber(number);
            }
          };

    public static com.google.protobuf.Internal.EnumVerifier 
        internalGetVerifier() {
      return SignatureAlgorithmVerifier.INSTANCE;
    }

    private static final class SignatureAlgorithmVerifier implements 
         com.google.protobuf.Internal.EnumVerifier { 
            static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SignatureAlgorithmVerifier();
            @java.lang.Override
            public boolean isInRange(int number) {
              return SignatureAlgorithm.forNumber(number) != null;
            }
          };

    private final int value;

    private SignatureAlgorithm(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:spannerpb.SignatureAlgorithm)
  }

  public interface LogStorageConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:spannerpb.LogStorageConfig)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * num_unseq_buckets defines the length of the unsequenced time ring buffer.
     * This value must *never* be reduced for any provisioned tree.
     * This value should be &gt;= 1, and there's probably not much benefit in
     * raising it past about 4.
     * TODO(al): test what the effects of various values are here.
     * </pre>
     *
     * <code>int64 num_unseq_buckets = 1;</code>
     * @return The numUnseqBuckets.
     */
    long getNumUnseqBuckets();

    /**
     * <pre>
     * num_merkle_buckets defines the number of individual buckets below each
     * unsequenced ring bucket.
     * This value may be changed at any time (so long as you understand the
     * impact it'll have on integration performace!)
     * This value must lie in the range [1..256]
     * </pre>
     *
     * <code>int64 num_merkle_buckets = 2;</code>
     * @return The numMerkleBuckets.
     */
    long getNumMerkleBuckets();
  }
  /**
   * <pre>
   * LogStorageConfig holds settings which tune the storage implementation for
   * a given log tree.
   * </pre>
   *
   * Protobuf type {@code spannerpb.LogStorageConfig}
   */
  public  static final class LogStorageConfig extends
      com.google.protobuf.GeneratedMessageLite<
          LogStorageConfig, LogStorageConfig.Builder> implements
      // @@protoc_insertion_point(message_implements:spannerpb.LogStorageConfig)
      LogStorageConfigOrBuilder {
    private LogStorageConfig() {
    }
    public static final int NUM_UNSEQ_BUCKETS_FIELD_NUMBER = 1;
    private long numUnseqBuckets_;
    /**
     * <pre>
     * num_unseq_buckets defines the length of the unsequenced time ring buffer.
     * This value must *never* be reduced for any provisioned tree.
     * This value should be &gt;= 1, and there's probably not much benefit in
     * raising it past about 4.
     * TODO(al): test what the effects of various values are here.
     * </pre>
     *
     * <code>int64 num_unseq_buckets = 1;</code>
     * @return The numUnseqBuckets.
     */
    @java.lang.Override
    public long getNumUnseqBuckets() {
      return numUnseqBuckets_;
    }
    /**
     * <pre>
     * num_unseq_buckets defines the length of the unsequenced time ring buffer.
     * This value must *never* be reduced for any provisioned tree.
     * This value should be &gt;= 1, and there's probably not much benefit in
     * raising it past about 4.
     * TODO(al): test what the effects of various values are here.
     * </pre>
     *
     * <code>int64 num_unseq_buckets = 1;</code>
     * @param value The numUnseqBuckets to set.
     */
    private void setNumUnseqBuckets(long value) {
      
      numUnseqBuckets_ = value;
    }
    /**
     * <pre>
     * num_unseq_buckets defines the length of the unsequenced time ring buffer.
     * This value must *never* be reduced for any provisioned tree.
     * This value should be &gt;= 1, and there's probably not much benefit in
     * raising it past about 4.
     * TODO(al): test what the effects of various values are here.
     * </pre>
     *
     * <code>int64 num_unseq_buckets = 1;</code>
     */
    private void clearNumUnseqBuckets() {
      
      numUnseqBuckets_ = 0L;
    }

    public static final int NUM_MERKLE_BUCKETS_FIELD_NUMBER = 2;
    private long numMerkleBuckets_;
    /**
     * <pre>
     * num_merkle_buckets defines the number of individual buckets below each
     * unsequenced ring bucket.
     * This value may be changed at any time (so long as you understand the
     * impact it'll have on integration performace!)
     * This value must lie in the range [1..256]
     * </pre>
     *
     * <code>int64 num_merkle_buckets = 2;</code>
     * @return The numMerkleBuckets.
     */
    @java.lang.Override
    public long getNumMerkleBuckets() {
      return numMerkleBuckets_;
    }
    /**
     * <pre>
     * num_merkle_buckets defines the number of individual buckets below each
     * unsequenced ring bucket.
     * This value may be changed at any time (so long as you understand the
     * impact it'll have on integration performace!)
     * This value must lie in the range [1..256]
     * </pre>
     *
     * <code>int64 num_merkle_buckets = 2;</code>
     * @param value The numMerkleBuckets to set.
     */
    private void setNumMerkleBuckets(long value) {
      
      numMerkleBuckets_ = value;
    }
    /**
     * <pre>
     * num_merkle_buckets defines the number of individual buckets below each
     * unsequenced ring bucket.
     * This value may be changed at any time (so long as you understand the
     * impact it'll have on integration performace!)
     * This value must lie in the range [1..256]
     * </pre>
     *
     * <code>int64 num_merkle_buckets = 2;</code>
     */
    private void clearNumMerkleBuckets() {
      
      numMerkleBuckets_ = 0L;
    }

    public static google.trillian.spannerpb.Spanner.LogStorageConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.spannerpb.Spanner.LogStorageConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.LogStorageConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.spannerpb.Spanner.LogStorageConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.LogStorageConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.spannerpb.Spanner.LogStorageConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.LogStorageConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.spannerpb.Spanner.LogStorageConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.LogStorageConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.trillian.spannerpb.Spanner.LogStorageConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.LogStorageConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.spannerpb.Spanner.LogStorageConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.trillian.spannerpb.Spanner.LogStorageConfig prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * LogStorageConfig holds settings which tune the storage implementation for
     * a given log tree.
     * </pre>
     *
     * Protobuf type {@code spannerpb.LogStorageConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.trillian.spannerpb.Spanner.LogStorageConfig, Builder> implements
        // @@protoc_insertion_point(builder_implements:spannerpb.LogStorageConfig)
        google.trillian.spannerpb.Spanner.LogStorageConfigOrBuilder {
      // Construct using google.trillian.spannerpb.Spanner.LogStorageConfig.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * num_unseq_buckets defines the length of the unsequenced time ring buffer.
       * This value must *never* be reduced for any provisioned tree.
       * This value should be &gt;= 1, and there's probably not much benefit in
       * raising it past about 4.
       * TODO(al): test what the effects of various values are here.
       * </pre>
       *
       * <code>int64 num_unseq_buckets = 1;</code>
       * @return The numUnseqBuckets.
       */
      @java.lang.Override
      public long getNumUnseqBuckets() {
        return instance.getNumUnseqBuckets();
      }
      /**
       * <pre>
       * num_unseq_buckets defines the length of the unsequenced time ring buffer.
       * This value must *never* be reduced for any provisioned tree.
       * This value should be &gt;= 1, and there's probably not much benefit in
       * raising it past about 4.
       * TODO(al): test what the effects of various values are here.
       * </pre>
       *
       * <code>int64 num_unseq_buckets = 1;</code>
       * @param value The numUnseqBuckets to set.
       * @return This builder for chaining.
       */
      public Builder setNumUnseqBuckets(long value) {
        copyOnWrite();
        instance.setNumUnseqBuckets(value);
        return this;
      }
      /**
       * <pre>
       * num_unseq_buckets defines the length of the unsequenced time ring buffer.
       * This value must *never* be reduced for any provisioned tree.
       * This value should be &gt;= 1, and there's probably not much benefit in
       * raising it past about 4.
       * TODO(al): test what the effects of various values are here.
       * </pre>
       *
       * <code>int64 num_unseq_buckets = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumUnseqBuckets() {
        copyOnWrite();
        instance.clearNumUnseqBuckets();
        return this;
      }

      /**
       * <pre>
       * num_merkle_buckets defines the number of individual buckets below each
       * unsequenced ring bucket.
       * This value may be changed at any time (so long as you understand the
       * impact it'll have on integration performace!)
       * This value must lie in the range [1..256]
       * </pre>
       *
       * <code>int64 num_merkle_buckets = 2;</code>
       * @return The numMerkleBuckets.
       */
      @java.lang.Override
      public long getNumMerkleBuckets() {
        return instance.getNumMerkleBuckets();
      }
      /**
       * <pre>
       * num_merkle_buckets defines the number of individual buckets below each
       * unsequenced ring bucket.
       * This value may be changed at any time (so long as you understand the
       * impact it'll have on integration performace!)
       * This value must lie in the range [1..256]
       * </pre>
       *
       * <code>int64 num_merkle_buckets = 2;</code>
       * @param value The numMerkleBuckets to set.
       * @return This builder for chaining.
       */
      public Builder setNumMerkleBuckets(long value) {
        copyOnWrite();
        instance.setNumMerkleBuckets(value);
        return this;
      }
      /**
       * <pre>
       * num_merkle_buckets defines the number of individual buckets below each
       * unsequenced ring bucket.
       * This value may be changed at any time (so long as you understand the
       * impact it'll have on integration performace!)
       * This value must lie in the range [1..256]
       * </pre>
       *
       * <code>int64 num_merkle_buckets = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumMerkleBuckets() {
        copyOnWrite();
        instance.clearNumMerkleBuckets();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:spannerpb.LogStorageConfig)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.trillian.spannerpb.Spanner.LogStorageConfig();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "numUnseqBuckets_",
              "numMerkleBuckets_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u0002\u0002\u0002" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.trillian.spannerpb.Spanner.LogStorageConfig> parser = PARSER;
          if (parser == null) {
            synchronized (google.trillian.spannerpb.Spanner.LogStorageConfig.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.trillian.spannerpb.Spanner.LogStorageConfig>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:spannerpb.LogStorageConfig)
    private static final google.trillian.spannerpb.Spanner.LogStorageConfig DEFAULT_INSTANCE;
    static {
      LogStorageConfig defaultInstance = new LogStorageConfig();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        LogStorageConfig.class, defaultInstance);
    }

    public static google.trillian.spannerpb.Spanner.LogStorageConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<LogStorageConfig> PARSER;

    public static com.google.protobuf.Parser<LogStorageConfig> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MapStorageConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:spannerpb.MapStorageConfig)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * <pre>
   * MapStorageConfig holds settings which tune the storage implementation for
   * a given map tree.
   * </pre>
   *
   * Protobuf type {@code spannerpb.MapStorageConfig}
   */
  public  static final class MapStorageConfig extends
      com.google.protobuf.GeneratedMessageLite<
          MapStorageConfig, MapStorageConfig.Builder> implements
      // @@protoc_insertion_point(message_implements:spannerpb.MapStorageConfig)
      MapStorageConfigOrBuilder {
    private MapStorageConfig() {
    }
    public static google.trillian.spannerpb.Spanner.MapStorageConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.spannerpb.Spanner.MapStorageConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.MapStorageConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.spannerpb.Spanner.MapStorageConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.MapStorageConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.spannerpb.Spanner.MapStorageConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.MapStorageConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.spannerpb.Spanner.MapStorageConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.MapStorageConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.trillian.spannerpb.Spanner.MapStorageConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.MapStorageConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.spannerpb.Spanner.MapStorageConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.trillian.spannerpb.Spanner.MapStorageConfig prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * MapStorageConfig holds settings which tune the storage implementation for
     * a given map tree.
     * </pre>
     *
     * Protobuf type {@code spannerpb.MapStorageConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.trillian.spannerpb.Spanner.MapStorageConfig, Builder> implements
        // @@protoc_insertion_point(builder_implements:spannerpb.MapStorageConfig)
        google.trillian.spannerpb.Spanner.MapStorageConfigOrBuilder {
      // Construct using google.trillian.spannerpb.Spanner.MapStorageConfig.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:spannerpb.MapStorageConfig)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.trillian.spannerpb.Spanner.MapStorageConfig();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0000\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.trillian.spannerpb.Spanner.MapStorageConfig> parser = PARSER;
          if (parser == null) {
            synchronized (google.trillian.spannerpb.Spanner.MapStorageConfig.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.trillian.spannerpb.Spanner.MapStorageConfig>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:spannerpb.MapStorageConfig)
    private static final google.trillian.spannerpb.Spanner.MapStorageConfig DEFAULT_INSTANCE;
    static {
      MapStorageConfig defaultInstance = new MapStorageConfig();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MapStorageConfig.class, defaultInstance);
    }

    public static google.trillian.spannerpb.Spanner.MapStorageConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MapStorageConfig> PARSER;

    public static com.google.protobuf.Parser<MapStorageConfig> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TreeInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:spannerpb.TreeInfo)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * tree_id is the ID of the tree, and is used as a primary key.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     * @return The treeId.
     */
    long getTreeId();

    /**
     * <pre>
     * key_id identifies the private key associated with this tree.
     * </pre>
     *
     * <code>int64 key_id = 2;</code>
     * @return The keyId.
     */
    long getKeyId();

    /**
     * <pre>
     * name is a short name for this tree.
     * </pre>
     *
     * <code>string name = 3;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * name is a short name for this tree.
     * </pre>
     *
     * <code>string name = 3;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * description is a short free form text describing the tree.
     * </pre>
     *
     * <code>string description = 4;</code>
     * @return The description.
     */
    java.lang.String getDescription();
    /**
     * <pre>
     * description is a short free form text describing the tree.
     * </pre>
     *
     * <code>string description = 4;</code>
     * @return The bytes for description.
     */
    com.google.protobuf.ByteString
        getDescriptionBytes();

    /**
     * <pre>
     * tree_type identifies whether this is a Log or a Map tree.
     * </pre>
     *
     * <code>.spannerpb.TreeType tree_type = 5;</code>
     * @return The enum numeric value on the wire for treeType.
     */
    int getTreeTypeValue();
    /**
     * <pre>
     * tree_type identifies whether this is a Log or a Map tree.
     * </pre>
     *
     * <code>.spannerpb.TreeType tree_type = 5;</code>
     * @return The treeType.
     */
    google.trillian.spannerpb.Spanner.TreeType getTreeType();

    /**
     * <pre>
     * tree_state is the state of the tree.
     * </pre>
     *
     * <code>.spannerpb.TreeState tree_state = 8;</code>
     * @return The enum numeric value on the wire for treeState.
     */
    int getTreeStateValue();
    /**
     * <pre>
     * tree_state is the state of the tree.
     * </pre>
     *
     * <code>.spannerpb.TreeState tree_state = 8;</code>
     * @return The treeState.
     */
    google.trillian.spannerpb.Spanner.TreeState getTreeState();

    /**
     * <pre>
     * hash_strategy is the hashing strategy used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashStrategy hash_strategy = 9;</code>
     * @return The enum numeric value on the wire for hashStrategy.
     */
    int getHashStrategyValue();
    /**
     * <pre>
     * hash_strategy is the hashing strategy used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashStrategy hash_strategy = 9;</code>
     * @return The hashStrategy.
     */
    google.trillian.spannerpb.Spanner.HashStrategy getHashStrategy();

    /**
     * <pre>
     * hash_algorithm is the hash algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashAlgorithm hash_algorithm = 10;</code>
     * @return The enum numeric value on the wire for hashAlgorithm.
     */
    int getHashAlgorithmValue();
    /**
     * <pre>
     * hash_algorithm is the hash algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashAlgorithm hash_algorithm = 10;</code>
     * @return The hashAlgorithm.
     */
    google.trillian.spannerpb.Spanner.HashAlgorithm getHashAlgorithm();

    /**
     * <pre>
     * signature_algorithm is the signature algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.SignatureAlgorithm signature_algorithm = 11;</code>
     * @return The enum numeric value on the wire for signatureAlgorithm.
     */
    int getSignatureAlgorithmValue();
    /**
     * <pre>
     * signature_algorithm is the signature algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.SignatureAlgorithm signature_algorithm = 11;</code>
     * @return The signatureAlgorithm.
     */
    google.trillian.spannerpb.Spanner.SignatureAlgorithm getSignatureAlgorithm();

    /**
     * <pre>
     * create_time_nanos is the creation timestamp of the tree, in nanos since
     * epoch.
     * </pre>
     *
     * <code>int64 create_time_nanos = 13;</code>
     * @return The createTimeNanos.
     */
    long getCreateTimeNanos();

    /**
     * <pre>
     * update_time_nanos is the last update time of the tree, in nanos since
     * epoch.
     * </pre>
     *
     * <code>int64 update_time_nanos = 14;</code>
     * @return The updateTimeNanos.
     */
    long getUpdateTimeNanos();

    /**
     * <pre>
     * private_key should be used to generate signatures for this tree.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 15;</code>
     * @return Whether the privateKey field is set.
     */
    boolean hasPrivateKey();
    /**
     * <pre>
     * private_key should be used to generate signatures for this tree.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 15;</code>
     * @return The privateKey.
     */
    com.google.protobuf.Any getPrivateKey();

    /**
     * <pre>
     * public_key_der should be used to verify signatures produced by this tree.
     * It is the key in DER-encoded PKIX form.
     * </pre>
     *
     * <code>bytes public_key_der = 16;</code>
     * @return The publicKeyDer.
     */
    com.google.protobuf.ByteString getPublicKeyDer();

    /**
     * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
     * @return Whether the logStorageConfig field is set.
     */
    boolean hasLogStorageConfig();
    /**
     * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
     * @return The logStorageConfig.
     */
    google.trillian.spannerpb.Spanner.LogStorageConfig getLogStorageConfig();

    /**
     * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
     * @return Whether the mapStorageConfig field is set.
     */
    boolean hasMapStorageConfig();
    /**
     * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
     * @return The mapStorageConfig.
     */
    google.trillian.spannerpb.Spanner.MapStorageConfig getMapStorageConfig();

    /**
     * <pre>
     * max_root_duration_millis is the interval after which a new signed root is
     * produced even if there have been no submission.  If zero, this behavior is
     * disabled.
     * </pre>
     *
     * <code>int64 max_root_duration_millis = 17;</code>
     * @return The maxRootDurationMillis.
     */
    long getMaxRootDurationMillis();

    /**
     * <pre>
     * If true the tree was soft deleted.
     * </pre>
     *
     * <code>bool deleted = 18;</code>
     * @return The deleted.
     */
    boolean getDeleted();

    /**
     * <pre>
     * Time of tree deletion, if any.
     * </pre>
     *
     * <code>int64 delete_time_nanos = 19;</code>
     * @return The deleteTimeNanos.
     */
    long getDeleteTimeNanos();

    public google.trillian.spannerpb.Spanner.TreeInfo.StorageConfigCase getStorageConfigCase();
  }
  /**
   * <pre>
   * TreeInfo stores information about a Trillian tree.
   * </pre>
   *
   * Protobuf type {@code spannerpb.TreeInfo}
   */
  public  static final class TreeInfo extends
      com.google.protobuf.GeneratedMessageLite<
          TreeInfo, TreeInfo.Builder> implements
      // @@protoc_insertion_point(message_implements:spannerpb.TreeInfo)
      TreeInfoOrBuilder {
    private TreeInfo() {
      name_ = "";
      description_ = "";
      publicKeyDer_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int storageConfigCase_ = 0;
    private java.lang.Object storageConfig_;
    public enum StorageConfigCase {
      LOG_STORAGE_CONFIG(6),
      MAP_STORAGE_CONFIG(7),
      STORAGECONFIG_NOT_SET(0);
      private final int value;
      private StorageConfigCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static StorageConfigCase valueOf(int value) {
        return forNumber(value);
      }

      public static StorageConfigCase forNumber(int value) {
        switch (value) {
          case 6: return LOG_STORAGE_CONFIG;
          case 7: return MAP_STORAGE_CONFIG;
          case 0: return STORAGECONFIG_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public StorageConfigCase
    getStorageConfigCase() {
      return StorageConfigCase.forNumber(
          storageConfigCase_);
    }

    private void clearStorageConfig() {
      storageConfigCase_ = 0;
      storageConfig_ = null;
    }

    public static final int TREE_ID_FIELD_NUMBER = 1;
    private long treeId_;
    /**
     * <pre>
     * tree_id is the ID of the tree, and is used as a primary key.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     * @return The treeId.
     */
    @java.lang.Override
    public long getTreeId() {
      return treeId_;
    }
    /**
     * <pre>
     * tree_id is the ID of the tree, and is used as a primary key.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     * @param value The treeId to set.
     */
    private void setTreeId(long value) {
      
      treeId_ = value;
    }
    /**
     * <pre>
     * tree_id is the ID of the tree, and is used as a primary key.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     */
    private void clearTreeId() {
      
      treeId_ = 0L;
    }

    public static final int KEY_ID_FIELD_NUMBER = 2;
    private long keyId_;
    /**
     * <pre>
     * key_id identifies the private key associated with this tree.
     * </pre>
     *
     * <code>int64 key_id = 2;</code>
     * @return The keyId.
     */
    @java.lang.Override
    public long getKeyId() {
      return keyId_;
    }
    /**
     * <pre>
     * key_id identifies the private key associated with this tree.
     * </pre>
     *
     * <code>int64 key_id = 2;</code>
     * @param value The keyId to set.
     */
    private void setKeyId(long value) {
      
      keyId_ = value;
    }
    /**
     * <pre>
     * key_id identifies the private key associated with this tree.
     * </pre>
     *
     * <code>int64 key_id = 2;</code>
     */
    private void clearKeyId() {
      
      keyId_ = 0L;
    }

    public static final int NAME_FIELD_NUMBER = 3;
    private java.lang.String name_;
    /**
     * <pre>
     * name is a short name for this tree.
     * </pre>
     *
     * <code>string name = 3;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return name_;
    }
    /**
     * <pre>
     * name is a short name for this tree.
     * </pre>
     *
     * <code>string name = 3;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(name_);
    }
    /**
     * <pre>
     * name is a short name for this tree.
     * </pre>
     *
     * <code>string name = 3;</code>
     * @param value The name to set.
     */
    private void setName(
        java.lang.String value) {
      value.getClass();
  
      name_ = value;
    }
    /**
     * <pre>
     * name is a short name for this tree.
     * </pre>
     *
     * <code>string name = 3;</code>
     */
    private void clearName() {
      
      name_ = getDefaultInstance().getName();
    }
    /**
     * <pre>
     * name is a short name for this tree.
     * </pre>
     *
     * <code>string name = 3;</code>
     * @param value The bytes for name to set.
     */
    private void setNameBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      name_ = value.toStringUtf8();
      
    }

    public static final int DESCRIPTION_FIELD_NUMBER = 4;
    private java.lang.String description_;
    /**
     * <pre>
     * description is a short free form text describing the tree.
     * </pre>
     *
     * <code>string description = 4;</code>
     * @return The description.
     */
    @java.lang.Override
    public java.lang.String getDescription() {
      return description_;
    }
    /**
     * <pre>
     * description is a short free form text describing the tree.
     * </pre>
     *
     * <code>string description = 4;</code>
     * @return The bytes for description.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDescriptionBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(description_);
    }
    /**
     * <pre>
     * description is a short free form text describing the tree.
     * </pre>
     *
     * <code>string description = 4;</code>
     * @param value The description to set.
     */
    private void setDescription(
        java.lang.String value) {
      value.getClass();
  
      description_ = value;
    }
    /**
     * <pre>
     * description is a short free form text describing the tree.
     * </pre>
     *
     * <code>string description = 4;</code>
     */
    private void clearDescription() {
      
      description_ = getDefaultInstance().getDescription();
    }
    /**
     * <pre>
     * description is a short free form text describing the tree.
     * </pre>
     *
     * <code>string description = 4;</code>
     * @param value The bytes for description to set.
     */
    private void setDescriptionBytes(
        com.google.protobuf.ByteString value) {
      checkByteStringIsUtf8(value);
      description_ = value.toStringUtf8();
      
    }

    public static final int TREE_TYPE_FIELD_NUMBER = 5;
    private int treeType_;
    /**
     * <pre>
     * tree_type identifies whether this is a Log or a Map tree.
     * </pre>
     *
     * <code>.spannerpb.TreeType tree_type = 5;</code>
     * @return The enum numeric value on the wire for treeType.
     */
    @java.lang.Override
    public int getTreeTypeValue() {
      return treeType_;
    }
    /**
     * <pre>
     * tree_type identifies whether this is a Log or a Map tree.
     * </pre>
     *
     * <code>.spannerpb.TreeType tree_type = 5;</code>
     * @return The treeType.
     */
    @java.lang.Override
    public google.trillian.spannerpb.Spanner.TreeType getTreeType() {
      google.trillian.spannerpb.Spanner.TreeType result = google.trillian.spannerpb.Spanner.TreeType.forNumber(treeType_);
      return result == null ? google.trillian.spannerpb.Spanner.TreeType.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * tree_type identifies whether this is a Log or a Map tree.
     * </pre>
     *
     * <code>.spannerpb.TreeType tree_type = 5;</code>
     * @param value The enum numeric value on the wire for treeType to set.
     */
    private void setTreeTypeValue(int value) {
        treeType_ = value;
    }
    /**
     * <pre>
     * tree_type identifies whether this is a Log or a Map tree.
     * </pre>
     *
     * <code>.spannerpb.TreeType tree_type = 5;</code>
     * @param value The treeType to set.
     */
    private void setTreeType(google.trillian.spannerpb.Spanner.TreeType value) {
      treeType_ = value.getNumber();
      
    }
    /**
     * <pre>
     * tree_type identifies whether this is a Log or a Map tree.
     * </pre>
     *
     * <code>.spannerpb.TreeType tree_type = 5;</code>
     */
    private void clearTreeType() {
      
      treeType_ = 0;
    }

    public static final int TREE_STATE_FIELD_NUMBER = 8;
    private int treeState_;
    /**
     * <pre>
     * tree_state is the state of the tree.
     * </pre>
     *
     * <code>.spannerpb.TreeState tree_state = 8;</code>
     * @return The enum numeric value on the wire for treeState.
     */
    @java.lang.Override
    public int getTreeStateValue() {
      return treeState_;
    }
    /**
     * <pre>
     * tree_state is the state of the tree.
     * </pre>
     *
     * <code>.spannerpb.TreeState tree_state = 8;</code>
     * @return The treeState.
     */
    @java.lang.Override
    public google.trillian.spannerpb.Spanner.TreeState getTreeState() {
      google.trillian.spannerpb.Spanner.TreeState result = google.trillian.spannerpb.Spanner.TreeState.forNumber(treeState_);
      return result == null ? google.trillian.spannerpb.Spanner.TreeState.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * tree_state is the state of the tree.
     * </pre>
     *
     * <code>.spannerpb.TreeState tree_state = 8;</code>
     * @param value The enum numeric value on the wire for treeState to set.
     */
    private void setTreeStateValue(int value) {
        treeState_ = value;
    }
    /**
     * <pre>
     * tree_state is the state of the tree.
     * </pre>
     *
     * <code>.spannerpb.TreeState tree_state = 8;</code>
     * @param value The treeState to set.
     */
    private void setTreeState(google.trillian.spannerpb.Spanner.TreeState value) {
      treeState_ = value.getNumber();
      
    }
    /**
     * <pre>
     * tree_state is the state of the tree.
     * </pre>
     *
     * <code>.spannerpb.TreeState tree_state = 8;</code>
     */
    private void clearTreeState() {
      
      treeState_ = 0;
    }

    public static final int HASH_STRATEGY_FIELD_NUMBER = 9;
    private int hashStrategy_;
    /**
     * <pre>
     * hash_strategy is the hashing strategy used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashStrategy hash_strategy = 9;</code>
     * @return The enum numeric value on the wire for hashStrategy.
     */
    @java.lang.Override
    public int getHashStrategyValue() {
      return hashStrategy_;
    }
    /**
     * <pre>
     * hash_strategy is the hashing strategy used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashStrategy hash_strategy = 9;</code>
     * @return The hashStrategy.
     */
    @java.lang.Override
    public google.trillian.spannerpb.Spanner.HashStrategy getHashStrategy() {
      google.trillian.spannerpb.Spanner.HashStrategy result = google.trillian.spannerpb.Spanner.HashStrategy.forNumber(hashStrategy_);
      return result == null ? google.trillian.spannerpb.Spanner.HashStrategy.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * hash_strategy is the hashing strategy used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashStrategy hash_strategy = 9;</code>
     * @param value The enum numeric value on the wire for hashStrategy to set.
     */
    private void setHashStrategyValue(int value) {
        hashStrategy_ = value;
    }
    /**
     * <pre>
     * hash_strategy is the hashing strategy used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashStrategy hash_strategy = 9;</code>
     * @param value The hashStrategy to set.
     */
    private void setHashStrategy(google.trillian.spannerpb.Spanner.HashStrategy value) {
      hashStrategy_ = value.getNumber();
      
    }
    /**
     * <pre>
     * hash_strategy is the hashing strategy used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashStrategy hash_strategy = 9;</code>
     */
    private void clearHashStrategy() {
      
      hashStrategy_ = 0;
    }

    public static final int HASH_ALGORITHM_FIELD_NUMBER = 10;
    private int hashAlgorithm_;
    /**
     * <pre>
     * hash_algorithm is the hash algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashAlgorithm hash_algorithm = 10;</code>
     * @return The enum numeric value on the wire for hashAlgorithm.
     */
    @java.lang.Override
    public int getHashAlgorithmValue() {
      return hashAlgorithm_;
    }
    /**
     * <pre>
     * hash_algorithm is the hash algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashAlgorithm hash_algorithm = 10;</code>
     * @return The hashAlgorithm.
     */
    @java.lang.Override
    public google.trillian.spannerpb.Spanner.HashAlgorithm getHashAlgorithm() {
      google.trillian.spannerpb.Spanner.HashAlgorithm result = google.trillian.spannerpb.Spanner.HashAlgorithm.forNumber(hashAlgorithm_);
      return result == null ? google.trillian.spannerpb.Spanner.HashAlgorithm.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * hash_algorithm is the hash algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashAlgorithm hash_algorithm = 10;</code>
     * @param value The enum numeric value on the wire for hashAlgorithm to set.
     */
    private void setHashAlgorithmValue(int value) {
        hashAlgorithm_ = value;
    }
    /**
     * <pre>
     * hash_algorithm is the hash algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashAlgorithm hash_algorithm = 10;</code>
     * @param value The hashAlgorithm to set.
     */
    private void setHashAlgorithm(google.trillian.spannerpb.Spanner.HashAlgorithm value) {
      hashAlgorithm_ = value.getNumber();
      
    }
    /**
     * <pre>
     * hash_algorithm is the hash algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.HashAlgorithm hash_algorithm = 10;</code>
     */
    private void clearHashAlgorithm() {
      
      hashAlgorithm_ = 0;
    }

    public static final int SIGNATURE_ALGORITHM_FIELD_NUMBER = 11;
    private int signatureAlgorithm_;
    /**
     * <pre>
     * signature_algorithm is the signature algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.SignatureAlgorithm signature_algorithm = 11;</code>
     * @return The enum numeric value on the wire for signatureAlgorithm.
     */
    @java.lang.Override
    public int getSignatureAlgorithmValue() {
      return signatureAlgorithm_;
    }
    /**
     * <pre>
     * signature_algorithm is the signature algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.SignatureAlgorithm signature_algorithm = 11;</code>
     * @return The signatureAlgorithm.
     */
    @java.lang.Override
    public google.trillian.spannerpb.Spanner.SignatureAlgorithm getSignatureAlgorithm() {
      google.trillian.spannerpb.Spanner.SignatureAlgorithm result = google.trillian.spannerpb.Spanner.SignatureAlgorithm.forNumber(signatureAlgorithm_);
      return result == null ? google.trillian.spannerpb.Spanner.SignatureAlgorithm.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * signature_algorithm is the signature algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.SignatureAlgorithm signature_algorithm = 11;</code>
     * @param value The enum numeric value on the wire for signatureAlgorithm to set.
     */
    private void setSignatureAlgorithmValue(int value) {
        signatureAlgorithm_ = value;
    }
    /**
     * <pre>
     * signature_algorithm is the signature algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.SignatureAlgorithm signature_algorithm = 11;</code>
     * @param value The signatureAlgorithm to set.
     */
    private void setSignatureAlgorithm(google.trillian.spannerpb.Spanner.SignatureAlgorithm value) {
      signatureAlgorithm_ = value.getNumber();
      
    }
    /**
     * <pre>
     * signature_algorithm is the signature algorithm used by the tree.
     * </pre>
     *
     * <code>.spannerpb.SignatureAlgorithm signature_algorithm = 11;</code>
     */
    private void clearSignatureAlgorithm() {
      
      signatureAlgorithm_ = 0;
    }

    public static final int CREATE_TIME_NANOS_FIELD_NUMBER = 13;
    private long createTimeNanos_;
    /**
     * <pre>
     * create_time_nanos is the creation timestamp of the tree, in nanos since
     * epoch.
     * </pre>
     *
     * <code>int64 create_time_nanos = 13;</code>
     * @return The createTimeNanos.
     */
    @java.lang.Override
    public long getCreateTimeNanos() {
      return createTimeNanos_;
    }
    /**
     * <pre>
     * create_time_nanos is the creation timestamp of the tree, in nanos since
     * epoch.
     * </pre>
     *
     * <code>int64 create_time_nanos = 13;</code>
     * @param value The createTimeNanos to set.
     */
    private void setCreateTimeNanos(long value) {
      
      createTimeNanos_ = value;
    }
    /**
     * <pre>
     * create_time_nanos is the creation timestamp of the tree, in nanos since
     * epoch.
     * </pre>
     *
     * <code>int64 create_time_nanos = 13;</code>
     */
    private void clearCreateTimeNanos() {
      
      createTimeNanos_ = 0L;
    }

    public static final int UPDATE_TIME_NANOS_FIELD_NUMBER = 14;
    private long updateTimeNanos_;
    /**
     * <pre>
     * update_time_nanos is the last update time of the tree, in nanos since
     * epoch.
     * </pre>
     *
     * <code>int64 update_time_nanos = 14;</code>
     * @return The updateTimeNanos.
     */
    @java.lang.Override
    public long getUpdateTimeNanos() {
      return updateTimeNanos_;
    }
    /**
     * <pre>
     * update_time_nanos is the last update time of the tree, in nanos since
     * epoch.
     * </pre>
     *
     * <code>int64 update_time_nanos = 14;</code>
     * @param value The updateTimeNanos to set.
     */
    private void setUpdateTimeNanos(long value) {
      
      updateTimeNanos_ = value;
    }
    /**
     * <pre>
     * update_time_nanos is the last update time of the tree, in nanos since
     * epoch.
     * </pre>
     *
     * <code>int64 update_time_nanos = 14;</code>
     */
    private void clearUpdateTimeNanos() {
      
      updateTimeNanos_ = 0L;
    }

    public static final int PRIVATE_KEY_FIELD_NUMBER = 15;
    private com.google.protobuf.Any privateKey_;
    /**
     * <pre>
     * private_key should be used to generate signatures for this tree.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 15;</code>
     */
    @java.lang.Override
    public boolean hasPrivateKey() {
      return privateKey_ != null;
    }
    /**
     * <pre>
     * private_key should be used to generate signatures for this tree.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 15;</code>
     */
    @java.lang.Override
    public com.google.protobuf.Any getPrivateKey() {
      return privateKey_ == null ? com.google.protobuf.Any.getDefaultInstance() : privateKey_;
    }
    /**
     * <pre>
     * private_key should be used to generate signatures for this tree.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 15;</code>
     */
    private void setPrivateKey(com.google.protobuf.Any value) {
      value.getClass();
  privateKey_ = value;
      
      }
    /**
     * <pre>
     * private_key should be used to generate signatures for this tree.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 15;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergePrivateKey(com.google.protobuf.Any value) {
      value.getClass();
  if (privateKey_ != null &&
          privateKey_ != com.google.protobuf.Any.getDefaultInstance()) {
        privateKey_ =
          com.google.protobuf.Any.newBuilder(privateKey_).mergeFrom(value).buildPartial();
      } else {
        privateKey_ = value;
      }
      
    }
    /**
     * <pre>
     * private_key should be used to generate signatures for this tree.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 15;</code>
     */
    private void clearPrivateKey() {  privateKey_ = null;
      
    }

    public static final int PUBLIC_KEY_DER_FIELD_NUMBER = 16;
    private com.google.protobuf.ByteString publicKeyDer_;
    /**
     * <pre>
     * public_key_der should be used to verify signatures produced by this tree.
     * It is the key in DER-encoded PKIX form.
     * </pre>
     *
     * <code>bytes public_key_der = 16;</code>
     * @return The publicKeyDer.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPublicKeyDer() {
      return publicKeyDer_;
    }
    /**
     * <pre>
     * public_key_der should be used to verify signatures produced by this tree.
     * It is the key in DER-encoded PKIX form.
     * </pre>
     *
     * <code>bytes public_key_der = 16;</code>
     * @param value The publicKeyDer to set.
     */
    private void setPublicKeyDer(com.google.protobuf.ByteString value) {
      value.getClass();
  
      publicKeyDer_ = value;
    }
    /**
     * <pre>
     * public_key_der should be used to verify signatures produced by this tree.
     * It is the key in DER-encoded PKIX form.
     * </pre>
     *
     * <code>bytes public_key_der = 16;</code>
     */
    private void clearPublicKeyDer() {
      
      publicKeyDer_ = getDefaultInstance().getPublicKeyDer();
    }

    public static final int LOG_STORAGE_CONFIG_FIELD_NUMBER = 6;
    /**
     * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
     */
    @java.lang.Override
    public boolean hasLogStorageConfig() {
      return storageConfigCase_ == 6;
    }
    /**
     * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
     */
    @java.lang.Override
    public google.trillian.spannerpb.Spanner.LogStorageConfig getLogStorageConfig() {
      if (storageConfigCase_ == 6) {
         return (google.trillian.spannerpb.Spanner.LogStorageConfig) storageConfig_;
      }
      return google.trillian.spannerpb.Spanner.LogStorageConfig.getDefaultInstance();
    }
    /**
     * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
     */
    private void setLogStorageConfig(google.trillian.spannerpb.Spanner.LogStorageConfig value) {
      value.getClass();
  storageConfig_ = value;
      storageConfigCase_ = 6;
    }
    /**
     * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
     */
    private void mergeLogStorageConfig(google.trillian.spannerpb.Spanner.LogStorageConfig value) {
      value.getClass();
  if (storageConfigCase_ == 6 &&
          storageConfig_ != google.trillian.spannerpb.Spanner.LogStorageConfig.getDefaultInstance()) {
        storageConfig_ = google.trillian.spannerpb.Spanner.LogStorageConfig.newBuilder((google.trillian.spannerpb.Spanner.LogStorageConfig) storageConfig_)
            .mergeFrom(value).buildPartial();
      } else {
        storageConfig_ = value;
      }
      storageConfigCase_ = 6;
    }
    /**
     * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
     */
    private void clearLogStorageConfig() {
      if (storageConfigCase_ == 6) {
        storageConfigCase_ = 0;
        storageConfig_ = null;
      }
    }

    public static final int MAP_STORAGE_CONFIG_FIELD_NUMBER = 7;
    /**
     * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
     */
    @java.lang.Override
    public boolean hasMapStorageConfig() {
      return storageConfigCase_ == 7;
    }
    /**
     * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
     */
    @java.lang.Override
    public google.trillian.spannerpb.Spanner.MapStorageConfig getMapStorageConfig() {
      if (storageConfigCase_ == 7) {
         return (google.trillian.spannerpb.Spanner.MapStorageConfig) storageConfig_;
      }
      return google.trillian.spannerpb.Spanner.MapStorageConfig.getDefaultInstance();
    }
    /**
     * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
     */
    private void setMapStorageConfig(google.trillian.spannerpb.Spanner.MapStorageConfig value) {
      value.getClass();
  storageConfig_ = value;
      storageConfigCase_ = 7;
    }
    /**
     * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
     */
    private void mergeMapStorageConfig(google.trillian.spannerpb.Spanner.MapStorageConfig value) {
      value.getClass();
  if (storageConfigCase_ == 7 &&
          storageConfig_ != google.trillian.spannerpb.Spanner.MapStorageConfig.getDefaultInstance()) {
        storageConfig_ = google.trillian.spannerpb.Spanner.MapStorageConfig.newBuilder((google.trillian.spannerpb.Spanner.MapStorageConfig) storageConfig_)
            .mergeFrom(value).buildPartial();
      } else {
        storageConfig_ = value;
      }
      storageConfigCase_ = 7;
    }
    /**
     * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
     */
    private void clearMapStorageConfig() {
      if (storageConfigCase_ == 7) {
        storageConfigCase_ = 0;
        storageConfig_ = null;
      }
    }

    public static final int MAX_ROOT_DURATION_MILLIS_FIELD_NUMBER = 17;
    private long maxRootDurationMillis_;
    /**
     * <pre>
     * max_root_duration_millis is the interval after which a new signed root is
     * produced even if there have been no submission.  If zero, this behavior is
     * disabled.
     * </pre>
     *
     * <code>int64 max_root_duration_millis = 17;</code>
     * @return The maxRootDurationMillis.
     */
    @java.lang.Override
    public long getMaxRootDurationMillis() {
      return maxRootDurationMillis_;
    }
    /**
     * <pre>
     * max_root_duration_millis is the interval after which a new signed root is
     * produced even if there have been no submission.  If zero, this behavior is
     * disabled.
     * </pre>
     *
     * <code>int64 max_root_duration_millis = 17;</code>
     * @param value The maxRootDurationMillis to set.
     */
    private void setMaxRootDurationMillis(long value) {
      
      maxRootDurationMillis_ = value;
    }
    /**
     * <pre>
     * max_root_duration_millis is the interval after which a new signed root is
     * produced even if there have been no submission.  If zero, this behavior is
     * disabled.
     * </pre>
     *
     * <code>int64 max_root_duration_millis = 17;</code>
     */
    private void clearMaxRootDurationMillis() {
      
      maxRootDurationMillis_ = 0L;
    }

    public static final int DELETED_FIELD_NUMBER = 18;
    private boolean deleted_;
    /**
     * <pre>
     * If true the tree was soft deleted.
     * </pre>
     *
     * <code>bool deleted = 18;</code>
     * @return The deleted.
     */
    @java.lang.Override
    public boolean getDeleted() {
      return deleted_;
    }
    /**
     * <pre>
     * If true the tree was soft deleted.
     * </pre>
     *
     * <code>bool deleted = 18;</code>
     * @param value The deleted to set.
     */
    private void setDeleted(boolean value) {
      
      deleted_ = value;
    }
    /**
     * <pre>
     * If true the tree was soft deleted.
     * </pre>
     *
     * <code>bool deleted = 18;</code>
     */
    private void clearDeleted() {
      
      deleted_ = false;
    }

    public static final int DELETE_TIME_NANOS_FIELD_NUMBER = 19;
    private long deleteTimeNanos_;
    /**
     * <pre>
     * Time of tree deletion, if any.
     * </pre>
     *
     * <code>int64 delete_time_nanos = 19;</code>
     * @return The deleteTimeNanos.
     */
    @java.lang.Override
    public long getDeleteTimeNanos() {
      return deleteTimeNanos_;
    }
    /**
     * <pre>
     * Time of tree deletion, if any.
     * </pre>
     *
     * <code>int64 delete_time_nanos = 19;</code>
     * @param value The deleteTimeNanos to set.
     */
    private void setDeleteTimeNanos(long value) {
      
      deleteTimeNanos_ = value;
    }
    /**
     * <pre>
     * Time of tree deletion, if any.
     * </pre>
     *
     * <code>int64 delete_time_nanos = 19;</code>
     */
    private void clearDeleteTimeNanos() {
      
      deleteTimeNanos_ = 0L;
    }

    public static google.trillian.spannerpb.Spanner.TreeInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.spannerpb.Spanner.TreeInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.TreeInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.spannerpb.Spanner.TreeInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.TreeInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.spannerpb.Spanner.TreeInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.TreeInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.spannerpb.Spanner.TreeInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.TreeInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.trillian.spannerpb.Spanner.TreeInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.TreeInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.spannerpb.Spanner.TreeInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.trillian.spannerpb.Spanner.TreeInfo prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * TreeInfo stores information about a Trillian tree.
     * </pre>
     *
     * Protobuf type {@code spannerpb.TreeInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.trillian.spannerpb.Spanner.TreeInfo, Builder> implements
        // @@protoc_insertion_point(builder_implements:spannerpb.TreeInfo)
        google.trillian.spannerpb.Spanner.TreeInfoOrBuilder {
      // Construct using google.trillian.spannerpb.Spanner.TreeInfo.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public StorageConfigCase
          getStorageConfigCase() {
        return instance.getStorageConfigCase();
      }

      public Builder clearStorageConfig() {
        copyOnWrite();
        instance.clearStorageConfig();
        return this;
      }


      /**
       * <pre>
       * tree_id is the ID of the tree, and is used as a primary key.
       * </pre>
       *
       * <code>int64 tree_id = 1;</code>
       * @return The treeId.
       */
      @java.lang.Override
      public long getTreeId() {
        return instance.getTreeId();
      }
      /**
       * <pre>
       * tree_id is the ID of the tree, and is used as a primary key.
       * </pre>
       *
       * <code>int64 tree_id = 1;</code>
       * @param value The treeId to set.
       * @return This builder for chaining.
       */
      public Builder setTreeId(long value) {
        copyOnWrite();
        instance.setTreeId(value);
        return this;
      }
      /**
       * <pre>
       * tree_id is the ID of the tree, and is used as a primary key.
       * </pre>
       *
       * <code>int64 tree_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTreeId() {
        copyOnWrite();
        instance.clearTreeId();
        return this;
      }

      /**
       * <pre>
       * key_id identifies the private key associated with this tree.
       * </pre>
       *
       * <code>int64 key_id = 2;</code>
       * @return The keyId.
       */
      @java.lang.Override
      public long getKeyId() {
        return instance.getKeyId();
      }
      /**
       * <pre>
       * key_id identifies the private key associated with this tree.
       * </pre>
       *
       * <code>int64 key_id = 2;</code>
       * @param value The keyId to set.
       * @return This builder for chaining.
       */
      public Builder setKeyId(long value) {
        copyOnWrite();
        instance.setKeyId(value);
        return this;
      }
      /**
       * <pre>
       * key_id identifies the private key associated with this tree.
       * </pre>
       *
       * <code>int64 key_id = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeyId() {
        copyOnWrite();
        instance.clearKeyId();
        return this;
      }

      /**
       * <pre>
       * name is a short name for this tree.
       * </pre>
       *
       * <code>string name = 3;</code>
       * @return The name.
       */
      @java.lang.Override
      public java.lang.String getName() {
        return instance.getName();
      }
      /**
       * <pre>
       * name is a short name for this tree.
       * </pre>
       *
       * <code>string name = 3;</code>
       * @return The bytes for name.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNameBytes() {
        return instance.getNameBytes();
      }
      /**
       * <pre>
       * name is a short name for this tree.
       * </pre>
       *
       * <code>string name = 3;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <pre>
       * name is a short name for this tree.
       * </pre>
       *
       * <code>string name = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }
      /**
       * <pre>
       * name is a short name for this tree.
       * </pre>
       *
       * <code>string name = 3;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNameBytes(value);
        return this;
      }

      /**
       * <pre>
       * description is a short free form text describing the tree.
       * </pre>
       *
       * <code>string description = 4;</code>
       * @return The description.
       */
      @java.lang.Override
      public java.lang.String getDescription() {
        return instance.getDescription();
      }
      /**
       * <pre>
       * description is a short free form text describing the tree.
       * </pre>
       *
       * <code>string description = 4;</code>
       * @return The bytes for description.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDescriptionBytes() {
        return instance.getDescriptionBytes();
      }
      /**
       * <pre>
       * description is a short free form text describing the tree.
       * </pre>
       *
       * <code>string description = 4;</code>
       * @param value The description to set.
       * @return This builder for chaining.
       */
      public Builder setDescription(
          java.lang.String value) {
        copyOnWrite();
        instance.setDescription(value);
        return this;
      }
      /**
       * <pre>
       * description is a short free form text describing the tree.
       * </pre>
       *
       * <code>string description = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearDescription() {
        copyOnWrite();
        instance.clearDescription();
        return this;
      }
      /**
       * <pre>
       * description is a short free form text describing the tree.
       * </pre>
       *
       * <code>string description = 4;</code>
       * @param value The bytes for description to set.
       * @return This builder for chaining.
       */
      public Builder setDescriptionBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDescriptionBytes(value);
        return this;
      }

      /**
       * <pre>
       * tree_type identifies whether this is a Log or a Map tree.
       * </pre>
       *
       * <code>.spannerpb.TreeType tree_type = 5;</code>
       * @return The enum numeric value on the wire for treeType.
       */
      @java.lang.Override
      public int getTreeTypeValue() {
        return instance.getTreeTypeValue();
      }
      /**
       * <pre>
       * tree_type identifies whether this is a Log or a Map tree.
       * </pre>
       *
       * <code>.spannerpb.TreeType tree_type = 5;</code>
       * @param value The treeType to set.
       * @return This builder for chaining.
       */
      public Builder setTreeTypeValue(int value) {
        copyOnWrite();
        instance.setTreeTypeValue(value);
        return this;
      }
      /**
       * <pre>
       * tree_type identifies whether this is a Log or a Map tree.
       * </pre>
       *
       * <code>.spannerpb.TreeType tree_type = 5;</code>
       * @return The treeType.
       */
      @java.lang.Override
      public google.trillian.spannerpb.Spanner.TreeType getTreeType() {
        return instance.getTreeType();
      }
      /**
       * <pre>
       * tree_type identifies whether this is a Log or a Map tree.
       * </pre>
       *
       * <code>.spannerpb.TreeType tree_type = 5;</code>
       * @param value The enum numeric value on the wire for treeType to set.
       * @return This builder for chaining.
       */
      public Builder setTreeType(google.trillian.spannerpb.Spanner.TreeType value) {
        copyOnWrite();
        instance.setTreeType(value);
        return this;
      }
      /**
       * <pre>
       * tree_type identifies whether this is a Log or a Map tree.
       * </pre>
       *
       * <code>.spannerpb.TreeType tree_type = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearTreeType() {
        copyOnWrite();
        instance.clearTreeType();
        return this;
      }

      /**
       * <pre>
       * tree_state is the state of the tree.
       * </pre>
       *
       * <code>.spannerpb.TreeState tree_state = 8;</code>
       * @return The enum numeric value on the wire for treeState.
       */
      @java.lang.Override
      public int getTreeStateValue() {
        return instance.getTreeStateValue();
      }
      /**
       * <pre>
       * tree_state is the state of the tree.
       * </pre>
       *
       * <code>.spannerpb.TreeState tree_state = 8;</code>
       * @param value The treeState to set.
       * @return This builder for chaining.
       */
      public Builder setTreeStateValue(int value) {
        copyOnWrite();
        instance.setTreeStateValue(value);
        return this;
      }
      /**
       * <pre>
       * tree_state is the state of the tree.
       * </pre>
       *
       * <code>.spannerpb.TreeState tree_state = 8;</code>
       * @return The treeState.
       */
      @java.lang.Override
      public google.trillian.spannerpb.Spanner.TreeState getTreeState() {
        return instance.getTreeState();
      }
      /**
       * <pre>
       * tree_state is the state of the tree.
       * </pre>
       *
       * <code>.spannerpb.TreeState tree_state = 8;</code>
       * @param value The enum numeric value on the wire for treeState to set.
       * @return This builder for chaining.
       */
      public Builder setTreeState(google.trillian.spannerpb.Spanner.TreeState value) {
        copyOnWrite();
        instance.setTreeState(value);
        return this;
      }
      /**
       * <pre>
       * tree_state is the state of the tree.
       * </pre>
       *
       * <code>.spannerpb.TreeState tree_state = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearTreeState() {
        copyOnWrite();
        instance.clearTreeState();
        return this;
      }

      /**
       * <pre>
       * hash_strategy is the hashing strategy used by the tree.
       * </pre>
       *
       * <code>.spannerpb.HashStrategy hash_strategy = 9;</code>
       * @return The enum numeric value on the wire for hashStrategy.
       */
      @java.lang.Override
      public int getHashStrategyValue() {
        return instance.getHashStrategyValue();
      }
      /**
       * <pre>
       * hash_strategy is the hashing strategy used by the tree.
       * </pre>
       *
       * <code>.spannerpb.HashStrategy hash_strategy = 9;</code>
       * @param value The hashStrategy to set.
       * @return This builder for chaining.
       */
      public Builder setHashStrategyValue(int value) {
        copyOnWrite();
        instance.setHashStrategyValue(value);
        return this;
      }
      /**
       * <pre>
       * hash_strategy is the hashing strategy used by the tree.
       * </pre>
       *
       * <code>.spannerpb.HashStrategy hash_strategy = 9;</code>
       * @return The hashStrategy.
       */
      @java.lang.Override
      public google.trillian.spannerpb.Spanner.HashStrategy getHashStrategy() {
        return instance.getHashStrategy();
      }
      /**
       * <pre>
       * hash_strategy is the hashing strategy used by the tree.
       * </pre>
       *
       * <code>.spannerpb.HashStrategy hash_strategy = 9;</code>
       * @param value The enum numeric value on the wire for hashStrategy to set.
       * @return This builder for chaining.
       */
      public Builder setHashStrategy(google.trillian.spannerpb.Spanner.HashStrategy value) {
        copyOnWrite();
        instance.setHashStrategy(value);
        return this;
      }
      /**
       * <pre>
       * hash_strategy is the hashing strategy used by the tree.
       * </pre>
       *
       * <code>.spannerpb.HashStrategy hash_strategy = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearHashStrategy() {
        copyOnWrite();
        instance.clearHashStrategy();
        return this;
      }

      /**
       * <pre>
       * hash_algorithm is the hash algorithm used by the tree.
       * </pre>
       *
       * <code>.spannerpb.HashAlgorithm hash_algorithm = 10;</code>
       * @return The enum numeric value on the wire for hashAlgorithm.
       */
      @java.lang.Override
      public int getHashAlgorithmValue() {
        return instance.getHashAlgorithmValue();
      }
      /**
       * <pre>
       * hash_algorithm is the hash algorithm used by the tree.
       * </pre>
       *
       * <code>.spannerpb.HashAlgorithm hash_algorithm = 10;</code>
       * @param value The hashAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setHashAlgorithmValue(int value) {
        copyOnWrite();
        instance.setHashAlgorithmValue(value);
        return this;
      }
      /**
       * <pre>
       * hash_algorithm is the hash algorithm used by the tree.
       * </pre>
       *
       * <code>.spannerpb.HashAlgorithm hash_algorithm = 10;</code>
       * @return The hashAlgorithm.
       */
      @java.lang.Override
      public google.trillian.spannerpb.Spanner.HashAlgorithm getHashAlgorithm() {
        return instance.getHashAlgorithm();
      }
      /**
       * <pre>
       * hash_algorithm is the hash algorithm used by the tree.
       * </pre>
       *
       * <code>.spannerpb.HashAlgorithm hash_algorithm = 10;</code>
       * @param value The enum numeric value on the wire for hashAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setHashAlgorithm(google.trillian.spannerpb.Spanner.HashAlgorithm value) {
        copyOnWrite();
        instance.setHashAlgorithm(value);
        return this;
      }
      /**
       * <pre>
       * hash_algorithm is the hash algorithm used by the tree.
       * </pre>
       *
       * <code>.spannerpb.HashAlgorithm hash_algorithm = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearHashAlgorithm() {
        copyOnWrite();
        instance.clearHashAlgorithm();
        return this;
      }

      /**
       * <pre>
       * signature_algorithm is the signature algorithm used by the tree.
       * </pre>
       *
       * <code>.spannerpb.SignatureAlgorithm signature_algorithm = 11;</code>
       * @return The enum numeric value on the wire for signatureAlgorithm.
       */
      @java.lang.Override
      public int getSignatureAlgorithmValue() {
        return instance.getSignatureAlgorithmValue();
      }
      /**
       * <pre>
       * signature_algorithm is the signature algorithm used by the tree.
       * </pre>
       *
       * <code>.spannerpb.SignatureAlgorithm signature_algorithm = 11;</code>
       * @param value The signatureAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setSignatureAlgorithmValue(int value) {
        copyOnWrite();
        instance.setSignatureAlgorithmValue(value);
        return this;
      }
      /**
       * <pre>
       * signature_algorithm is the signature algorithm used by the tree.
       * </pre>
       *
       * <code>.spannerpb.SignatureAlgorithm signature_algorithm = 11;</code>
       * @return The signatureAlgorithm.
       */
      @java.lang.Override
      public google.trillian.spannerpb.Spanner.SignatureAlgorithm getSignatureAlgorithm() {
        return instance.getSignatureAlgorithm();
      }
      /**
       * <pre>
       * signature_algorithm is the signature algorithm used by the tree.
       * </pre>
       *
       * <code>.spannerpb.SignatureAlgorithm signature_algorithm = 11;</code>
       * @param value The enum numeric value on the wire for signatureAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setSignatureAlgorithm(google.trillian.spannerpb.Spanner.SignatureAlgorithm value) {
        copyOnWrite();
        instance.setSignatureAlgorithm(value);
        return this;
      }
      /**
       * <pre>
       * signature_algorithm is the signature algorithm used by the tree.
       * </pre>
       *
       * <code>.spannerpb.SignatureAlgorithm signature_algorithm = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignatureAlgorithm() {
        copyOnWrite();
        instance.clearSignatureAlgorithm();
        return this;
      }

      /**
       * <pre>
       * create_time_nanos is the creation timestamp of the tree, in nanos since
       * epoch.
       * </pre>
       *
       * <code>int64 create_time_nanos = 13;</code>
       * @return The createTimeNanos.
       */
      @java.lang.Override
      public long getCreateTimeNanos() {
        return instance.getCreateTimeNanos();
      }
      /**
       * <pre>
       * create_time_nanos is the creation timestamp of the tree, in nanos since
       * epoch.
       * </pre>
       *
       * <code>int64 create_time_nanos = 13;</code>
       * @param value The createTimeNanos to set.
       * @return This builder for chaining.
       */
      public Builder setCreateTimeNanos(long value) {
        copyOnWrite();
        instance.setCreateTimeNanos(value);
        return this;
      }
      /**
       * <pre>
       * create_time_nanos is the creation timestamp of the tree, in nanos since
       * epoch.
       * </pre>
       *
       * <code>int64 create_time_nanos = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearCreateTimeNanos() {
        copyOnWrite();
        instance.clearCreateTimeNanos();
        return this;
      }

      /**
       * <pre>
       * update_time_nanos is the last update time of the tree, in nanos since
       * epoch.
       * </pre>
       *
       * <code>int64 update_time_nanos = 14;</code>
       * @return The updateTimeNanos.
       */
      @java.lang.Override
      public long getUpdateTimeNanos() {
        return instance.getUpdateTimeNanos();
      }
      /**
       * <pre>
       * update_time_nanos is the last update time of the tree, in nanos since
       * epoch.
       * </pre>
       *
       * <code>int64 update_time_nanos = 14;</code>
       * @param value The updateTimeNanos to set.
       * @return This builder for chaining.
       */
      public Builder setUpdateTimeNanos(long value) {
        copyOnWrite();
        instance.setUpdateTimeNanos(value);
        return this;
      }
      /**
       * <pre>
       * update_time_nanos is the last update time of the tree, in nanos since
       * epoch.
       * </pre>
       *
       * <code>int64 update_time_nanos = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearUpdateTimeNanos() {
        copyOnWrite();
        instance.clearUpdateTimeNanos();
        return this;
      }

      /**
       * <pre>
       * private_key should be used to generate signatures for this tree.
       * </pre>
       *
       * <code>.google.protobuf.Any private_key = 15;</code>
       */
      @java.lang.Override
      public boolean hasPrivateKey() {
        return instance.hasPrivateKey();
      }
      /**
       * <pre>
       * private_key should be used to generate signatures for this tree.
       * </pre>
       *
       * <code>.google.protobuf.Any private_key = 15;</code>
       */
      @java.lang.Override
      public com.google.protobuf.Any getPrivateKey() {
        return instance.getPrivateKey();
      }
      /**
       * <pre>
       * private_key should be used to generate signatures for this tree.
       * </pre>
       *
       * <code>.google.protobuf.Any private_key = 15;</code>
       */
      public Builder setPrivateKey(com.google.protobuf.Any value) {
        copyOnWrite();
        instance.setPrivateKey(value);
        return this;
        }
      /**
       * <pre>
       * private_key should be used to generate signatures for this tree.
       * </pre>
       *
       * <code>.google.protobuf.Any private_key = 15;</code>
       */
      public Builder setPrivateKey(
          com.google.protobuf.Any.Builder builderForValue) {
        copyOnWrite();
        instance.setPrivateKey(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * private_key should be used to generate signatures for this tree.
       * </pre>
       *
       * <code>.google.protobuf.Any private_key = 15;</code>
       */
      public Builder mergePrivateKey(com.google.protobuf.Any value) {
        copyOnWrite();
        instance.mergePrivateKey(value);
        return this;
      }
      /**
       * <pre>
       * private_key should be used to generate signatures for this tree.
       * </pre>
       *
       * <code>.google.protobuf.Any private_key = 15;</code>
       */
      public Builder clearPrivateKey() {  copyOnWrite();
        instance.clearPrivateKey();
        return this;
      }

      /**
       * <pre>
       * public_key_der should be used to verify signatures produced by this tree.
       * It is the key in DER-encoded PKIX form.
       * </pre>
       *
       * <code>bytes public_key_der = 16;</code>
       * @return The publicKeyDer.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPublicKeyDer() {
        return instance.getPublicKeyDer();
      }
      /**
       * <pre>
       * public_key_der should be used to verify signatures produced by this tree.
       * It is the key in DER-encoded PKIX form.
       * </pre>
       *
       * <code>bytes public_key_der = 16;</code>
       * @param value The publicKeyDer to set.
       * @return This builder for chaining.
       */
      public Builder setPublicKeyDer(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPublicKeyDer(value);
        return this;
      }
      /**
       * <pre>
       * public_key_der should be used to verify signatures produced by this tree.
       * It is the key in DER-encoded PKIX form.
       * </pre>
       *
       * <code>bytes public_key_der = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearPublicKeyDer() {
        copyOnWrite();
        instance.clearPublicKeyDer();
        return this;
      }

      /**
       * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
       */
      @java.lang.Override
      public boolean hasLogStorageConfig() {
        return instance.hasLogStorageConfig();
      }
      /**
       * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
       */
      @java.lang.Override
      public google.trillian.spannerpb.Spanner.LogStorageConfig getLogStorageConfig() {
        return instance.getLogStorageConfig();
      }
      /**
       * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
       */
      public Builder setLogStorageConfig(google.trillian.spannerpb.Spanner.LogStorageConfig value) {
        copyOnWrite();
        instance.setLogStorageConfig(value);
        return this;
      }
      /**
       * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
       */
      public Builder setLogStorageConfig(
          google.trillian.spannerpb.Spanner.LogStorageConfig.Builder builderForValue) {
        copyOnWrite();
        instance.setLogStorageConfig(builderForValue.build());
        return this;
      }
      /**
       * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
       */
      public Builder mergeLogStorageConfig(google.trillian.spannerpb.Spanner.LogStorageConfig value) {
        copyOnWrite();
        instance.mergeLogStorageConfig(value);
        return this;
      }
      /**
       * <code>.spannerpb.LogStorageConfig log_storage_config = 6;</code>
       */
      public Builder clearLogStorageConfig() {
        copyOnWrite();
        instance.clearLogStorageConfig();
        return this;
      }

      /**
       * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
       */
      @java.lang.Override
      public boolean hasMapStorageConfig() {
        return instance.hasMapStorageConfig();
      }
      /**
       * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
       */
      @java.lang.Override
      public google.trillian.spannerpb.Spanner.MapStorageConfig getMapStorageConfig() {
        return instance.getMapStorageConfig();
      }
      /**
       * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
       */
      public Builder setMapStorageConfig(google.trillian.spannerpb.Spanner.MapStorageConfig value) {
        copyOnWrite();
        instance.setMapStorageConfig(value);
        return this;
      }
      /**
       * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
       */
      public Builder setMapStorageConfig(
          google.trillian.spannerpb.Spanner.MapStorageConfig.Builder builderForValue) {
        copyOnWrite();
        instance.setMapStorageConfig(builderForValue.build());
        return this;
      }
      /**
       * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
       */
      public Builder mergeMapStorageConfig(google.trillian.spannerpb.Spanner.MapStorageConfig value) {
        copyOnWrite();
        instance.mergeMapStorageConfig(value);
        return this;
      }
      /**
       * <code>.spannerpb.MapStorageConfig map_storage_config = 7;</code>
       */
      public Builder clearMapStorageConfig() {
        copyOnWrite();
        instance.clearMapStorageConfig();
        return this;
      }

      /**
       * <pre>
       * max_root_duration_millis is the interval after which a new signed root is
       * produced even if there have been no submission.  If zero, this behavior is
       * disabled.
       * </pre>
       *
       * <code>int64 max_root_duration_millis = 17;</code>
       * @return The maxRootDurationMillis.
       */
      @java.lang.Override
      public long getMaxRootDurationMillis() {
        return instance.getMaxRootDurationMillis();
      }
      /**
       * <pre>
       * max_root_duration_millis is the interval after which a new signed root is
       * produced even if there have been no submission.  If zero, this behavior is
       * disabled.
       * </pre>
       *
       * <code>int64 max_root_duration_millis = 17;</code>
       * @param value The maxRootDurationMillis to set.
       * @return This builder for chaining.
       */
      public Builder setMaxRootDurationMillis(long value) {
        copyOnWrite();
        instance.setMaxRootDurationMillis(value);
        return this;
      }
      /**
       * <pre>
       * max_root_duration_millis is the interval after which a new signed root is
       * produced even if there have been no submission.  If zero, this behavior is
       * disabled.
       * </pre>
       *
       * <code>int64 max_root_duration_millis = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxRootDurationMillis() {
        copyOnWrite();
        instance.clearMaxRootDurationMillis();
        return this;
      }

      /**
       * <pre>
       * If true the tree was soft deleted.
       * </pre>
       *
       * <code>bool deleted = 18;</code>
       * @return The deleted.
       */
      @java.lang.Override
      public boolean getDeleted() {
        return instance.getDeleted();
      }
      /**
       * <pre>
       * If true the tree was soft deleted.
       * </pre>
       *
       * <code>bool deleted = 18;</code>
       * @param value The deleted to set.
       * @return This builder for chaining.
       */
      public Builder setDeleted(boolean value) {
        copyOnWrite();
        instance.setDeleted(value);
        return this;
      }
      /**
       * <pre>
       * If true the tree was soft deleted.
       * </pre>
       *
       * <code>bool deleted = 18;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeleted() {
        copyOnWrite();
        instance.clearDeleted();
        return this;
      }

      /**
       * <pre>
       * Time of tree deletion, if any.
       * </pre>
       *
       * <code>int64 delete_time_nanos = 19;</code>
       * @return The deleteTimeNanos.
       */
      @java.lang.Override
      public long getDeleteTimeNanos() {
        return instance.getDeleteTimeNanos();
      }
      /**
       * <pre>
       * Time of tree deletion, if any.
       * </pre>
       *
       * <code>int64 delete_time_nanos = 19;</code>
       * @param value The deleteTimeNanos to set.
       * @return This builder for chaining.
       */
      public Builder setDeleteTimeNanos(long value) {
        copyOnWrite();
        instance.setDeleteTimeNanos(value);
        return this;
      }
      /**
       * <pre>
       * Time of tree deletion, if any.
       * </pre>
       *
       * <code>int64 delete_time_nanos = 19;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeleteTimeNanos() {
        copyOnWrite();
        instance.clearDeleteTimeNanos();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:spannerpb.TreeInfo)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.trillian.spannerpb.Spanner.TreeInfo();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "storageConfig_",
              "storageConfigCase_",
              "treeId_",
              "keyId_",
              "name_",
              "description_",
              "treeType_",
              google.trillian.spannerpb.Spanner.LogStorageConfig.class,
              google.trillian.spannerpb.Spanner.MapStorageConfig.class,
              "treeState_",
              "hashStrategy_",
              "hashAlgorithm_",
              "signatureAlgorithm_",
              "createTimeNanos_",
              "updateTimeNanos_",
              "privateKey_",
              "publicKeyDer_",
              "maxRootDurationMillis_",
              "deleted_",
              "deleteTimeNanos_",
            };
            java.lang.String info =
                "\u0000\u0012\u0001\u0000\u0001\u0013\u0012\u0000\u0000\u0000\u0001\u0002\u0002\u0002" +
                "\u0003\u0208\u0004\u0208\u0005\f\u0006<\u0000\u0007<\u0000\b\f\t\f\n\f\u000b\f\r" +
                "\u0002\u000e\u0002\u000f\t\u0010\n\u0011\u0002\u0012\u0007\u0013\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.trillian.spannerpb.Spanner.TreeInfo> parser = PARSER;
          if (parser == null) {
            synchronized (google.trillian.spannerpb.Spanner.TreeInfo.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.trillian.spannerpb.Spanner.TreeInfo>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:spannerpb.TreeInfo)
    private static final google.trillian.spannerpb.Spanner.TreeInfo DEFAULT_INSTANCE;
    static {
      TreeInfo defaultInstance = new TreeInfo();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TreeInfo.class, defaultInstance);
    }

    public static google.trillian.spannerpb.Spanner.TreeInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TreeInfo> PARSER;

    public static com.google.protobuf.Parser<TreeInfo> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TreeHeadOrBuilder extends
      // @@protoc_insertion_point(interface_extends:spannerpb.TreeHead)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * tree_id identifies the tree this TreeHead is built from.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     * @return The treeId.
     */
    long getTreeId();

    /**
     * <pre>
     * ts_nanos is the nanosecond resolution timestamp at which the
     * TreeHead was created.
     * </pre>
     *
     * <code>int64 ts_nanos = 2;</code>
     * @return The tsNanos.
     */
    long getTsNanos();

    /**
     * <pre>
     * tree_size is the number of entries in the tree.
     * </pre>
     *
     * <code>int64 tree_size = 3;</code>
     * @return The treeSize.
     */
    long getTreeSize();

    /**
     * <pre>
     * root_hash is the root of the tree.
     * </pre>
     *
     * <code>bytes root_hash = 4;</code>
     * @return The rootHash.
     */
    com.google.protobuf.ByteString getRootHash();

    /**
     * <pre>
     * signature holds the raw digital signature across the serialized log_root
     * (not present) represented by the data in this TreeHead.
     * </pre>
     *
     * <code>bytes signature = 10;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();

    /**
     * <pre>
     * tree_revision identifies the revision at which the TreeHead was created.
     * </pre>
     *
     * <code>int64 tree_revision = 6;</code>
     * @return The treeRevision.
     */
    long getTreeRevision();

    /**
     * <code>bytes metadata = 9;</code>
     * @return The metadata.
     */
    com.google.protobuf.ByteString getMetadata();
  }
  /**
   * <pre>
   * TreeHead is the storage format for Trillian's commitment to a particular
   * tree state.
   * </pre>
   *
   * Protobuf type {@code spannerpb.TreeHead}
   */
  public  static final class TreeHead extends
      com.google.protobuf.GeneratedMessageLite<
          TreeHead, TreeHead.Builder> implements
      // @@protoc_insertion_point(message_implements:spannerpb.TreeHead)
      TreeHeadOrBuilder {
    private TreeHead() {
      rootHash_ = com.google.protobuf.ByteString.EMPTY;
      signature_ = com.google.protobuf.ByteString.EMPTY;
      metadata_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int TREE_ID_FIELD_NUMBER = 1;
    private long treeId_;
    /**
     * <pre>
     * tree_id identifies the tree this TreeHead is built from.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     * @return The treeId.
     */
    @java.lang.Override
    public long getTreeId() {
      return treeId_;
    }
    /**
     * <pre>
     * tree_id identifies the tree this TreeHead is built from.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     * @param value The treeId to set.
     */
    private void setTreeId(long value) {
      
      treeId_ = value;
    }
    /**
     * <pre>
     * tree_id identifies the tree this TreeHead is built from.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     */
    private void clearTreeId() {
      
      treeId_ = 0L;
    }

    public static final int TS_NANOS_FIELD_NUMBER = 2;
    private long tsNanos_;
    /**
     * <pre>
     * ts_nanos is the nanosecond resolution timestamp at which the
     * TreeHead was created.
     * </pre>
     *
     * <code>int64 ts_nanos = 2;</code>
     * @return The tsNanos.
     */
    @java.lang.Override
    public long getTsNanos() {
      return tsNanos_;
    }
    /**
     * <pre>
     * ts_nanos is the nanosecond resolution timestamp at which the
     * TreeHead was created.
     * </pre>
     *
     * <code>int64 ts_nanos = 2;</code>
     * @param value The tsNanos to set.
     */
    private void setTsNanos(long value) {
      
      tsNanos_ = value;
    }
    /**
     * <pre>
     * ts_nanos is the nanosecond resolution timestamp at which the
     * TreeHead was created.
     * </pre>
     *
     * <code>int64 ts_nanos = 2;</code>
     */
    private void clearTsNanos() {
      
      tsNanos_ = 0L;
    }

    public static final int TREE_SIZE_FIELD_NUMBER = 3;
    private long treeSize_;
    /**
     * <pre>
     * tree_size is the number of entries in the tree.
     * </pre>
     *
     * <code>int64 tree_size = 3;</code>
     * @return The treeSize.
     */
    @java.lang.Override
    public long getTreeSize() {
      return treeSize_;
    }
    /**
     * <pre>
     * tree_size is the number of entries in the tree.
     * </pre>
     *
     * <code>int64 tree_size = 3;</code>
     * @param value The treeSize to set.
     */
    private void setTreeSize(long value) {
      
      treeSize_ = value;
    }
    /**
     * <pre>
     * tree_size is the number of entries in the tree.
     * </pre>
     *
     * <code>int64 tree_size = 3;</code>
     */
    private void clearTreeSize() {
      
      treeSize_ = 0L;
    }

    public static final int ROOT_HASH_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString rootHash_;
    /**
     * <pre>
     * root_hash is the root of the tree.
     * </pre>
     *
     * <code>bytes root_hash = 4;</code>
     * @return The rootHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getRootHash() {
      return rootHash_;
    }
    /**
     * <pre>
     * root_hash is the root of the tree.
     * </pre>
     *
     * <code>bytes root_hash = 4;</code>
     * @param value The rootHash to set.
     */
    private void setRootHash(com.google.protobuf.ByteString value) {
      value.getClass();
  
      rootHash_ = value;
    }
    /**
     * <pre>
     * root_hash is the root of the tree.
     * </pre>
     *
     * <code>bytes root_hash = 4;</code>
     */
    private void clearRootHash() {
      
      rootHash_ = getDefaultInstance().getRootHash();
    }

    public static final int SIGNATURE_FIELD_NUMBER = 10;
    private com.google.protobuf.ByteString signature_;
    /**
     * <pre>
     * signature holds the raw digital signature across the serialized log_root
     * (not present) represented by the data in this TreeHead.
     * </pre>
     *
     * <code>bytes signature = 10;</code>
     * @return The signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }
    /**
     * <pre>
     * signature holds the raw digital signature across the serialized log_root
     * (not present) represented by the data in this TreeHead.
     * </pre>
     *
     * <code>bytes signature = 10;</code>
     * @param value The signature to set.
     */
    private void setSignature(com.google.protobuf.ByteString value) {
      value.getClass();
  
      signature_ = value;
    }
    /**
     * <pre>
     * signature holds the raw digital signature across the serialized log_root
     * (not present) represented by the data in this TreeHead.
     * </pre>
     *
     * <code>bytes signature = 10;</code>
     */
    private void clearSignature() {
      
      signature_ = getDefaultInstance().getSignature();
    }

    public static final int TREE_REVISION_FIELD_NUMBER = 6;
    private long treeRevision_;
    /**
     * <pre>
     * tree_revision identifies the revision at which the TreeHead was created.
     * </pre>
     *
     * <code>int64 tree_revision = 6;</code>
     * @return The treeRevision.
     */
    @java.lang.Override
    public long getTreeRevision() {
      return treeRevision_;
    }
    /**
     * <pre>
     * tree_revision identifies the revision at which the TreeHead was created.
     * </pre>
     *
     * <code>int64 tree_revision = 6;</code>
     * @param value The treeRevision to set.
     */
    private void setTreeRevision(long value) {
      
      treeRevision_ = value;
    }
    /**
     * <pre>
     * tree_revision identifies the revision at which the TreeHead was created.
     * </pre>
     *
     * <code>int64 tree_revision = 6;</code>
     */
    private void clearTreeRevision() {
      
      treeRevision_ = 0L;
    }

    public static final int METADATA_FIELD_NUMBER = 9;
    private com.google.protobuf.ByteString metadata_;
    /**
     * <code>bytes metadata = 9;</code>
     * @return The metadata.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getMetadata() {
      return metadata_;
    }
    /**
     * <code>bytes metadata = 9;</code>
     * @param value The metadata to set.
     */
    private void setMetadata(com.google.protobuf.ByteString value) {
      value.getClass();
  
      metadata_ = value;
    }
    /**
     * <code>bytes metadata = 9;</code>
     */
    private void clearMetadata() {
      
      metadata_ = getDefaultInstance().getMetadata();
    }

    public static google.trillian.spannerpb.Spanner.TreeHead parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.spannerpb.Spanner.TreeHead parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.TreeHead parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.spannerpb.Spanner.TreeHead parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.TreeHead parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.spannerpb.Spanner.TreeHead parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.TreeHead parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.spannerpb.Spanner.TreeHead parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.TreeHead parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.trillian.spannerpb.Spanner.TreeHead parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.spannerpb.Spanner.TreeHead parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.spannerpb.Spanner.TreeHead parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.trillian.spannerpb.Spanner.TreeHead prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * TreeHead is the storage format for Trillian's commitment to a particular
     * tree state.
     * </pre>
     *
     * Protobuf type {@code spannerpb.TreeHead}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.trillian.spannerpb.Spanner.TreeHead, Builder> implements
        // @@protoc_insertion_point(builder_implements:spannerpb.TreeHead)
        google.trillian.spannerpb.Spanner.TreeHeadOrBuilder {
      // Construct using google.trillian.spannerpb.Spanner.TreeHead.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * tree_id identifies the tree this TreeHead is built from.
       * </pre>
       *
       * <code>int64 tree_id = 1;</code>
       * @return The treeId.
       */
      @java.lang.Override
      public long getTreeId() {
        return instance.getTreeId();
      }
      /**
       * <pre>
       * tree_id identifies the tree this TreeHead is built from.
       * </pre>
       *
       * <code>int64 tree_id = 1;</code>
       * @param value The treeId to set.
       * @return This builder for chaining.
       */
      public Builder setTreeId(long value) {
        copyOnWrite();
        instance.setTreeId(value);
        return this;
      }
      /**
       * <pre>
       * tree_id identifies the tree this TreeHead is built from.
       * </pre>
       *
       * <code>int64 tree_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTreeId() {
        copyOnWrite();
        instance.clearTreeId();
        return this;
      }

      /**
       * <pre>
       * ts_nanos is the nanosecond resolution timestamp at which the
       * TreeHead was created.
       * </pre>
       *
       * <code>int64 ts_nanos = 2;</code>
       * @return The tsNanos.
       */
      @java.lang.Override
      public long getTsNanos() {
        return instance.getTsNanos();
      }
      /**
       * <pre>
       * ts_nanos is the nanosecond resolution timestamp at which the
       * TreeHead was created.
       * </pre>
       *
       * <code>int64 ts_nanos = 2;</code>
       * @param value The tsNanos to set.
       * @return This builder for chaining.
       */
      public Builder setTsNanos(long value) {
        copyOnWrite();
        instance.setTsNanos(value);
        return this;
      }
      /**
       * <pre>
       * ts_nanos is the nanosecond resolution timestamp at which the
       * TreeHead was created.
       * </pre>
       *
       * <code>int64 ts_nanos = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearTsNanos() {
        copyOnWrite();
        instance.clearTsNanos();
        return this;
      }

      /**
       * <pre>
       * tree_size is the number of entries in the tree.
       * </pre>
       *
       * <code>int64 tree_size = 3;</code>
       * @return The treeSize.
       */
      @java.lang.Override
      public long getTreeSize() {
        return instance.getTreeSize();
      }
      /**
       * <pre>
       * tree_size is the number of entries in the tree.
       * </pre>
       *
       * <code>int64 tree_size = 3;</code>
       * @param value The treeSize to set.
       * @return This builder for chaining.
       */
      public Builder setTreeSize(long value) {
        copyOnWrite();
        instance.setTreeSize(value);
        return this;
      }
      /**
       * <pre>
       * tree_size is the number of entries in the tree.
       * </pre>
       *
       * <code>int64 tree_size = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTreeSize() {
        copyOnWrite();
        instance.clearTreeSize();
        return this;
      }

      /**
       * <pre>
       * root_hash is the root of the tree.
       * </pre>
       *
       * <code>bytes root_hash = 4;</code>
       * @return The rootHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getRootHash() {
        return instance.getRootHash();
      }
      /**
       * <pre>
       * root_hash is the root of the tree.
       * </pre>
       *
       * <code>bytes root_hash = 4;</code>
       * @param value The rootHash to set.
       * @return This builder for chaining.
       */
      public Builder setRootHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRootHash(value);
        return this;
      }
      /**
       * <pre>
       * root_hash is the root of the tree.
       * </pre>
       *
       * <code>bytes root_hash = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearRootHash() {
        copyOnWrite();
        instance.clearRootHash();
        return this;
      }

      /**
       * <pre>
       * signature holds the raw digital signature across the serialized log_root
       * (not present) represented by the data in this TreeHead.
       * </pre>
       *
       * <code>bytes signature = 10;</code>
       * @return The signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return instance.getSignature();
      }
      /**
       * <pre>
       * signature holds the raw digital signature across the serialized log_root
       * (not present) represented by the data in this TreeHead.
       * </pre>
       *
       * <code>bytes signature = 10;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <pre>
       * signature holds the raw digital signature across the serialized log_root
       * (not present) represented by the data in this TreeHead.
       * </pre>
       *
       * <code>bytes signature = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }

      /**
       * <pre>
       * tree_revision identifies the revision at which the TreeHead was created.
       * </pre>
       *
       * <code>int64 tree_revision = 6;</code>
       * @return The treeRevision.
       */
      @java.lang.Override
      public long getTreeRevision() {
        return instance.getTreeRevision();
      }
      /**
       * <pre>
       * tree_revision identifies the revision at which the TreeHead was created.
       * </pre>
       *
       * <code>int64 tree_revision = 6;</code>
       * @param value The treeRevision to set.
       * @return This builder for chaining.
       */
      public Builder setTreeRevision(long value) {
        copyOnWrite();
        instance.setTreeRevision(value);
        return this;
      }
      /**
       * <pre>
       * tree_revision identifies the revision at which the TreeHead was created.
       * </pre>
       *
       * <code>int64 tree_revision = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearTreeRevision() {
        copyOnWrite();
        instance.clearTreeRevision();
        return this;
      }

      /**
       * <code>bytes metadata = 9;</code>
       * @return The metadata.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getMetadata() {
        return instance.getMetadata();
      }
      /**
       * <code>bytes metadata = 9;</code>
       * @param value The metadata to set.
       * @return This builder for chaining.
       */
      public Builder setMetadata(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMetadata(value);
        return this;
      }
      /**
       * <code>bytes metadata = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearMetadata() {
        copyOnWrite();
        instance.clearMetadata();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:spannerpb.TreeHead)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.trillian.spannerpb.Spanner.TreeHead();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "treeId_",
              "tsNanos_",
              "treeSize_",
              "rootHash_",
              "treeRevision_",
              "metadata_",
              "signature_",
            };
            java.lang.String info =
                "\u0000\u0007\u0000\u0000\u0001\n\u0007\u0000\u0000\u0000\u0001\u0002\u0002\u0002" +
                "\u0003\u0002\u0004\n\u0006\u0002\t\n\n\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.trillian.spannerpb.Spanner.TreeHead> parser = PARSER;
          if (parser == null) {
            synchronized (google.trillian.spannerpb.Spanner.TreeHead.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.trillian.spannerpb.Spanner.TreeHead>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:spannerpb.TreeHead)
    private static final google.trillian.spannerpb.Spanner.TreeHead DEFAULT_INSTANCE;
    static {
      TreeHead defaultInstance = new TreeHead();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TreeHead.class, defaultInstance);
    }

    public static google.trillian.spannerpb.Spanner.TreeHead getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TreeHead> PARSER;

    public static com.google.protobuf.Parser<TreeHead> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
