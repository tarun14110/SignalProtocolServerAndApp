// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: skylog/storage/gcp/gcppb/gcp.proto

package google.trillian.gcppb;

public final class Gcp {
  private Gcp() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface BuildJobOrBuilder extends
      // @@protoc_insertion_point(interface_extends:gcppb.BuildJob)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The tree ID to build a subtree of.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     * @return The treeId.
     */
    long getTreeId();

    /**
     * <pre>
     * The beginning of the leaves range (inclusive).
     * </pre>
     *
     * <code>uint64 begin = 2;</code>
     * @return The begin.
     */
    long getBegin();

    /**
     * <pre>
     * The ending of the leaves range (exclusive).
     * </pre>
     *
     * <code>uint64 end = 3;</code>
     * @return The end.
     */
    long getEnd();

    /**
     * <pre>
     * The tree sharding scheme that the build worker should use. Since builders
     * are stateless it is more efficient to pass it in from the master rather
     * than fetch it from storage on each job invocation.
     * </pre>
     *
     * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
     * @return Whether the treeSharding field is set.
     */
    boolean hasTreeSharding();
    /**
     * <pre>
     * The tree sharding scheme that the build worker should use. Since builders
     * are stateless it is more efficient to pass it in from the master rather
     * than fetch it from storage on each job invocation.
     * </pre>
     *
     * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
     * @return The treeSharding.
     */
    google.trillian.gcppb.Gcp.TreeSharding getTreeSharding();

    /**
     * <pre>
     * The sequence sharding scheme that the build worker should use. It is
     * provided for the same reason as the tree sharding field.
     * </pre>
     *
     * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
     * @return Whether the seqSharding field is set.
     */
    boolean hasSeqSharding();
    /**
     * <pre>
     * The sequence sharding scheme that the build worker should use. It is
     * provided for the same reason as the tree sharding field.
     * </pre>
     *
     * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
     * @return The seqSharding.
     */
    google.trillian.gcppb.Gcp.SequenceSharding getSeqSharding();
  }
  /**
   * <pre>
   * BuildJob is a Merke tree building job. It instructs workers to build a
   * subtree covering leaves of the [begin, end) range for the specified tree.
   * </pre>
   *
   * Protobuf type {@code gcppb.BuildJob}
   */
  public  static final class BuildJob extends
      com.google.protobuf.GeneratedMessageLite<
          BuildJob, BuildJob.Builder> implements
      // @@protoc_insertion_point(message_implements:gcppb.BuildJob)
      BuildJobOrBuilder {
    private BuildJob() {
    }
    public static final int TREE_ID_FIELD_NUMBER = 1;
    private long treeId_;
    /**
     * <pre>
     * The tree ID to build a subtree of.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     * @return The treeId.
     */
    @java.lang.Override
    public long getTreeId() {
      return treeId_;
    }
    /**
     * <pre>
     * The tree ID to build a subtree of.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     * @param value The treeId to set.
     */
    private void setTreeId(long value) {
      
      treeId_ = value;
    }
    /**
     * <pre>
     * The tree ID to build a subtree of.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     */
    private void clearTreeId() {
      
      treeId_ = 0L;
    }

    public static final int BEGIN_FIELD_NUMBER = 2;
    private long begin_;
    /**
     * <pre>
     * The beginning of the leaves range (inclusive).
     * </pre>
     *
     * <code>uint64 begin = 2;</code>
     * @return The begin.
     */
    @java.lang.Override
    public long getBegin() {
      return begin_;
    }
    /**
     * <pre>
     * The beginning of the leaves range (inclusive).
     * </pre>
     *
     * <code>uint64 begin = 2;</code>
     * @param value The begin to set.
     */
    private void setBegin(long value) {
      
      begin_ = value;
    }
    /**
     * <pre>
     * The beginning of the leaves range (inclusive).
     * </pre>
     *
     * <code>uint64 begin = 2;</code>
     */
    private void clearBegin() {
      
      begin_ = 0L;
    }

    public static final int END_FIELD_NUMBER = 3;
    private long end_;
    /**
     * <pre>
     * The ending of the leaves range (exclusive).
     * </pre>
     *
     * <code>uint64 end = 3;</code>
     * @return The end.
     */
    @java.lang.Override
    public long getEnd() {
      return end_;
    }
    /**
     * <pre>
     * The ending of the leaves range (exclusive).
     * </pre>
     *
     * <code>uint64 end = 3;</code>
     * @param value The end to set.
     */
    private void setEnd(long value) {
      
      end_ = value;
    }
    /**
     * <pre>
     * The ending of the leaves range (exclusive).
     * </pre>
     *
     * <code>uint64 end = 3;</code>
     */
    private void clearEnd() {
      
      end_ = 0L;
    }

    public static final int TREE_SHARDING_FIELD_NUMBER = 4;
    private google.trillian.gcppb.Gcp.TreeSharding treeSharding_;
    /**
     * <pre>
     * The tree sharding scheme that the build worker should use. Since builders
     * are stateless it is more efficient to pass it in from the master rather
     * than fetch it from storage on each job invocation.
     * </pre>
     *
     * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
     */
    @java.lang.Override
    public boolean hasTreeSharding() {
      return treeSharding_ != null;
    }
    /**
     * <pre>
     * The tree sharding scheme that the build worker should use. Since builders
     * are stateless it is more efficient to pass it in from the master rather
     * than fetch it from storage on each job invocation.
     * </pre>
     *
     * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
     */
    @java.lang.Override
    public google.trillian.gcppb.Gcp.TreeSharding getTreeSharding() {
      return treeSharding_ == null ? google.trillian.gcppb.Gcp.TreeSharding.getDefaultInstance() : treeSharding_;
    }
    /**
     * <pre>
     * The tree sharding scheme that the build worker should use. Since builders
     * are stateless it is more efficient to pass it in from the master rather
     * than fetch it from storage on each job invocation.
     * </pre>
     *
     * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
     */
    private void setTreeSharding(google.trillian.gcppb.Gcp.TreeSharding value) {
      value.getClass();
  treeSharding_ = value;
      
      }
    /**
     * <pre>
     * The tree sharding scheme that the build worker should use. Since builders
     * are stateless it is more efficient to pass it in from the master rather
     * than fetch it from storage on each job invocation.
     * </pre>
     *
     * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeTreeSharding(google.trillian.gcppb.Gcp.TreeSharding value) {
      value.getClass();
  if (treeSharding_ != null &&
          treeSharding_ != google.trillian.gcppb.Gcp.TreeSharding.getDefaultInstance()) {
        treeSharding_ =
          google.trillian.gcppb.Gcp.TreeSharding.newBuilder(treeSharding_).mergeFrom(value).buildPartial();
      } else {
        treeSharding_ = value;
      }
      
    }
    /**
     * <pre>
     * The tree sharding scheme that the build worker should use. Since builders
     * are stateless it is more efficient to pass it in from the master rather
     * than fetch it from storage on each job invocation.
     * </pre>
     *
     * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
     */
    private void clearTreeSharding() {  treeSharding_ = null;
      
    }

    public static final int SEQ_SHARDING_FIELD_NUMBER = 5;
    private google.trillian.gcppb.Gcp.SequenceSharding seqSharding_;
    /**
     * <pre>
     * The sequence sharding scheme that the build worker should use. It is
     * provided for the same reason as the tree sharding field.
     * </pre>
     *
     * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
     */
    @java.lang.Override
    public boolean hasSeqSharding() {
      return seqSharding_ != null;
    }
    /**
     * <pre>
     * The sequence sharding scheme that the build worker should use. It is
     * provided for the same reason as the tree sharding field.
     * </pre>
     *
     * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
     */
    @java.lang.Override
    public google.trillian.gcppb.Gcp.SequenceSharding getSeqSharding() {
      return seqSharding_ == null ? google.trillian.gcppb.Gcp.SequenceSharding.getDefaultInstance() : seqSharding_;
    }
    /**
     * <pre>
     * The sequence sharding scheme that the build worker should use. It is
     * provided for the same reason as the tree sharding field.
     * </pre>
     *
     * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
     */
    private void setSeqSharding(google.trillian.gcppb.Gcp.SequenceSharding value) {
      value.getClass();
  seqSharding_ = value;
      
      }
    /**
     * <pre>
     * The sequence sharding scheme that the build worker should use. It is
     * provided for the same reason as the tree sharding field.
     * </pre>
     *
     * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeSeqSharding(google.trillian.gcppb.Gcp.SequenceSharding value) {
      value.getClass();
  if (seqSharding_ != null &&
          seqSharding_ != google.trillian.gcppb.Gcp.SequenceSharding.getDefaultInstance()) {
        seqSharding_ =
          google.trillian.gcppb.Gcp.SequenceSharding.newBuilder(seqSharding_).mergeFrom(value).buildPartial();
      } else {
        seqSharding_ = value;
      }
      
    }
    /**
     * <pre>
     * The sequence sharding scheme that the build worker should use. It is
     * provided for the same reason as the tree sharding field.
     * </pre>
     *
     * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
     */
    private void clearSeqSharding() {  seqSharding_ = null;
      
    }

    public static google.trillian.gcppb.Gcp.BuildJob parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.gcppb.Gcp.BuildJob parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.BuildJob parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.gcppb.Gcp.BuildJob parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.BuildJob parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.gcppb.Gcp.BuildJob parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.BuildJob parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.gcppb.Gcp.BuildJob parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.BuildJob parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.trillian.gcppb.Gcp.BuildJob parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.BuildJob parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.gcppb.Gcp.BuildJob parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.trillian.gcppb.Gcp.BuildJob prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * BuildJob is a Merke tree building job. It instructs workers to build a
     * subtree covering leaves of the [begin, end) range for the specified tree.
     * </pre>
     *
     * Protobuf type {@code gcppb.BuildJob}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.trillian.gcppb.Gcp.BuildJob, Builder> implements
        // @@protoc_insertion_point(builder_implements:gcppb.BuildJob)
        google.trillian.gcppb.Gcp.BuildJobOrBuilder {
      // Construct using google.trillian.gcppb.Gcp.BuildJob.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The tree ID to build a subtree of.
       * </pre>
       *
       * <code>int64 tree_id = 1;</code>
       * @return The treeId.
       */
      @java.lang.Override
      public long getTreeId() {
        return instance.getTreeId();
      }
      /**
       * <pre>
       * The tree ID to build a subtree of.
       * </pre>
       *
       * <code>int64 tree_id = 1;</code>
       * @param value The treeId to set.
       * @return This builder for chaining.
       */
      public Builder setTreeId(long value) {
        copyOnWrite();
        instance.setTreeId(value);
        return this;
      }
      /**
       * <pre>
       * The tree ID to build a subtree of.
       * </pre>
       *
       * <code>int64 tree_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTreeId() {
        copyOnWrite();
        instance.clearTreeId();
        return this;
      }

      /**
       * <pre>
       * The beginning of the leaves range (inclusive).
       * </pre>
       *
       * <code>uint64 begin = 2;</code>
       * @return The begin.
       */
      @java.lang.Override
      public long getBegin() {
        return instance.getBegin();
      }
      /**
       * <pre>
       * The beginning of the leaves range (inclusive).
       * </pre>
       *
       * <code>uint64 begin = 2;</code>
       * @param value The begin to set.
       * @return This builder for chaining.
       */
      public Builder setBegin(long value) {
        copyOnWrite();
        instance.setBegin(value);
        return this;
      }
      /**
       * <pre>
       * The beginning of the leaves range (inclusive).
       * </pre>
       *
       * <code>uint64 begin = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearBegin() {
        copyOnWrite();
        instance.clearBegin();
        return this;
      }

      /**
       * <pre>
       * The ending of the leaves range (exclusive).
       * </pre>
       *
       * <code>uint64 end = 3;</code>
       * @return The end.
       */
      @java.lang.Override
      public long getEnd() {
        return instance.getEnd();
      }
      /**
       * <pre>
       * The ending of the leaves range (exclusive).
       * </pre>
       *
       * <code>uint64 end = 3;</code>
       * @param value The end to set.
       * @return This builder for chaining.
       */
      public Builder setEnd(long value) {
        copyOnWrite();
        instance.setEnd(value);
        return this;
      }
      /**
       * <pre>
       * The ending of the leaves range (exclusive).
       * </pre>
       *
       * <code>uint64 end = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearEnd() {
        copyOnWrite();
        instance.clearEnd();
        return this;
      }

      /**
       * <pre>
       * The tree sharding scheme that the build worker should use. Since builders
       * are stateless it is more efficient to pass it in from the master rather
       * than fetch it from storage on each job invocation.
       * </pre>
       *
       * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
       */
      @java.lang.Override
      public boolean hasTreeSharding() {
        return instance.hasTreeSharding();
      }
      /**
       * <pre>
       * The tree sharding scheme that the build worker should use. Since builders
       * are stateless it is more efficient to pass it in from the master rather
       * than fetch it from storage on each job invocation.
       * </pre>
       *
       * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
       */
      @java.lang.Override
      public google.trillian.gcppb.Gcp.TreeSharding getTreeSharding() {
        return instance.getTreeSharding();
      }
      /**
       * <pre>
       * The tree sharding scheme that the build worker should use. Since builders
       * are stateless it is more efficient to pass it in from the master rather
       * than fetch it from storage on each job invocation.
       * </pre>
       *
       * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
       */
      public Builder setTreeSharding(google.trillian.gcppb.Gcp.TreeSharding value) {
        copyOnWrite();
        instance.setTreeSharding(value);
        return this;
        }
      /**
       * <pre>
       * The tree sharding scheme that the build worker should use. Since builders
       * are stateless it is more efficient to pass it in from the master rather
       * than fetch it from storage on each job invocation.
       * </pre>
       *
       * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
       */
      public Builder setTreeSharding(
          google.trillian.gcppb.Gcp.TreeSharding.Builder builderForValue) {
        copyOnWrite();
        instance.setTreeSharding(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The tree sharding scheme that the build worker should use. Since builders
       * are stateless it is more efficient to pass it in from the master rather
       * than fetch it from storage on each job invocation.
       * </pre>
       *
       * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
       */
      public Builder mergeTreeSharding(google.trillian.gcppb.Gcp.TreeSharding value) {
        copyOnWrite();
        instance.mergeTreeSharding(value);
        return this;
      }
      /**
       * <pre>
       * The tree sharding scheme that the build worker should use. Since builders
       * are stateless it is more efficient to pass it in from the master rather
       * than fetch it from storage on each job invocation.
       * </pre>
       *
       * <code>.gcppb.TreeSharding tree_sharding = 4;</code>
       */
      public Builder clearTreeSharding() {  copyOnWrite();
        instance.clearTreeSharding();
        return this;
      }

      /**
       * <pre>
       * The sequence sharding scheme that the build worker should use. It is
       * provided for the same reason as the tree sharding field.
       * </pre>
       *
       * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
       */
      @java.lang.Override
      public boolean hasSeqSharding() {
        return instance.hasSeqSharding();
      }
      /**
       * <pre>
       * The sequence sharding scheme that the build worker should use. It is
       * provided for the same reason as the tree sharding field.
       * </pre>
       *
       * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
       */
      @java.lang.Override
      public google.trillian.gcppb.Gcp.SequenceSharding getSeqSharding() {
        return instance.getSeqSharding();
      }
      /**
       * <pre>
       * The sequence sharding scheme that the build worker should use. It is
       * provided for the same reason as the tree sharding field.
       * </pre>
       *
       * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
       */
      public Builder setSeqSharding(google.trillian.gcppb.Gcp.SequenceSharding value) {
        copyOnWrite();
        instance.setSeqSharding(value);
        return this;
        }
      /**
       * <pre>
       * The sequence sharding scheme that the build worker should use. It is
       * provided for the same reason as the tree sharding field.
       * </pre>
       *
       * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
       */
      public Builder setSeqSharding(
          google.trillian.gcppb.Gcp.SequenceSharding.Builder builderForValue) {
        copyOnWrite();
        instance.setSeqSharding(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The sequence sharding scheme that the build worker should use. It is
       * provided for the same reason as the tree sharding field.
       * </pre>
       *
       * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
       */
      public Builder mergeSeqSharding(google.trillian.gcppb.Gcp.SequenceSharding value) {
        copyOnWrite();
        instance.mergeSeqSharding(value);
        return this;
      }
      /**
       * <pre>
       * The sequence sharding scheme that the build worker should use. It is
       * provided for the same reason as the tree sharding field.
       * </pre>
       *
       * <code>.gcppb.SequenceSharding seq_sharding = 5;</code>
       */
      public Builder clearSeqSharding() {  copyOnWrite();
        instance.clearSeqSharding();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:gcppb.BuildJob)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.trillian.gcppb.Gcp.BuildJob();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "treeId_",
              "begin_",
              "end_",
              "treeSharding_",
              "seqSharding_",
            };
            java.lang.String info =
                "\u0000\u0005\u0000\u0000\u0001\u0005\u0005\u0000\u0000\u0000\u0001\u0002\u0002\u0003" +
                "\u0003\u0003\u0004\t\u0005\t";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.trillian.gcppb.Gcp.BuildJob> parser = PARSER;
          if (parser == null) {
            synchronized (google.trillian.gcppb.Gcp.BuildJob.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.trillian.gcppb.Gcp.BuildJob>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:gcppb.BuildJob)
    private static final google.trillian.gcppb.Gcp.BuildJob DEFAULT_INSTANCE;
    static {
      BuildJob defaultInstance = new BuildJob();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        BuildJob.class, defaultInstance);
    }

    public static google.trillian.gcppb.Gcp.BuildJob getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<BuildJob> PARSER;

    public static com.google.protobuf.Parser<BuildJob> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TreeShardingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:gcppb.TreeSharding)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>uint32 levels = 1;</code>
     * @return The levels.
     */
    int getLevels();

    /**
     * <code>uint32 shards = 2;</code>
     * @return The shards.
     */
    int getShards();
  }
  /**
   * <pre>
   * TreeSharding describes the tree nodes sharding scheme.
   * The specified number of lower tree levels are split into the specified number
   * of shards, where each shard stores a periodic sub-structure of perfect
   * subtrees. There is one extra shard covering the upper tree levels.
   * See the tree storage comments for more details.
   * </pre>
   *
   * Protobuf type {@code gcppb.TreeSharding}
   */
  public  static final class TreeSharding extends
      com.google.protobuf.GeneratedMessageLite<
          TreeSharding, TreeSharding.Builder> implements
      // @@protoc_insertion_point(message_implements:gcppb.TreeSharding)
      TreeShardingOrBuilder {
    private TreeSharding() {
    }
    public static final int LEVELS_FIELD_NUMBER = 1;
    private int levels_;
    /**
     * <code>uint32 levels = 1;</code>
     * @return The levels.
     */
    @java.lang.Override
    public int getLevels() {
      return levels_;
    }
    /**
     * <code>uint32 levels = 1;</code>
     * @param value The levels to set.
     */
    private void setLevels(int value) {
      
      levels_ = value;
    }
    /**
     * <code>uint32 levels = 1;</code>
     */
    private void clearLevels() {
      
      levels_ = 0;
    }

    public static final int SHARDS_FIELD_NUMBER = 2;
    private int shards_;
    /**
     * <code>uint32 shards = 2;</code>
     * @return The shards.
     */
    @java.lang.Override
    public int getShards() {
      return shards_;
    }
    /**
     * <code>uint32 shards = 2;</code>
     * @param value The shards to set.
     */
    private void setShards(int value) {
      
      shards_ = value;
    }
    /**
     * <code>uint32 shards = 2;</code>
     */
    private void clearShards() {
      
      shards_ = 0;
    }

    public static google.trillian.gcppb.Gcp.TreeSharding parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.gcppb.Gcp.TreeSharding parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.TreeSharding parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.gcppb.Gcp.TreeSharding parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.TreeSharding parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.gcppb.Gcp.TreeSharding parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.TreeSharding parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.gcppb.Gcp.TreeSharding parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.TreeSharding parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.trillian.gcppb.Gcp.TreeSharding parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.TreeSharding parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.gcppb.Gcp.TreeSharding parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.trillian.gcppb.Gcp.TreeSharding prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * TreeSharding describes the tree nodes sharding scheme.
     * The specified number of lower tree levels are split into the specified number
     * of shards, where each shard stores a periodic sub-structure of perfect
     * subtrees. There is one extra shard covering the upper tree levels.
     * See the tree storage comments for more details.
     * </pre>
     *
     * Protobuf type {@code gcppb.TreeSharding}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.trillian.gcppb.Gcp.TreeSharding, Builder> implements
        // @@protoc_insertion_point(builder_implements:gcppb.TreeSharding)
        google.trillian.gcppb.Gcp.TreeShardingOrBuilder {
      // Construct using google.trillian.gcppb.Gcp.TreeSharding.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>uint32 levels = 1;</code>
       * @return The levels.
       */
      @java.lang.Override
      public int getLevels() {
        return instance.getLevels();
      }
      /**
       * <code>uint32 levels = 1;</code>
       * @param value The levels to set.
       * @return This builder for chaining.
       */
      public Builder setLevels(int value) {
        copyOnWrite();
        instance.setLevels(value);
        return this;
      }
      /**
       * <code>uint32 levels = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearLevels() {
        copyOnWrite();
        instance.clearLevels();
        return this;
      }

      /**
       * <code>uint32 shards = 2;</code>
       * @return The shards.
       */
      @java.lang.Override
      public int getShards() {
        return instance.getShards();
      }
      /**
       * <code>uint32 shards = 2;</code>
       * @param value The shards to set.
       * @return This builder for chaining.
       */
      public Builder setShards(int value) {
        copyOnWrite();
        instance.setShards(value);
        return this;
      }
      /**
       * <code>uint32 shards = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearShards() {
        copyOnWrite();
        instance.clearShards();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:gcppb.TreeSharding)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.trillian.gcppb.Gcp.TreeSharding();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "levels_",
              "shards_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u000b\u0002\u000b" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.trillian.gcppb.Gcp.TreeSharding> parser = PARSER;
          if (parser == null) {
            synchronized (google.trillian.gcppb.Gcp.TreeSharding.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.trillian.gcppb.Gcp.TreeSharding>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:gcppb.TreeSharding)
    private static final google.trillian.gcppb.Gcp.TreeSharding DEFAULT_INSTANCE;
    static {
      TreeSharding defaultInstance = new TreeSharding();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TreeSharding.class, defaultInstance);
    }

    public static google.trillian.gcppb.Gcp.TreeSharding getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TreeSharding> PARSER;

    public static com.google.protobuf.Parser<TreeSharding> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SequenceShardingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:gcppb.SequenceSharding)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>uint32 shards = 1;</code>
     * @return The shards.
     */
    int getShards();

    /**
     * <code>uint64 size = 2;</code>
     * @return The size.
     */
    long getSize();
  }
  /**
   * <pre>
   * SequenceSharding describes the sequenced log entries sharding scheme.
   * The sequence is split into the specified number of shards, where each shard
   * stores a periodic sub-sequence consisting of stripes of the specified size.
   * See the sequence storage comments for more details.
   * </pre>
   *
   * Protobuf type {@code gcppb.SequenceSharding}
   */
  public  static final class SequenceSharding extends
      com.google.protobuf.GeneratedMessageLite<
          SequenceSharding, SequenceSharding.Builder> implements
      // @@protoc_insertion_point(message_implements:gcppb.SequenceSharding)
      SequenceShardingOrBuilder {
    private SequenceSharding() {
    }
    public static final int SHARDS_FIELD_NUMBER = 1;
    private int shards_;
    /**
     * <code>uint32 shards = 1;</code>
     * @return The shards.
     */
    @java.lang.Override
    public int getShards() {
      return shards_;
    }
    /**
     * <code>uint32 shards = 1;</code>
     * @param value The shards to set.
     */
    private void setShards(int value) {
      
      shards_ = value;
    }
    /**
     * <code>uint32 shards = 1;</code>
     */
    private void clearShards() {
      
      shards_ = 0;
    }

    public static final int SIZE_FIELD_NUMBER = 2;
    private long size_;
    /**
     * <code>uint64 size = 2;</code>
     * @return The size.
     */
    @java.lang.Override
    public long getSize() {
      return size_;
    }
    /**
     * <code>uint64 size = 2;</code>
     * @param value The size to set.
     */
    private void setSize(long value) {
      
      size_ = value;
    }
    /**
     * <code>uint64 size = 2;</code>
     */
    private void clearSize() {
      
      size_ = 0L;
    }

    public static google.trillian.gcppb.Gcp.SequenceSharding parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.gcppb.Gcp.SequenceSharding parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.SequenceSharding parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.gcppb.Gcp.SequenceSharding parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.SequenceSharding parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static google.trillian.gcppb.Gcp.SequenceSharding parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.SequenceSharding parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.gcppb.Gcp.SequenceSharding parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.SequenceSharding parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static google.trillian.gcppb.Gcp.SequenceSharding parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static google.trillian.gcppb.Gcp.SequenceSharding parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static google.trillian.gcppb.Gcp.SequenceSharding parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(google.trillian.gcppb.Gcp.SequenceSharding prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * SequenceSharding describes the sequenced log entries sharding scheme.
     * The sequence is split into the specified number of shards, where each shard
     * stores a periodic sub-sequence consisting of stripes of the specified size.
     * See the sequence storage comments for more details.
     * </pre>
     *
     * Protobuf type {@code gcppb.SequenceSharding}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          google.trillian.gcppb.Gcp.SequenceSharding, Builder> implements
        // @@protoc_insertion_point(builder_implements:gcppb.SequenceSharding)
        google.trillian.gcppb.Gcp.SequenceShardingOrBuilder {
      // Construct using google.trillian.gcppb.Gcp.SequenceSharding.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>uint32 shards = 1;</code>
       * @return The shards.
       */
      @java.lang.Override
      public int getShards() {
        return instance.getShards();
      }
      /**
       * <code>uint32 shards = 1;</code>
       * @param value The shards to set.
       * @return This builder for chaining.
       */
      public Builder setShards(int value) {
        copyOnWrite();
        instance.setShards(value);
        return this;
      }
      /**
       * <code>uint32 shards = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearShards() {
        copyOnWrite();
        instance.clearShards();
        return this;
      }

      /**
       * <code>uint64 size = 2;</code>
       * @return The size.
       */
      @java.lang.Override
      public long getSize() {
        return instance.getSize();
      }
      /**
       * <code>uint64 size = 2;</code>
       * @param value The size to set.
       * @return This builder for chaining.
       */
      public Builder setSize(long value) {
        copyOnWrite();
        instance.setSize(value);
        return this;
      }
      /**
       * <code>uint64 size = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSize() {
        copyOnWrite();
        instance.clearSize();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:gcppb.SequenceSharding)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new google.trillian.gcppb.Gcp.SequenceSharding();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "shards_",
              "size_",
            };
            java.lang.String info =
                "\u0000\u0002\u0000\u0000\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u000b\u0002\u0003" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<google.trillian.gcppb.Gcp.SequenceSharding> parser = PARSER;
          if (parser == null) {
            synchronized (google.trillian.gcppb.Gcp.SequenceSharding.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<google.trillian.gcppb.Gcp.SequenceSharding>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:gcppb.SequenceSharding)
    private static final google.trillian.gcppb.Gcp.SequenceSharding DEFAULT_INSTANCE;
    static {
      SequenceSharding defaultInstance = new SequenceSharding();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SequenceSharding.class, defaultInstance);
    }

    public static google.trillian.gcppb.Gcp.SequenceSharding getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SequenceSharding> PARSER;

    public static com.google.protobuf.Parser<SequenceSharding> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
