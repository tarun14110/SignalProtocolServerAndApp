// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trillian.proto

package google.trillian.proto;

/**
 * <pre>
 * Represents a tree, which may be either a verifiable log or map.
 * Readonly attributes are assigned at tree creation, after which they may not
 * be modified.
 * Note: Many APIs within the rest of the code require these objects to
 * be provided. For safety they should be obtained via Admin API calls and
 * not created dynamically.
 * </pre>
 *
 * Protobuf type {@code trillian.Tree}
 */
public  final class Tree extends
    com.google.protobuf.GeneratedMessageLite<
        Tree, Tree.Builder> implements
    // @@protoc_insertion_point(message_implements:trillian.Tree)
    TreeOrBuilder {
  private Tree() {
    displayName_ = "";
    description_ = "";
  }
  public static final int TREE_ID_FIELD_NUMBER = 1;
  private long treeId_;
  /**
   * <pre>
   * ID of the tree.
   * Readonly.
   * </pre>
   *
   * <code>int64 tree_id = 1;</code>
   * @return The treeId.
   */
  @java.lang.Override
  public long getTreeId() {
    return treeId_;
  }
  /**
   * <pre>
   * ID of the tree.
   * Readonly.
   * </pre>
   *
   * <code>int64 tree_id = 1;</code>
   * @param value The treeId to set.
   */
  private void setTreeId(long value) {
    
    treeId_ = value;
  }
  /**
   * <pre>
   * ID of the tree.
   * Readonly.
   * </pre>
   *
   * <code>int64 tree_id = 1;</code>
   */
  private void clearTreeId() {
    
    treeId_ = 0L;
  }

  public static final int TREE_STATE_FIELD_NUMBER = 2;
  private int treeState_;
  /**
   * <pre>
   * State of the tree.
   * Trees are ACTIVE after creation. At any point the tree may transition
   * between ACTIVE, DRAINING and FROZEN states.
   * </pre>
   *
   * <code>.trillian.TreeState tree_state = 2;</code>
   * @return The enum numeric value on the wire for treeState.
   */
  @java.lang.Override
  public int getTreeStateValue() {
    return treeState_;
  }
  /**
   * <pre>
   * State of the tree.
   * Trees are ACTIVE after creation. At any point the tree may transition
   * between ACTIVE, DRAINING and FROZEN states.
   * </pre>
   *
   * <code>.trillian.TreeState tree_state = 2;</code>
   * @return The treeState.
   */
  @java.lang.Override
  public google.trillian.proto.TreeState getTreeState() {
    google.trillian.proto.TreeState result = google.trillian.proto.TreeState.forNumber(treeState_);
    return result == null ? google.trillian.proto.TreeState.UNRECOGNIZED : result;
  }
  /**
   * <pre>
   * State of the tree.
   * Trees are ACTIVE after creation. At any point the tree may transition
   * between ACTIVE, DRAINING and FROZEN states.
   * </pre>
   *
   * <code>.trillian.TreeState tree_state = 2;</code>
   * @param value The enum numeric value on the wire for treeState to set.
   */
  private void setTreeStateValue(int value) {
      treeState_ = value;
  }
  /**
   * <pre>
   * State of the tree.
   * Trees are ACTIVE after creation. At any point the tree may transition
   * between ACTIVE, DRAINING and FROZEN states.
   * </pre>
   *
   * <code>.trillian.TreeState tree_state = 2;</code>
   * @param value The treeState to set.
   */
  private void setTreeState(google.trillian.proto.TreeState value) {
    treeState_ = value.getNumber();
    
  }
  /**
   * <pre>
   * State of the tree.
   * Trees are ACTIVE after creation. At any point the tree may transition
   * between ACTIVE, DRAINING and FROZEN states.
   * </pre>
   *
   * <code>.trillian.TreeState tree_state = 2;</code>
   */
  private void clearTreeState() {
    
    treeState_ = 0;
  }

  public static final int TREE_TYPE_FIELD_NUMBER = 3;
  private int treeType_;
  /**
   * <pre>
   * Type of the tree.
   * Readonly after Tree creation. Exception: Can be switched from
   * PREORDERED_LOG to LOG if the Tree is and remains in the FROZEN state.
   * </pre>
   *
   * <code>.trillian.TreeType tree_type = 3;</code>
   * @return The enum numeric value on the wire for treeType.
   */
  @java.lang.Override
  public int getTreeTypeValue() {
    return treeType_;
  }
  /**
   * <pre>
   * Type of the tree.
   * Readonly after Tree creation. Exception: Can be switched from
   * PREORDERED_LOG to LOG if the Tree is and remains in the FROZEN state.
   * </pre>
   *
   * <code>.trillian.TreeType tree_type = 3;</code>
   * @return The treeType.
   */
  @java.lang.Override
  public google.trillian.proto.TreeType getTreeType() {
    google.trillian.proto.TreeType result = google.trillian.proto.TreeType.forNumber(treeType_);
    return result == null ? google.trillian.proto.TreeType.UNRECOGNIZED : result;
  }
  /**
   * <pre>
   * Type of the tree.
   * Readonly after Tree creation. Exception: Can be switched from
   * PREORDERED_LOG to LOG if the Tree is and remains in the FROZEN state.
   * </pre>
   *
   * <code>.trillian.TreeType tree_type = 3;</code>
   * @param value The enum numeric value on the wire for treeType to set.
   */
  private void setTreeTypeValue(int value) {
      treeType_ = value;
  }
  /**
   * <pre>
   * Type of the tree.
   * Readonly after Tree creation. Exception: Can be switched from
   * PREORDERED_LOG to LOG if the Tree is and remains in the FROZEN state.
   * </pre>
   *
   * <code>.trillian.TreeType tree_type = 3;</code>
   * @param value The treeType to set.
   */
  private void setTreeType(google.trillian.proto.TreeType value) {
    treeType_ = value.getNumber();
    
  }
  /**
   * <pre>
   * Type of the tree.
   * Readonly after Tree creation. Exception: Can be switched from
   * PREORDERED_LOG to LOG if the Tree is and remains in the FROZEN state.
   * </pre>
   *
   * <code>.trillian.TreeType tree_type = 3;</code>
   */
  private void clearTreeType() {
    
    treeType_ = 0;
  }

  public static final int HASH_STRATEGY_FIELD_NUMBER = 4;
  private int hashStrategy_;
  /**
   * <pre>
   * Hash strategy to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.trillian.HashStrategy hash_strategy = 4;</code>
   * @return The enum numeric value on the wire for hashStrategy.
   */
  @java.lang.Override
  public int getHashStrategyValue() {
    return hashStrategy_;
  }
  /**
   * <pre>
   * Hash strategy to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.trillian.HashStrategy hash_strategy = 4;</code>
   * @return The hashStrategy.
   */
  @java.lang.Override
  public google.trillian.proto.HashStrategy getHashStrategy() {
    google.trillian.proto.HashStrategy result = google.trillian.proto.HashStrategy.forNumber(hashStrategy_);
    return result == null ? google.trillian.proto.HashStrategy.UNRECOGNIZED : result;
  }
  /**
   * <pre>
   * Hash strategy to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.trillian.HashStrategy hash_strategy = 4;</code>
   * @param value The enum numeric value on the wire for hashStrategy to set.
   */
  private void setHashStrategyValue(int value) {
      hashStrategy_ = value;
  }
  /**
   * <pre>
   * Hash strategy to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.trillian.HashStrategy hash_strategy = 4;</code>
   * @param value The hashStrategy to set.
   */
  private void setHashStrategy(google.trillian.proto.HashStrategy value) {
    hashStrategy_ = value.getNumber();
    
  }
  /**
   * <pre>
   * Hash strategy to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.trillian.HashStrategy hash_strategy = 4;</code>
   */
  private void clearHashStrategy() {
    
    hashStrategy_ = 0;
  }

  public static final int HASH_ALGORITHM_FIELD_NUMBER = 5;
  private int hashAlgorithm_;
  /**
   * <pre>
   * Hash algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.HashAlgorithm hash_algorithm = 5;</code>
   * @return The enum numeric value on the wire for hashAlgorithm.
   */
  @java.lang.Override
  public int getHashAlgorithmValue() {
    return hashAlgorithm_;
  }
  /**
   * <pre>
   * Hash algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.HashAlgorithm hash_algorithm = 5;</code>
   * @return The hashAlgorithm.
   */
  @java.lang.Override
  public google.trillian.sigpb.Sigpb.DigitallySigned.HashAlgorithm getHashAlgorithm() {
    google.trillian.sigpb.Sigpb.DigitallySigned.HashAlgorithm result = google.trillian.sigpb.Sigpb.DigitallySigned.HashAlgorithm.forNumber(hashAlgorithm_);
    return result == null ? google.trillian.sigpb.Sigpb.DigitallySigned.HashAlgorithm.UNRECOGNIZED : result;
  }
  /**
   * <pre>
   * Hash algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.HashAlgorithm hash_algorithm = 5;</code>
   * @param value The enum numeric value on the wire for hashAlgorithm to set.
   */
  private void setHashAlgorithmValue(int value) {
      hashAlgorithm_ = value;
  }
  /**
   * <pre>
   * Hash algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.HashAlgorithm hash_algorithm = 5;</code>
   * @param value The hashAlgorithm to set.
   */
  private void setHashAlgorithm(google.trillian.sigpb.Sigpb.DigitallySigned.HashAlgorithm value) {
    hashAlgorithm_ = value.getNumber();
    
  }
  /**
   * <pre>
   * Hash algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.HashAlgorithm hash_algorithm = 5;</code>
   */
  private void clearHashAlgorithm() {
    
    hashAlgorithm_ = 0;
  }

  public static final int SIGNATURE_ALGORITHM_FIELD_NUMBER = 6;
  private int signatureAlgorithm_;
  /**
   * <pre>
   * Signature algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.SignatureAlgorithm signature_algorithm = 6;</code>
   * @return The enum numeric value on the wire for signatureAlgorithm.
   */
  @java.lang.Override
  public int getSignatureAlgorithmValue() {
    return signatureAlgorithm_;
  }
  /**
   * <pre>
   * Signature algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.SignatureAlgorithm signature_algorithm = 6;</code>
   * @return The signatureAlgorithm.
   */
  @java.lang.Override
  public google.trillian.sigpb.Sigpb.DigitallySigned.SignatureAlgorithm getSignatureAlgorithm() {
    google.trillian.sigpb.Sigpb.DigitallySigned.SignatureAlgorithm result = google.trillian.sigpb.Sigpb.DigitallySigned.SignatureAlgorithm.forNumber(signatureAlgorithm_);
    return result == null ? google.trillian.sigpb.Sigpb.DigitallySigned.SignatureAlgorithm.UNRECOGNIZED : result;
  }
  /**
   * <pre>
   * Signature algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.SignatureAlgorithm signature_algorithm = 6;</code>
   * @param value The enum numeric value on the wire for signatureAlgorithm to set.
   */
  private void setSignatureAlgorithmValue(int value) {
      signatureAlgorithm_ = value;
  }
  /**
   * <pre>
   * Signature algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.SignatureAlgorithm signature_algorithm = 6;</code>
   * @param value The signatureAlgorithm to set.
   */
  private void setSignatureAlgorithm(google.trillian.sigpb.Sigpb.DigitallySigned.SignatureAlgorithm value) {
    signatureAlgorithm_ = value.getNumber();
    
  }
  /**
   * <pre>
   * Signature algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.SignatureAlgorithm signature_algorithm = 6;</code>
   */
  private void clearSignatureAlgorithm() {
    
    signatureAlgorithm_ = 0;
  }

  public static final int DISPLAY_NAME_FIELD_NUMBER = 8;
  private java.lang.String displayName_;
  /**
   * <pre>
   * Display name of the tree.
   * Optional.
   * </pre>
   *
   * <code>string display_name = 8;</code>
   * @return The displayName.
   */
  @java.lang.Override
  public java.lang.String getDisplayName() {
    return displayName_;
  }
  /**
   * <pre>
   * Display name of the tree.
   * Optional.
   * </pre>
   *
   * <code>string display_name = 8;</code>
   * @return The bytes for displayName.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getDisplayNameBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(displayName_);
  }
  /**
   * <pre>
   * Display name of the tree.
   * Optional.
   * </pre>
   *
   * <code>string display_name = 8;</code>
   * @param value The displayName to set.
   */
  private void setDisplayName(
      java.lang.String value) {
    value.getClass();
  
    displayName_ = value;
  }
  /**
   * <pre>
   * Display name of the tree.
   * Optional.
   * </pre>
   *
   * <code>string display_name = 8;</code>
   */
  private void clearDisplayName() {
    
    displayName_ = getDefaultInstance().getDisplayName();
  }
  /**
   * <pre>
   * Display name of the tree.
   * Optional.
   * </pre>
   *
   * <code>string display_name = 8;</code>
   * @param value The bytes for displayName to set.
   */
  private void setDisplayNameBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    displayName_ = value.toStringUtf8();
    
  }

  public static final int DESCRIPTION_FIELD_NUMBER = 9;
  private java.lang.String description_;
  /**
   * <pre>
   * Description of the tree,
   * Optional.
   * </pre>
   *
   * <code>string description = 9;</code>
   * @return The description.
   */
  @java.lang.Override
  public java.lang.String getDescription() {
    return description_;
  }
  /**
   * <pre>
   * Description of the tree,
   * Optional.
   * </pre>
   *
   * <code>string description = 9;</code>
   * @return The bytes for description.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString
      getDescriptionBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(description_);
  }
  /**
   * <pre>
   * Description of the tree,
   * Optional.
   * </pre>
   *
   * <code>string description = 9;</code>
   * @param value The description to set.
   */
  private void setDescription(
      java.lang.String value) {
    value.getClass();
  
    description_ = value;
  }
  /**
   * <pre>
   * Description of the tree,
   * Optional.
   * </pre>
   *
   * <code>string description = 9;</code>
   */
  private void clearDescription() {
    
    description_ = getDefaultInstance().getDescription();
  }
  /**
   * <pre>
   * Description of the tree,
   * Optional.
   * </pre>
   *
   * <code>string description = 9;</code>
   * @param value The bytes for description to set.
   */
  private void setDescriptionBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    description_ = value.toStringUtf8();
    
  }

  public static final int PRIVATE_KEY_FIELD_NUMBER = 12;
  private com.google.protobuf.Any privateKey_;
  /**
   * <pre>
   * Identifies the private key used for signing tree heads and entry
   * timestamps.
   * This can be any type of message to accommodate different key management
   * systems, e.g. PEM files, HSMs, etc.
   * Private keys are write-only: they're never returned by RPCs.
   * The private_key message can be changed after a tree is created, but the
   * underlying key must remain the same - this is to enable migrating a key
   * from one provider to another.
   * </pre>
   *
   * <code>.google.protobuf.Any private_key = 12;</code>
   */
  @java.lang.Override
  public boolean hasPrivateKey() {
    return privateKey_ != null;
  }
  /**
   * <pre>
   * Identifies the private key used for signing tree heads and entry
   * timestamps.
   * This can be any type of message to accommodate different key management
   * systems, e.g. PEM files, HSMs, etc.
   * Private keys are write-only: they're never returned by RPCs.
   * The private_key message can be changed after a tree is created, but the
   * underlying key must remain the same - this is to enable migrating a key
   * from one provider to another.
   * </pre>
   *
   * <code>.google.protobuf.Any private_key = 12;</code>
   */
  @java.lang.Override
  public com.google.protobuf.Any getPrivateKey() {
    return privateKey_ == null ? com.google.protobuf.Any.getDefaultInstance() : privateKey_;
  }
  /**
   * <pre>
   * Identifies the private key used for signing tree heads and entry
   * timestamps.
   * This can be any type of message to accommodate different key management
   * systems, e.g. PEM files, HSMs, etc.
   * Private keys are write-only: they're never returned by RPCs.
   * The private_key message can be changed after a tree is created, but the
   * underlying key must remain the same - this is to enable migrating a key
   * from one provider to another.
   * </pre>
   *
   * <code>.google.protobuf.Any private_key = 12;</code>
   */
  private void setPrivateKey(com.google.protobuf.Any value) {
    value.getClass();
  privateKey_ = value;
    
    }
  /**
   * <pre>
   * Identifies the private key used for signing tree heads and entry
   * timestamps.
   * This can be any type of message to accommodate different key management
   * systems, e.g. PEM files, HSMs, etc.
   * Private keys are write-only: they're never returned by RPCs.
   * The private_key message can be changed after a tree is created, but the
   * underlying key must remain the same - this is to enable migrating a key
   * from one provider to another.
   * </pre>
   *
   * <code>.google.protobuf.Any private_key = 12;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergePrivateKey(com.google.protobuf.Any value) {
    value.getClass();
  if (privateKey_ != null &&
        privateKey_ != com.google.protobuf.Any.getDefaultInstance()) {
      privateKey_ =
        com.google.protobuf.Any.newBuilder(privateKey_).mergeFrom(value).buildPartial();
    } else {
      privateKey_ = value;
    }
    
  }
  /**
   * <pre>
   * Identifies the private key used for signing tree heads and entry
   * timestamps.
   * This can be any type of message to accommodate different key management
   * systems, e.g. PEM files, HSMs, etc.
   * Private keys are write-only: they're never returned by RPCs.
   * The private_key message can be changed after a tree is created, but the
   * underlying key must remain the same - this is to enable migrating a key
   * from one provider to another.
   * </pre>
   *
   * <code>.google.protobuf.Any private_key = 12;</code>
   */
  private void clearPrivateKey() {  privateKey_ = null;
    
  }

  public static final int STORAGE_SETTINGS_FIELD_NUMBER = 13;
  private com.google.protobuf.Any storageSettings_;
  /**
   * <pre>
   * Storage-specific settings.
   * Varies according to the storage implementation backing Trillian.
   * </pre>
   *
   * <code>.google.protobuf.Any storage_settings = 13;</code>
   */
  @java.lang.Override
  public boolean hasStorageSettings() {
    return storageSettings_ != null;
  }
  /**
   * <pre>
   * Storage-specific settings.
   * Varies according to the storage implementation backing Trillian.
   * </pre>
   *
   * <code>.google.protobuf.Any storage_settings = 13;</code>
   */
  @java.lang.Override
  public com.google.protobuf.Any getStorageSettings() {
    return storageSettings_ == null ? com.google.protobuf.Any.getDefaultInstance() : storageSettings_;
  }
  /**
   * <pre>
   * Storage-specific settings.
   * Varies according to the storage implementation backing Trillian.
   * </pre>
   *
   * <code>.google.protobuf.Any storage_settings = 13;</code>
   */
  private void setStorageSettings(com.google.protobuf.Any value) {
    value.getClass();
  storageSettings_ = value;
    
    }
  /**
   * <pre>
   * Storage-specific settings.
   * Varies according to the storage implementation backing Trillian.
   * </pre>
   *
   * <code>.google.protobuf.Any storage_settings = 13;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeStorageSettings(com.google.protobuf.Any value) {
    value.getClass();
  if (storageSettings_ != null &&
        storageSettings_ != com.google.protobuf.Any.getDefaultInstance()) {
      storageSettings_ =
        com.google.protobuf.Any.newBuilder(storageSettings_).mergeFrom(value).buildPartial();
    } else {
      storageSettings_ = value;
    }
    
  }
  /**
   * <pre>
   * Storage-specific settings.
   * Varies according to the storage implementation backing Trillian.
   * </pre>
   *
   * <code>.google.protobuf.Any storage_settings = 13;</code>
   */
  private void clearStorageSettings() {  storageSettings_ = null;
    
  }

  public static final int PUBLIC_KEY_FIELD_NUMBER = 14;
  private google.trillian.keyspb.Keyspb.PublicKey publicKey_;
  /**
   * <pre>
   * The public key used for verifying tree heads and entry timestamps.
   * Readonly.
   * </pre>
   *
   * <code>.keyspb.PublicKey public_key = 14;</code>
   */
  @java.lang.Override
  public boolean hasPublicKey() {
    return publicKey_ != null;
  }
  /**
   * <pre>
   * The public key used for verifying tree heads and entry timestamps.
   * Readonly.
   * </pre>
   *
   * <code>.keyspb.PublicKey public_key = 14;</code>
   */
  @java.lang.Override
  public google.trillian.keyspb.Keyspb.PublicKey getPublicKey() {
    return publicKey_ == null ? google.trillian.keyspb.Keyspb.PublicKey.getDefaultInstance() : publicKey_;
  }
  /**
   * <pre>
   * The public key used for verifying tree heads and entry timestamps.
   * Readonly.
   * </pre>
   *
   * <code>.keyspb.PublicKey public_key = 14;</code>
   */
  private void setPublicKey(google.trillian.keyspb.Keyspb.PublicKey value) {
    value.getClass();
  publicKey_ = value;
    
    }
  /**
   * <pre>
   * The public key used for verifying tree heads and entry timestamps.
   * Readonly.
   * </pre>
   *
   * <code>.keyspb.PublicKey public_key = 14;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergePublicKey(google.trillian.keyspb.Keyspb.PublicKey value) {
    value.getClass();
  if (publicKey_ != null &&
        publicKey_ != google.trillian.keyspb.Keyspb.PublicKey.getDefaultInstance()) {
      publicKey_ =
        google.trillian.keyspb.Keyspb.PublicKey.newBuilder(publicKey_).mergeFrom(value).buildPartial();
    } else {
      publicKey_ = value;
    }
    
  }
  /**
   * <pre>
   * The public key used for verifying tree heads and entry timestamps.
   * Readonly.
   * </pre>
   *
   * <code>.keyspb.PublicKey public_key = 14;</code>
   */
  private void clearPublicKey() {  publicKey_ = null;
    
  }

  public static final int MAX_ROOT_DURATION_FIELD_NUMBER = 15;
  private com.google.protobuf.Duration maxRootDuration_;
  /**
   * <pre>
   * Interval after which a new signed root is produced even if there have been
   * no submission.  If zero, this behavior is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_root_duration = 15;</code>
   */
  @java.lang.Override
  public boolean hasMaxRootDuration() {
    return maxRootDuration_ != null;
  }
  /**
   * <pre>
   * Interval after which a new signed root is produced even if there have been
   * no submission.  If zero, this behavior is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_root_duration = 15;</code>
   */
  @java.lang.Override
  public com.google.protobuf.Duration getMaxRootDuration() {
    return maxRootDuration_ == null ? com.google.protobuf.Duration.getDefaultInstance() : maxRootDuration_;
  }
  /**
   * <pre>
   * Interval after which a new signed root is produced even if there have been
   * no submission.  If zero, this behavior is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_root_duration = 15;</code>
   */
  private void setMaxRootDuration(com.google.protobuf.Duration value) {
    value.getClass();
  maxRootDuration_ = value;
    
    }
  /**
   * <pre>
   * Interval after which a new signed root is produced even if there have been
   * no submission.  If zero, this behavior is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_root_duration = 15;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeMaxRootDuration(com.google.protobuf.Duration value) {
    value.getClass();
  if (maxRootDuration_ != null &&
        maxRootDuration_ != com.google.protobuf.Duration.getDefaultInstance()) {
      maxRootDuration_ =
        com.google.protobuf.Duration.newBuilder(maxRootDuration_).mergeFrom(value).buildPartial();
    } else {
      maxRootDuration_ = value;
    }
    
  }
  /**
   * <pre>
   * Interval after which a new signed root is produced even if there have been
   * no submission.  If zero, this behavior is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_root_duration = 15;</code>
   */
  private void clearMaxRootDuration() {  maxRootDuration_ = null;
    
  }

  public static final int CREATE_TIME_FIELD_NUMBER = 16;
  private com.google.protobuf.Timestamp createTime_;
  /**
   * <pre>
   * Time of tree creation.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp create_time = 16;</code>
   */
  @java.lang.Override
  public boolean hasCreateTime() {
    return createTime_ != null;
  }
  /**
   * <pre>
   * Time of tree creation.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp create_time = 16;</code>
   */
  @java.lang.Override
  public com.google.protobuf.Timestamp getCreateTime() {
    return createTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : createTime_;
  }
  /**
   * <pre>
   * Time of tree creation.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp create_time = 16;</code>
   */
  private void setCreateTime(com.google.protobuf.Timestamp value) {
    value.getClass();
  createTime_ = value;
    
    }
  /**
   * <pre>
   * Time of tree creation.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp create_time = 16;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeCreateTime(com.google.protobuf.Timestamp value) {
    value.getClass();
  if (createTime_ != null &&
        createTime_ != com.google.protobuf.Timestamp.getDefaultInstance()) {
      createTime_ =
        com.google.protobuf.Timestamp.newBuilder(createTime_).mergeFrom(value).buildPartial();
    } else {
      createTime_ = value;
    }
    
  }
  /**
   * <pre>
   * Time of tree creation.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp create_time = 16;</code>
   */
  private void clearCreateTime() {  createTime_ = null;
    
  }

  public static final int UPDATE_TIME_FIELD_NUMBER = 17;
  private com.google.protobuf.Timestamp updateTime_;
  /**
   * <pre>
   * Time of last tree update.
   * Readonly (automatically assigned on updates).
   * </pre>
   *
   * <code>.google.protobuf.Timestamp update_time = 17;</code>
   */
  @java.lang.Override
  public boolean hasUpdateTime() {
    return updateTime_ != null;
  }
  /**
   * <pre>
   * Time of last tree update.
   * Readonly (automatically assigned on updates).
   * </pre>
   *
   * <code>.google.protobuf.Timestamp update_time = 17;</code>
   */
  @java.lang.Override
  public com.google.protobuf.Timestamp getUpdateTime() {
    return updateTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : updateTime_;
  }
  /**
   * <pre>
   * Time of last tree update.
   * Readonly (automatically assigned on updates).
   * </pre>
   *
   * <code>.google.protobuf.Timestamp update_time = 17;</code>
   */
  private void setUpdateTime(com.google.protobuf.Timestamp value) {
    value.getClass();
  updateTime_ = value;
    
    }
  /**
   * <pre>
   * Time of last tree update.
   * Readonly (automatically assigned on updates).
   * </pre>
   *
   * <code>.google.protobuf.Timestamp update_time = 17;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeUpdateTime(com.google.protobuf.Timestamp value) {
    value.getClass();
  if (updateTime_ != null &&
        updateTime_ != com.google.protobuf.Timestamp.getDefaultInstance()) {
      updateTime_ =
        com.google.protobuf.Timestamp.newBuilder(updateTime_).mergeFrom(value).buildPartial();
    } else {
      updateTime_ = value;
    }
    
  }
  /**
   * <pre>
   * Time of last tree update.
   * Readonly (automatically assigned on updates).
   * </pre>
   *
   * <code>.google.protobuf.Timestamp update_time = 17;</code>
   */
  private void clearUpdateTime() {  updateTime_ = null;
    
  }

  public static final int DELETED_FIELD_NUMBER = 19;
  private boolean deleted_;
  /**
   * <pre>
   * If true, the tree has been deleted.
   * Deleted trees may be undeleted during a certain time window, after which
   * they're permanently deleted (and unrecoverable).
   * Readonly.
   * </pre>
   *
   * <code>bool deleted = 19;</code>
   * @return The deleted.
   */
  @java.lang.Override
  public boolean getDeleted() {
    return deleted_;
  }
  /**
   * <pre>
   * If true, the tree has been deleted.
   * Deleted trees may be undeleted during a certain time window, after which
   * they're permanently deleted (and unrecoverable).
   * Readonly.
   * </pre>
   *
   * <code>bool deleted = 19;</code>
   * @param value The deleted to set.
   */
  private void setDeleted(boolean value) {
    
    deleted_ = value;
  }
  /**
   * <pre>
   * If true, the tree has been deleted.
   * Deleted trees may be undeleted during a certain time window, after which
   * they're permanently deleted (and unrecoverable).
   * Readonly.
   * </pre>
   *
   * <code>bool deleted = 19;</code>
   */
  private void clearDeleted() {
    
    deleted_ = false;
  }

  public static final int DELETE_TIME_FIELD_NUMBER = 20;
  private com.google.protobuf.Timestamp deleteTime_;
  /**
   * <pre>
   * Time of tree deletion, if any.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp delete_time = 20;</code>
   */
  @java.lang.Override
  public boolean hasDeleteTime() {
    return deleteTime_ != null;
  }
  /**
   * <pre>
   * Time of tree deletion, if any.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp delete_time = 20;</code>
   */
  @java.lang.Override
  public com.google.protobuf.Timestamp getDeleteTime() {
    return deleteTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : deleteTime_;
  }
  /**
   * <pre>
   * Time of tree deletion, if any.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp delete_time = 20;</code>
   */
  private void setDeleteTime(com.google.protobuf.Timestamp value) {
    value.getClass();
  deleteTime_ = value;
    
    }
  /**
   * <pre>
   * Time of tree deletion, if any.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp delete_time = 20;</code>
   */
  @java.lang.SuppressWarnings({"ReferenceEquality"})
  private void mergeDeleteTime(com.google.protobuf.Timestamp value) {
    value.getClass();
  if (deleteTime_ != null &&
        deleteTime_ != com.google.protobuf.Timestamp.getDefaultInstance()) {
      deleteTime_ =
        com.google.protobuf.Timestamp.newBuilder(deleteTime_).mergeFrom(value).buildPartial();
    } else {
      deleteTime_ = value;
    }
    
  }
  /**
   * <pre>
   * Time of tree deletion, if any.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp delete_time = 20;</code>
   */
  private void clearDeleteTime() {  deleteTime_ = null;
    
  }

  public static google.trillian.proto.Tree parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static google.trillian.proto.Tree parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static google.trillian.proto.Tree parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static google.trillian.proto.Tree parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static google.trillian.proto.Tree parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static google.trillian.proto.Tree parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static google.trillian.proto.Tree parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static google.trillian.proto.Tree parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static google.trillian.proto.Tree parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static google.trillian.proto.Tree parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static google.trillian.proto.Tree parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static google.trillian.proto.Tree parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(google.trillian.proto.Tree prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   * Represents a tree, which may be either a verifiable log or map.
   * Readonly attributes are assigned at tree creation, after which they may not
   * be modified.
   * Note: Many APIs within the rest of the code require these objects to
   * be provided. For safety they should be obtained via Admin API calls and
   * not created dynamically.
   * </pre>
   *
   * Protobuf type {@code trillian.Tree}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        google.trillian.proto.Tree, Builder> implements
      // @@protoc_insertion_point(builder_implements:trillian.Tree)
      google.trillian.proto.TreeOrBuilder {
    // Construct using google.trillian.proto.Tree.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * ID of the tree.
     * Readonly.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     * @return The treeId.
     */
    @java.lang.Override
    public long getTreeId() {
      return instance.getTreeId();
    }
    /**
     * <pre>
     * ID of the tree.
     * Readonly.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     * @param value The treeId to set.
     * @return This builder for chaining.
     */
    public Builder setTreeId(long value) {
      copyOnWrite();
      instance.setTreeId(value);
      return this;
    }
    /**
     * <pre>
     * ID of the tree.
     * Readonly.
     * </pre>
     *
     * <code>int64 tree_id = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearTreeId() {
      copyOnWrite();
      instance.clearTreeId();
      return this;
    }

    /**
     * <pre>
     * State of the tree.
     * Trees are ACTIVE after creation. At any point the tree may transition
     * between ACTIVE, DRAINING and FROZEN states.
     * </pre>
     *
     * <code>.trillian.TreeState tree_state = 2;</code>
     * @return The enum numeric value on the wire for treeState.
     */
    @java.lang.Override
    public int getTreeStateValue() {
      return instance.getTreeStateValue();
    }
    /**
     * <pre>
     * State of the tree.
     * Trees are ACTIVE after creation. At any point the tree may transition
     * between ACTIVE, DRAINING and FROZEN states.
     * </pre>
     *
     * <code>.trillian.TreeState tree_state = 2;</code>
     * @param value The treeState to set.
     * @return This builder for chaining.
     */
    public Builder setTreeStateValue(int value) {
      copyOnWrite();
      instance.setTreeStateValue(value);
      return this;
    }
    /**
     * <pre>
     * State of the tree.
     * Trees are ACTIVE after creation. At any point the tree may transition
     * between ACTIVE, DRAINING and FROZEN states.
     * </pre>
     *
     * <code>.trillian.TreeState tree_state = 2;</code>
     * @return The treeState.
     */
    @java.lang.Override
    public google.trillian.proto.TreeState getTreeState() {
      return instance.getTreeState();
    }
    /**
     * <pre>
     * State of the tree.
     * Trees are ACTIVE after creation. At any point the tree may transition
     * between ACTIVE, DRAINING and FROZEN states.
     * </pre>
     *
     * <code>.trillian.TreeState tree_state = 2;</code>
     * @param value The enum numeric value on the wire for treeState to set.
     * @return This builder for chaining.
     */
    public Builder setTreeState(google.trillian.proto.TreeState value) {
      copyOnWrite();
      instance.setTreeState(value);
      return this;
    }
    /**
     * <pre>
     * State of the tree.
     * Trees are ACTIVE after creation. At any point the tree may transition
     * between ACTIVE, DRAINING and FROZEN states.
     * </pre>
     *
     * <code>.trillian.TreeState tree_state = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearTreeState() {
      copyOnWrite();
      instance.clearTreeState();
      return this;
    }

    /**
     * <pre>
     * Type of the tree.
     * Readonly after Tree creation. Exception: Can be switched from
     * PREORDERED_LOG to LOG if the Tree is and remains in the FROZEN state.
     * </pre>
     *
     * <code>.trillian.TreeType tree_type = 3;</code>
     * @return The enum numeric value on the wire for treeType.
     */
    @java.lang.Override
    public int getTreeTypeValue() {
      return instance.getTreeTypeValue();
    }
    /**
     * <pre>
     * Type of the tree.
     * Readonly after Tree creation. Exception: Can be switched from
     * PREORDERED_LOG to LOG if the Tree is and remains in the FROZEN state.
     * </pre>
     *
     * <code>.trillian.TreeType tree_type = 3;</code>
     * @param value The treeType to set.
     * @return This builder for chaining.
     */
    public Builder setTreeTypeValue(int value) {
      copyOnWrite();
      instance.setTreeTypeValue(value);
      return this;
    }
    /**
     * <pre>
     * Type of the tree.
     * Readonly after Tree creation. Exception: Can be switched from
     * PREORDERED_LOG to LOG if the Tree is and remains in the FROZEN state.
     * </pre>
     *
     * <code>.trillian.TreeType tree_type = 3;</code>
     * @return The treeType.
     */
    @java.lang.Override
    public google.trillian.proto.TreeType getTreeType() {
      return instance.getTreeType();
    }
    /**
     * <pre>
     * Type of the tree.
     * Readonly after Tree creation. Exception: Can be switched from
     * PREORDERED_LOG to LOG if the Tree is and remains in the FROZEN state.
     * </pre>
     *
     * <code>.trillian.TreeType tree_type = 3;</code>
     * @param value The enum numeric value on the wire for treeType to set.
     * @return This builder for chaining.
     */
    public Builder setTreeType(google.trillian.proto.TreeType value) {
      copyOnWrite();
      instance.setTreeType(value);
      return this;
    }
    /**
     * <pre>
     * Type of the tree.
     * Readonly after Tree creation. Exception: Can be switched from
     * PREORDERED_LOG to LOG if the Tree is and remains in the FROZEN state.
     * </pre>
     *
     * <code>.trillian.TreeType tree_type = 3;</code>
     * @return This builder for chaining.
     */
    public Builder clearTreeType() {
      copyOnWrite();
      instance.clearTreeType();
      return this;
    }

    /**
     * <pre>
     * Hash strategy to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.trillian.HashStrategy hash_strategy = 4;</code>
     * @return The enum numeric value on the wire for hashStrategy.
     */
    @java.lang.Override
    public int getHashStrategyValue() {
      return instance.getHashStrategyValue();
    }
    /**
     * <pre>
     * Hash strategy to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.trillian.HashStrategy hash_strategy = 4;</code>
     * @param value The hashStrategy to set.
     * @return This builder for chaining.
     */
    public Builder setHashStrategyValue(int value) {
      copyOnWrite();
      instance.setHashStrategyValue(value);
      return this;
    }
    /**
     * <pre>
     * Hash strategy to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.trillian.HashStrategy hash_strategy = 4;</code>
     * @return The hashStrategy.
     */
    @java.lang.Override
    public google.trillian.proto.HashStrategy getHashStrategy() {
      return instance.getHashStrategy();
    }
    /**
     * <pre>
     * Hash strategy to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.trillian.HashStrategy hash_strategy = 4;</code>
     * @param value The enum numeric value on the wire for hashStrategy to set.
     * @return This builder for chaining.
     */
    public Builder setHashStrategy(google.trillian.proto.HashStrategy value) {
      copyOnWrite();
      instance.setHashStrategy(value);
      return this;
    }
    /**
     * <pre>
     * Hash strategy to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.trillian.HashStrategy hash_strategy = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearHashStrategy() {
      copyOnWrite();
      instance.clearHashStrategy();
      return this;
    }

    /**
     * <pre>
     * Hash algorithm to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.sigpb.DigitallySigned.HashAlgorithm hash_algorithm = 5;</code>
     * @return The enum numeric value on the wire for hashAlgorithm.
     */
    @java.lang.Override
    public int getHashAlgorithmValue() {
      return instance.getHashAlgorithmValue();
    }
    /**
     * <pre>
     * Hash algorithm to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.sigpb.DigitallySigned.HashAlgorithm hash_algorithm = 5;</code>
     * @param value The hashAlgorithm to set.
     * @return This builder for chaining.
     */
    public Builder setHashAlgorithmValue(int value) {
      copyOnWrite();
      instance.setHashAlgorithmValue(value);
      return this;
    }
    /**
     * <pre>
     * Hash algorithm to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.sigpb.DigitallySigned.HashAlgorithm hash_algorithm = 5;</code>
     * @return The hashAlgorithm.
     */
    @java.lang.Override
    public google.trillian.sigpb.Sigpb.DigitallySigned.HashAlgorithm getHashAlgorithm() {
      return instance.getHashAlgorithm();
    }
    /**
     * <pre>
     * Hash algorithm to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.sigpb.DigitallySigned.HashAlgorithm hash_algorithm = 5;</code>
     * @param value The enum numeric value on the wire for hashAlgorithm to set.
     * @return This builder for chaining.
     */
    public Builder setHashAlgorithm(google.trillian.sigpb.Sigpb.DigitallySigned.HashAlgorithm value) {
      copyOnWrite();
      instance.setHashAlgorithm(value);
      return this;
    }
    /**
     * <pre>
     * Hash algorithm to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.sigpb.DigitallySigned.HashAlgorithm hash_algorithm = 5;</code>
     * @return This builder for chaining.
     */
    public Builder clearHashAlgorithm() {
      copyOnWrite();
      instance.clearHashAlgorithm();
      return this;
    }

    /**
     * <pre>
     * Signature algorithm to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.sigpb.DigitallySigned.SignatureAlgorithm signature_algorithm = 6;</code>
     * @return The enum numeric value on the wire for signatureAlgorithm.
     */
    @java.lang.Override
    public int getSignatureAlgorithmValue() {
      return instance.getSignatureAlgorithmValue();
    }
    /**
     * <pre>
     * Signature algorithm to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.sigpb.DigitallySigned.SignatureAlgorithm signature_algorithm = 6;</code>
     * @param value The signatureAlgorithm to set.
     * @return This builder for chaining.
     */
    public Builder setSignatureAlgorithmValue(int value) {
      copyOnWrite();
      instance.setSignatureAlgorithmValue(value);
      return this;
    }
    /**
     * <pre>
     * Signature algorithm to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.sigpb.DigitallySigned.SignatureAlgorithm signature_algorithm = 6;</code>
     * @return The signatureAlgorithm.
     */
    @java.lang.Override
    public google.trillian.sigpb.Sigpb.DigitallySigned.SignatureAlgorithm getSignatureAlgorithm() {
      return instance.getSignatureAlgorithm();
    }
    /**
     * <pre>
     * Signature algorithm to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.sigpb.DigitallySigned.SignatureAlgorithm signature_algorithm = 6;</code>
     * @param value The enum numeric value on the wire for signatureAlgorithm to set.
     * @return This builder for chaining.
     */
    public Builder setSignatureAlgorithm(google.trillian.sigpb.Sigpb.DigitallySigned.SignatureAlgorithm value) {
      copyOnWrite();
      instance.setSignatureAlgorithm(value);
      return this;
    }
    /**
     * <pre>
     * Signature algorithm to be used by the tree.
     * Readonly.
     * </pre>
     *
     * <code>.sigpb.DigitallySigned.SignatureAlgorithm signature_algorithm = 6;</code>
     * @return This builder for chaining.
     */
    public Builder clearSignatureAlgorithm() {
      copyOnWrite();
      instance.clearSignatureAlgorithm();
      return this;
    }

    /**
     * <pre>
     * Display name of the tree.
     * Optional.
     * </pre>
     *
     * <code>string display_name = 8;</code>
     * @return The displayName.
     */
    @java.lang.Override
    public java.lang.String getDisplayName() {
      return instance.getDisplayName();
    }
    /**
     * <pre>
     * Display name of the tree.
     * Optional.
     * </pre>
     *
     * <code>string display_name = 8;</code>
     * @return The bytes for displayName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDisplayNameBytes() {
      return instance.getDisplayNameBytes();
    }
    /**
     * <pre>
     * Display name of the tree.
     * Optional.
     * </pre>
     *
     * <code>string display_name = 8;</code>
     * @param value The displayName to set.
     * @return This builder for chaining.
     */
    public Builder setDisplayName(
        java.lang.String value) {
      copyOnWrite();
      instance.setDisplayName(value);
      return this;
    }
    /**
     * <pre>
     * Display name of the tree.
     * Optional.
     * </pre>
     *
     * <code>string display_name = 8;</code>
     * @return This builder for chaining.
     */
    public Builder clearDisplayName() {
      copyOnWrite();
      instance.clearDisplayName();
      return this;
    }
    /**
     * <pre>
     * Display name of the tree.
     * Optional.
     * </pre>
     *
     * <code>string display_name = 8;</code>
     * @param value The bytes for displayName to set.
     * @return This builder for chaining.
     */
    public Builder setDisplayNameBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setDisplayNameBytes(value);
      return this;
    }

    /**
     * <pre>
     * Description of the tree,
     * Optional.
     * </pre>
     *
     * <code>string description = 9;</code>
     * @return The description.
     */
    @java.lang.Override
    public java.lang.String getDescription() {
      return instance.getDescription();
    }
    /**
     * <pre>
     * Description of the tree,
     * Optional.
     * </pre>
     *
     * <code>string description = 9;</code>
     * @return The bytes for description.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDescriptionBytes() {
      return instance.getDescriptionBytes();
    }
    /**
     * <pre>
     * Description of the tree,
     * Optional.
     * </pre>
     *
     * <code>string description = 9;</code>
     * @param value The description to set.
     * @return This builder for chaining.
     */
    public Builder setDescription(
        java.lang.String value) {
      copyOnWrite();
      instance.setDescription(value);
      return this;
    }
    /**
     * <pre>
     * Description of the tree,
     * Optional.
     * </pre>
     *
     * <code>string description = 9;</code>
     * @return This builder for chaining.
     */
    public Builder clearDescription() {
      copyOnWrite();
      instance.clearDescription();
      return this;
    }
    /**
     * <pre>
     * Description of the tree,
     * Optional.
     * </pre>
     *
     * <code>string description = 9;</code>
     * @param value The bytes for description to set.
     * @return This builder for chaining.
     */
    public Builder setDescriptionBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setDescriptionBytes(value);
      return this;
    }

    /**
     * <pre>
     * Identifies the private key used for signing tree heads and entry
     * timestamps.
     * This can be any type of message to accommodate different key management
     * systems, e.g. PEM files, HSMs, etc.
     * Private keys are write-only: they're never returned by RPCs.
     * The private_key message can be changed after a tree is created, but the
     * underlying key must remain the same - this is to enable migrating a key
     * from one provider to another.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 12;</code>
     */
    @java.lang.Override
    public boolean hasPrivateKey() {
      return instance.hasPrivateKey();
    }
    /**
     * <pre>
     * Identifies the private key used for signing tree heads and entry
     * timestamps.
     * This can be any type of message to accommodate different key management
     * systems, e.g. PEM files, HSMs, etc.
     * Private keys are write-only: they're never returned by RPCs.
     * The private_key message can be changed after a tree is created, but the
     * underlying key must remain the same - this is to enable migrating a key
     * from one provider to another.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 12;</code>
     */
    @java.lang.Override
    public com.google.protobuf.Any getPrivateKey() {
      return instance.getPrivateKey();
    }
    /**
     * <pre>
     * Identifies the private key used for signing tree heads and entry
     * timestamps.
     * This can be any type of message to accommodate different key management
     * systems, e.g. PEM files, HSMs, etc.
     * Private keys are write-only: they're never returned by RPCs.
     * The private_key message can be changed after a tree is created, but the
     * underlying key must remain the same - this is to enable migrating a key
     * from one provider to another.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 12;</code>
     */
    public Builder setPrivateKey(com.google.protobuf.Any value) {
      copyOnWrite();
      instance.setPrivateKey(value);
      return this;
      }
    /**
     * <pre>
     * Identifies the private key used for signing tree heads and entry
     * timestamps.
     * This can be any type of message to accommodate different key management
     * systems, e.g. PEM files, HSMs, etc.
     * Private keys are write-only: they're never returned by RPCs.
     * The private_key message can be changed after a tree is created, but the
     * underlying key must remain the same - this is to enable migrating a key
     * from one provider to another.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 12;</code>
     */
    public Builder setPrivateKey(
        com.google.protobuf.Any.Builder builderForValue) {
      copyOnWrite();
      instance.setPrivateKey(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Identifies the private key used for signing tree heads and entry
     * timestamps.
     * This can be any type of message to accommodate different key management
     * systems, e.g. PEM files, HSMs, etc.
     * Private keys are write-only: they're never returned by RPCs.
     * The private_key message can be changed after a tree is created, but the
     * underlying key must remain the same - this is to enable migrating a key
     * from one provider to another.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 12;</code>
     */
    public Builder mergePrivateKey(com.google.protobuf.Any value) {
      copyOnWrite();
      instance.mergePrivateKey(value);
      return this;
    }
    /**
     * <pre>
     * Identifies the private key used for signing tree heads and entry
     * timestamps.
     * This can be any type of message to accommodate different key management
     * systems, e.g. PEM files, HSMs, etc.
     * Private keys are write-only: they're never returned by RPCs.
     * The private_key message can be changed after a tree is created, but the
     * underlying key must remain the same - this is to enable migrating a key
     * from one provider to another.
     * </pre>
     *
     * <code>.google.protobuf.Any private_key = 12;</code>
     */
    public Builder clearPrivateKey() {  copyOnWrite();
      instance.clearPrivateKey();
      return this;
    }

    /**
     * <pre>
     * Storage-specific settings.
     * Varies according to the storage implementation backing Trillian.
     * </pre>
     *
     * <code>.google.protobuf.Any storage_settings = 13;</code>
     */
    @java.lang.Override
    public boolean hasStorageSettings() {
      return instance.hasStorageSettings();
    }
    /**
     * <pre>
     * Storage-specific settings.
     * Varies according to the storage implementation backing Trillian.
     * </pre>
     *
     * <code>.google.protobuf.Any storage_settings = 13;</code>
     */
    @java.lang.Override
    public com.google.protobuf.Any getStorageSettings() {
      return instance.getStorageSettings();
    }
    /**
     * <pre>
     * Storage-specific settings.
     * Varies according to the storage implementation backing Trillian.
     * </pre>
     *
     * <code>.google.protobuf.Any storage_settings = 13;</code>
     */
    public Builder setStorageSettings(com.google.protobuf.Any value) {
      copyOnWrite();
      instance.setStorageSettings(value);
      return this;
      }
    /**
     * <pre>
     * Storage-specific settings.
     * Varies according to the storage implementation backing Trillian.
     * </pre>
     *
     * <code>.google.protobuf.Any storage_settings = 13;</code>
     */
    public Builder setStorageSettings(
        com.google.protobuf.Any.Builder builderForValue) {
      copyOnWrite();
      instance.setStorageSettings(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Storage-specific settings.
     * Varies according to the storage implementation backing Trillian.
     * </pre>
     *
     * <code>.google.protobuf.Any storage_settings = 13;</code>
     */
    public Builder mergeStorageSettings(com.google.protobuf.Any value) {
      copyOnWrite();
      instance.mergeStorageSettings(value);
      return this;
    }
    /**
     * <pre>
     * Storage-specific settings.
     * Varies according to the storage implementation backing Trillian.
     * </pre>
     *
     * <code>.google.protobuf.Any storage_settings = 13;</code>
     */
    public Builder clearStorageSettings() {  copyOnWrite();
      instance.clearStorageSettings();
      return this;
    }

    /**
     * <pre>
     * The public key used for verifying tree heads and entry timestamps.
     * Readonly.
     * </pre>
     *
     * <code>.keyspb.PublicKey public_key = 14;</code>
     */
    @java.lang.Override
    public boolean hasPublicKey() {
      return instance.hasPublicKey();
    }
    /**
     * <pre>
     * The public key used for verifying tree heads and entry timestamps.
     * Readonly.
     * </pre>
     *
     * <code>.keyspb.PublicKey public_key = 14;</code>
     */
    @java.lang.Override
    public google.trillian.keyspb.Keyspb.PublicKey getPublicKey() {
      return instance.getPublicKey();
    }
    /**
     * <pre>
     * The public key used for verifying tree heads and entry timestamps.
     * Readonly.
     * </pre>
     *
     * <code>.keyspb.PublicKey public_key = 14;</code>
     */
    public Builder setPublicKey(google.trillian.keyspb.Keyspb.PublicKey value) {
      copyOnWrite();
      instance.setPublicKey(value);
      return this;
      }
    /**
     * <pre>
     * The public key used for verifying tree heads and entry timestamps.
     * Readonly.
     * </pre>
     *
     * <code>.keyspb.PublicKey public_key = 14;</code>
     */
    public Builder setPublicKey(
        google.trillian.keyspb.Keyspb.PublicKey.Builder builderForValue) {
      copyOnWrite();
      instance.setPublicKey(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The public key used for verifying tree heads and entry timestamps.
     * Readonly.
     * </pre>
     *
     * <code>.keyspb.PublicKey public_key = 14;</code>
     */
    public Builder mergePublicKey(google.trillian.keyspb.Keyspb.PublicKey value) {
      copyOnWrite();
      instance.mergePublicKey(value);
      return this;
    }
    /**
     * <pre>
     * The public key used for verifying tree heads and entry timestamps.
     * Readonly.
     * </pre>
     *
     * <code>.keyspb.PublicKey public_key = 14;</code>
     */
    public Builder clearPublicKey() {  copyOnWrite();
      instance.clearPublicKey();
      return this;
    }

    /**
     * <pre>
     * Interval after which a new signed root is produced even if there have been
     * no submission.  If zero, this behavior is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_root_duration = 15;</code>
     */
    @java.lang.Override
    public boolean hasMaxRootDuration() {
      return instance.hasMaxRootDuration();
    }
    /**
     * <pre>
     * Interval after which a new signed root is produced even if there have been
     * no submission.  If zero, this behavior is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_root_duration = 15;</code>
     */
    @java.lang.Override
    public com.google.protobuf.Duration getMaxRootDuration() {
      return instance.getMaxRootDuration();
    }
    /**
     * <pre>
     * Interval after which a new signed root is produced even if there have been
     * no submission.  If zero, this behavior is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_root_duration = 15;</code>
     */
    public Builder setMaxRootDuration(com.google.protobuf.Duration value) {
      copyOnWrite();
      instance.setMaxRootDuration(value);
      return this;
      }
    /**
     * <pre>
     * Interval after which a new signed root is produced even if there have been
     * no submission.  If zero, this behavior is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_root_duration = 15;</code>
     */
    public Builder setMaxRootDuration(
        com.google.protobuf.Duration.Builder builderForValue) {
      copyOnWrite();
      instance.setMaxRootDuration(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Interval after which a new signed root is produced even if there have been
     * no submission.  If zero, this behavior is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_root_duration = 15;</code>
     */
    public Builder mergeMaxRootDuration(com.google.protobuf.Duration value) {
      copyOnWrite();
      instance.mergeMaxRootDuration(value);
      return this;
    }
    /**
     * <pre>
     * Interval after which a new signed root is produced even if there have been
     * no submission.  If zero, this behavior is disabled.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_root_duration = 15;</code>
     */
    public Builder clearMaxRootDuration() {  copyOnWrite();
      instance.clearMaxRootDuration();
      return this;
    }

    /**
     * <pre>
     * Time of tree creation.
     * Readonly.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp create_time = 16;</code>
     */
    @java.lang.Override
    public boolean hasCreateTime() {
      return instance.hasCreateTime();
    }
    /**
     * <pre>
     * Time of tree creation.
     * Readonly.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp create_time = 16;</code>
     */
    @java.lang.Override
    public com.google.protobuf.Timestamp getCreateTime() {
      return instance.getCreateTime();
    }
    /**
     * <pre>
     * Time of tree creation.
     * Readonly.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp create_time = 16;</code>
     */
    public Builder setCreateTime(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.setCreateTime(value);
      return this;
      }
    /**
     * <pre>
     * Time of tree creation.
     * Readonly.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp create_time = 16;</code>
     */
    public Builder setCreateTime(
        com.google.protobuf.Timestamp.Builder builderForValue) {
      copyOnWrite();
      instance.setCreateTime(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Time of tree creation.
     * Readonly.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp create_time = 16;</code>
     */
    public Builder mergeCreateTime(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.mergeCreateTime(value);
      return this;
    }
    /**
     * <pre>
     * Time of tree creation.
     * Readonly.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp create_time = 16;</code>
     */
    public Builder clearCreateTime() {  copyOnWrite();
      instance.clearCreateTime();
      return this;
    }

    /**
     * <pre>
     * Time of last tree update.
     * Readonly (automatically assigned on updates).
     * </pre>
     *
     * <code>.google.protobuf.Timestamp update_time = 17;</code>
     */
    @java.lang.Override
    public boolean hasUpdateTime() {
      return instance.hasUpdateTime();
    }
    /**
     * <pre>
     * Time of last tree update.
     * Readonly (automatically assigned on updates).
     * </pre>
     *
     * <code>.google.protobuf.Timestamp update_time = 17;</code>
     */
    @java.lang.Override
    public com.google.protobuf.Timestamp getUpdateTime() {
      return instance.getUpdateTime();
    }
    /**
     * <pre>
     * Time of last tree update.
     * Readonly (automatically assigned on updates).
     * </pre>
     *
     * <code>.google.protobuf.Timestamp update_time = 17;</code>
     */
    public Builder setUpdateTime(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.setUpdateTime(value);
      return this;
      }
    /**
     * <pre>
     * Time of last tree update.
     * Readonly (automatically assigned on updates).
     * </pre>
     *
     * <code>.google.protobuf.Timestamp update_time = 17;</code>
     */
    public Builder setUpdateTime(
        com.google.protobuf.Timestamp.Builder builderForValue) {
      copyOnWrite();
      instance.setUpdateTime(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Time of last tree update.
     * Readonly (automatically assigned on updates).
     * </pre>
     *
     * <code>.google.protobuf.Timestamp update_time = 17;</code>
     */
    public Builder mergeUpdateTime(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.mergeUpdateTime(value);
      return this;
    }
    /**
     * <pre>
     * Time of last tree update.
     * Readonly (automatically assigned on updates).
     * </pre>
     *
     * <code>.google.protobuf.Timestamp update_time = 17;</code>
     */
    public Builder clearUpdateTime() {  copyOnWrite();
      instance.clearUpdateTime();
      return this;
    }

    /**
     * <pre>
     * If true, the tree has been deleted.
     * Deleted trees may be undeleted during a certain time window, after which
     * they're permanently deleted (and unrecoverable).
     * Readonly.
     * </pre>
     *
     * <code>bool deleted = 19;</code>
     * @return The deleted.
     */
    @java.lang.Override
    public boolean getDeleted() {
      return instance.getDeleted();
    }
    /**
     * <pre>
     * If true, the tree has been deleted.
     * Deleted trees may be undeleted during a certain time window, after which
     * they're permanently deleted (and unrecoverable).
     * Readonly.
     * </pre>
     *
     * <code>bool deleted = 19;</code>
     * @param value The deleted to set.
     * @return This builder for chaining.
     */
    public Builder setDeleted(boolean value) {
      copyOnWrite();
      instance.setDeleted(value);
      return this;
    }
    /**
     * <pre>
     * If true, the tree has been deleted.
     * Deleted trees may be undeleted during a certain time window, after which
     * they're permanently deleted (and unrecoverable).
     * Readonly.
     * </pre>
     *
     * <code>bool deleted = 19;</code>
     * @return This builder for chaining.
     */
    public Builder clearDeleted() {
      copyOnWrite();
      instance.clearDeleted();
      return this;
    }

    /**
     * <pre>
     * Time of tree deletion, if any.
     * Readonly.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp delete_time = 20;</code>
     */
    @java.lang.Override
    public boolean hasDeleteTime() {
      return instance.hasDeleteTime();
    }
    /**
     * <pre>
     * Time of tree deletion, if any.
     * Readonly.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp delete_time = 20;</code>
     */
    @java.lang.Override
    public com.google.protobuf.Timestamp getDeleteTime() {
      return instance.getDeleteTime();
    }
    /**
     * <pre>
     * Time of tree deletion, if any.
     * Readonly.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp delete_time = 20;</code>
     */
    public Builder setDeleteTime(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.setDeleteTime(value);
      return this;
      }
    /**
     * <pre>
     * Time of tree deletion, if any.
     * Readonly.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp delete_time = 20;</code>
     */
    public Builder setDeleteTime(
        com.google.protobuf.Timestamp.Builder builderForValue) {
      copyOnWrite();
      instance.setDeleteTime(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Time of tree deletion, if any.
     * Readonly.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp delete_time = 20;</code>
     */
    public Builder mergeDeleteTime(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.mergeDeleteTime(value);
      return this;
    }
    /**
     * <pre>
     * Time of tree deletion, if any.
     * Readonly.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp delete_time = 20;</code>
     */
    public Builder clearDeleteTime() {  copyOnWrite();
      instance.clearDeleteTime();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:trillian.Tree)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new google.trillian.proto.Tree();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "treeId_",
            "treeState_",
            "treeType_",
            "hashStrategy_",
            "hashAlgorithm_",
            "signatureAlgorithm_",
            "displayName_",
            "description_",
            "privateKey_",
            "storageSettings_",
            "publicKey_",
            "maxRootDuration_",
            "createTime_",
            "updateTime_",
            "deleted_",
            "deleteTime_",
          };
          java.lang.String info =
              "\u0000\u0010\u0000\u0000\u0001\u0014\u0010\u0000\u0000\u0000\u0001\u0002\u0002\f" +
              "\u0003\f\u0004\f\u0005\f\u0006\f\b\u0208\t\u0208\f\t\r\t\u000e\t\u000f\t\u0010\t" +
              "\u0011\t\u0013\u0007\u0014\t";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<google.trillian.proto.Tree> parser = PARSER;
        if (parser == null) {
          synchronized (google.trillian.proto.Tree.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<google.trillian.proto.Tree>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:trillian.Tree)
  private static final google.trillian.proto.Tree DEFAULT_INSTANCE;
  static {
    Tree defaultInstance = new Tree();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      Tree.class, defaultInstance);
  }

  public static google.trillian.proto.Tree getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<Tree> PARSER;

  public static com.google.protobuf.Parser<Tree> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

