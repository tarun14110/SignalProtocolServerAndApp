// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: storage/storagepb/storage.proto

package storagepb;

public final class Storage {
  private Storage() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface NodeIDProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:storagepb.NodeIDProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>bytes path = 1;</code>
     */
    com.google.protobuf.ByteString getPath();

    /**
     * <code>int32 prefix_len_bits = 2;</code>
     */
    int getPrefixLenBits();
  }
  /**
   * <pre>
   * NodeIDProto is the serialized form of NodeID. It's used only for persistence
   * in storage. As this is long-term we prefer not to use a Go specific format.
   * </pre>
   *
   * Protobuf type {@code storagepb.NodeIDProto}
   */
  public  static final class NodeIDProto extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:storagepb.NodeIDProto)
      NodeIDProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeIDProto.newBuilder() to construct.
    private NodeIDProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeIDProto() {
      path_ = com.google.protobuf.ByteString.EMPTY;
      prefixLenBits_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeIDProto(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {

              path_ = input.readBytes();
              break;
            }
            case 16: {

              prefixLenBits_ = input.readInt32();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return storagepb.Storage.internal_static_storagepb_NodeIDProto_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return storagepb.Storage.internal_static_storagepb_NodeIDProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              storagepb.Storage.NodeIDProto.class, storagepb.Storage.NodeIDProto.Builder.class);
    }

    public static final int PATH_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString path_;
    /**
     * <code>bytes path = 1;</code>
     */
    public com.google.protobuf.ByteString getPath() {
      return path_;
    }

    public static final int PREFIX_LEN_BITS_FIELD_NUMBER = 2;
    private int prefixLenBits_;
    /**
     * <code>int32 prefix_len_bits = 2;</code>
     */
    public int getPrefixLenBits() {
      return prefixLenBits_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!path_.isEmpty()) {
        output.writeBytes(1, path_);
      }
      if (prefixLenBits_ != 0) {
        output.writeInt32(2, prefixLenBits_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!path_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, path_);
      }
      if (prefixLenBits_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, prefixLenBits_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof storagepb.Storage.NodeIDProto)) {
        return super.equals(obj);
      }
      storagepb.Storage.NodeIDProto other = (storagepb.Storage.NodeIDProto) obj;

      boolean result = true;
      result = result && getPath()
          .equals(other.getPath());
      result = result && (getPrefixLenBits()
          == other.getPrefixLenBits());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + PATH_FIELD_NUMBER;
      hash = (53 * hash) + getPath().hashCode();
      hash = (37 * hash) + PREFIX_LEN_BITS_FIELD_NUMBER;
      hash = (53 * hash) + getPrefixLenBits();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static storagepb.Storage.NodeIDProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static storagepb.Storage.NodeIDProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static storagepb.Storage.NodeIDProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static storagepb.Storage.NodeIDProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static storagepb.Storage.NodeIDProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static storagepb.Storage.NodeIDProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static storagepb.Storage.NodeIDProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static storagepb.Storage.NodeIDProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static storagepb.Storage.NodeIDProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static storagepb.Storage.NodeIDProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static storagepb.Storage.NodeIDProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static storagepb.Storage.NodeIDProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(storagepb.Storage.NodeIDProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * NodeIDProto is the serialized form of NodeID. It's used only for persistence
     * in storage. As this is long-term we prefer not to use a Go specific format.
     * </pre>
     *
     * Protobuf type {@code storagepb.NodeIDProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:storagepb.NodeIDProto)
        storagepb.Storage.NodeIDProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return storagepb.Storage.internal_static_storagepb_NodeIDProto_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return storagepb.Storage.internal_static_storagepb_NodeIDProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                storagepb.Storage.NodeIDProto.class, storagepb.Storage.NodeIDProto.Builder.class);
      }

      // Construct using storagepb.Storage.NodeIDProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        path_ = com.google.protobuf.ByteString.EMPTY;

        prefixLenBits_ = 0;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return storagepb.Storage.internal_static_storagepb_NodeIDProto_descriptor;
      }

      public storagepb.Storage.NodeIDProto getDefaultInstanceForType() {
        return storagepb.Storage.NodeIDProto.getDefaultInstance();
      }

      public storagepb.Storage.NodeIDProto build() {
        storagepb.Storage.NodeIDProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public storagepb.Storage.NodeIDProto buildPartial() {
        storagepb.Storage.NodeIDProto result = new storagepb.Storage.NodeIDProto(this);
        result.path_ = path_;
        result.prefixLenBits_ = prefixLenBits_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof storagepb.Storage.NodeIDProto) {
          return mergeFrom((storagepb.Storage.NodeIDProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(storagepb.Storage.NodeIDProto other) {
        if (other == storagepb.Storage.NodeIDProto.getDefaultInstance()) return this;
        if (other.getPath() != com.google.protobuf.ByteString.EMPTY) {
          setPath(other.getPath());
        }
        if (other.getPrefixLenBits() != 0) {
          setPrefixLenBits(other.getPrefixLenBits());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        storagepb.Storage.NodeIDProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (storagepb.Storage.NodeIDProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.ByteString path_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>bytes path = 1;</code>
       */
      public com.google.protobuf.ByteString getPath() {
        return path_;
      }
      /**
       * <code>bytes path = 1;</code>
       */
      public Builder setPath(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        path_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>bytes path = 1;</code>
       */
      public Builder clearPath() {
        
        path_ = getDefaultInstance().getPath();
        onChanged();
        return this;
      }

      private int prefixLenBits_ ;
      /**
       * <code>int32 prefix_len_bits = 2;</code>
       */
      public int getPrefixLenBits() {
        return prefixLenBits_;
      }
      /**
       * <code>int32 prefix_len_bits = 2;</code>
       */
      public Builder setPrefixLenBits(int value) {
        
        prefixLenBits_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int32 prefix_len_bits = 2;</code>
       */
      public Builder clearPrefixLenBits() {
        
        prefixLenBits_ = 0;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:storagepb.NodeIDProto)
    }

    // @@protoc_insertion_point(class_scope:storagepb.NodeIDProto)
    private static final storagepb.Storage.NodeIDProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new storagepb.Storage.NodeIDProto();
    }

    public static storagepb.Storage.NodeIDProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeIDProto>
        PARSER = new com.google.protobuf.AbstractParser<NodeIDProto>() {
      public NodeIDProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeIDProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeIDProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeIDProto> getParserForType() {
      return PARSER;
    }

    public storagepb.Storage.NodeIDProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SubtreeProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:storagepb.SubtreeProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * subtree's prefix (must be a multiple of 8 bits)
     * </pre>
     *
     * <code>bytes prefix = 1;</code>
     */
    com.google.protobuf.ByteString getPrefix();

    /**
     * <pre>
     * subtree's depth
     * </pre>
     *
     * <code>int32 depth = 2;</code>
     */
    int getDepth();

    /**
     * <code>bytes root_hash = 3;</code>
     */
    com.google.protobuf.ByteString getRootHash();

    /**
     * <pre>
     * map of suffix (within subtree) to subtree-leaf node hash
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; leaves = 4;</code>
     */
    int getLeavesCount();
    /**
     * <pre>
     * map of suffix (within subtree) to subtree-leaf node hash
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; leaves = 4;</code>
     */
    boolean containsLeaves(
        java.lang.String key);
    /**
     * Use {@link #getLeavesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getLeaves();
    /**
     * <pre>
     * map of suffix (within subtree) to subtree-leaf node hash
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; leaves = 4;</code>
     */
    java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getLeavesMap();
    /**
     * <pre>
     * map of suffix (within subtree) to subtree-leaf node hash
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; leaves = 4;</code>
     */

    com.google.protobuf.ByteString getLeavesOrDefault(
        java.lang.String key,
        com.google.protobuf.ByteString defaultValue);
    /**
     * <pre>
     * map of suffix (within subtree) to subtree-leaf node hash
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; leaves = 4;</code>
     */

    com.google.protobuf.ByteString getLeavesOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Map of suffix (within subtree) to subtree-internal node hash.
     * This structure is usually used in RAM as a cache, the internal nodes of
     * the subtree are not generally stored. However internal nodes are stored for
     * partially filled log subtrees.
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
     */
    int getInternalNodesCount();
    /**
     * <pre>
     * Map of suffix (within subtree) to subtree-internal node hash.
     * This structure is usually used in RAM as a cache, the internal nodes of
     * the subtree are not generally stored. However internal nodes are stored for
     * partially filled log subtrees.
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
     */
    boolean containsInternalNodes(
        java.lang.String key);
    /**
     * Use {@link #getInternalNodesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getInternalNodes();
    /**
     * <pre>
     * Map of suffix (within subtree) to subtree-internal node hash.
     * This structure is usually used in RAM as a cache, the internal nodes of
     * the subtree are not generally stored. However internal nodes are stored for
     * partially filled log subtrees.
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
     */
    java.util.Map<java.lang.String, com.google.protobuf.ByteString>
    getInternalNodesMap();
    /**
     * <pre>
     * Map of suffix (within subtree) to subtree-internal node hash.
     * This structure is usually used in RAM as a cache, the internal nodes of
     * the subtree are not generally stored. However internal nodes are stored for
     * partially filled log subtrees.
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
     */

    com.google.protobuf.ByteString getInternalNodesOrDefault(
        java.lang.String key,
        com.google.protobuf.ByteString defaultValue);
    /**
     * <pre>
     * Map of suffix (within subtree) to subtree-internal node hash.
     * This structure is usually used in RAM as a cache, the internal nodes of
     * the subtree are not generally stored. However internal nodes are stored for
     * partially filled log subtrees.
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
     */

    com.google.protobuf.ByteString getInternalNodesOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Used as a crosscheck on the internal node map by recording its expected
     * size after loading and repopulation.
     * </pre>
     *
     * <code>uint32 internal_node_count = 6;</code>
     */
    int getInternalNodeCount();
  }
  /**
   * <pre>
   * SubtreeProto contains nodes of a subtree.
   * </pre>
   *
   * Protobuf type {@code storagepb.SubtreeProto}
   */
  public  static final class SubtreeProto extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:storagepb.SubtreeProto)
      SubtreeProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SubtreeProto.newBuilder() to construct.
    private SubtreeProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SubtreeProto() {
      prefix_ = com.google.protobuf.ByteString.EMPTY;
      depth_ = 0;
      rootHash_ = com.google.protobuf.ByteString.EMPTY;
      internalNodeCount_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private SubtreeProto(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {

              prefix_ = input.readBytes();
              break;
            }
            case 16: {

              depth_ = input.readInt32();
              break;
            }
            case 26: {

              rootHash_ = input.readBytes();
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                leaves_ = com.google.protobuf.MapField.newMapField(
                    LeavesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000008;
              }
              com.google.protobuf.MapEntry<java.lang.String, com.google.protobuf.ByteString>
              leaves__ = input.readMessage(
                  LeavesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              leaves_.getMutableMap().put(
                  leaves__.getKey(), leaves__.getValue());
              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                internalNodes_ = com.google.protobuf.MapField.newMapField(
                    InternalNodesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000010;
              }
              com.google.protobuf.MapEntry<java.lang.String, com.google.protobuf.ByteString>
              internalNodes__ = input.readMessage(
                  InternalNodesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              internalNodes_.getMutableMap().put(
                  internalNodes__.getKey(), internalNodes__.getValue());
              break;
            }
            case 48: {

              internalNodeCount_ = input.readUInt32();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return storagepb.Storage.internal_static_storagepb_SubtreeProto_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 4:
          return internalGetLeaves();
        case 5:
          return internalGetInternalNodes();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return storagepb.Storage.internal_static_storagepb_SubtreeProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              storagepb.Storage.SubtreeProto.class, storagepb.Storage.SubtreeProto.Builder.class);
    }

    private int bitField0_;
    public static final int PREFIX_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString prefix_;
    /**
     * <pre>
     * subtree's prefix (must be a multiple of 8 bits)
     * </pre>
     *
     * <code>bytes prefix = 1;</code>
     */
    public com.google.protobuf.ByteString getPrefix() {
      return prefix_;
    }

    public static final int DEPTH_FIELD_NUMBER = 2;
    private int depth_;
    /**
     * <pre>
     * subtree's depth
     * </pre>
     *
     * <code>int32 depth = 2;</code>
     */
    public int getDepth() {
      return depth_;
    }

    public static final int ROOT_HASH_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString rootHash_;
    /**
     * <code>bytes root_hash = 3;</code>
     */
    public com.google.protobuf.ByteString getRootHash() {
      return rootHash_;
    }

    public static final int LEAVES_FIELD_NUMBER = 4;
    private static final class LeavesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, com.google.protobuf.ByteString> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, com.google.protobuf.ByteString>newDefaultInstance(
                  storagepb.Storage.internal_static_storagepb_SubtreeProto_LeavesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.BYTES,
                  com.google.protobuf.ByteString.EMPTY);
    }
    private com.google.protobuf.MapField<
        java.lang.String, com.google.protobuf.ByteString> leaves_;
    private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.ByteString>
    internalGetLeaves() {
      if (leaves_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            LeavesDefaultEntryHolder.defaultEntry);
      }
      return leaves_;
    }

    public int getLeavesCount() {
      return internalGetLeaves().getMap().size();
    }
    /**
     * <pre>
     * map of suffix (within subtree) to subtree-leaf node hash
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; leaves = 4;</code>
     */

    public boolean containsLeaves(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetLeaves().getMap().containsKey(key);
    }
    /**
     * Use {@link #getLeavesMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getLeaves() {
      return getLeavesMap();
    }
    /**
     * <pre>
     * map of suffix (within subtree) to subtree-leaf node hash
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; leaves = 4;</code>
     */

    public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getLeavesMap() {
      return internalGetLeaves().getMap();
    }
    /**
     * <pre>
     * map of suffix (within subtree) to subtree-leaf node hash
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; leaves = 4;</code>
     */

    public com.google.protobuf.ByteString getLeavesOrDefault(
        java.lang.String key,
        com.google.protobuf.ByteString defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
          internalGetLeaves().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * map of suffix (within subtree) to subtree-leaf node hash
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; leaves = 4;</code>
     */

    public com.google.protobuf.ByteString getLeavesOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
          internalGetLeaves().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int INTERNAL_NODES_FIELD_NUMBER = 5;
    private static final class InternalNodesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, com.google.protobuf.ByteString> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, com.google.protobuf.ByteString>newDefaultInstance(
                  storagepb.Storage.internal_static_storagepb_SubtreeProto_InternalNodesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.BYTES,
                  com.google.protobuf.ByteString.EMPTY);
    }
    private com.google.protobuf.MapField<
        java.lang.String, com.google.protobuf.ByteString> internalNodes_;
    private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.ByteString>
    internalGetInternalNodes() {
      if (internalNodes_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            InternalNodesDefaultEntryHolder.defaultEntry);
      }
      return internalNodes_;
    }

    public int getInternalNodesCount() {
      return internalGetInternalNodes().getMap().size();
    }
    /**
     * <pre>
     * Map of suffix (within subtree) to subtree-internal node hash.
     * This structure is usually used in RAM as a cache, the internal nodes of
     * the subtree are not generally stored. However internal nodes are stored for
     * partially filled log subtrees.
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
     */

    public boolean containsInternalNodes(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetInternalNodes().getMap().containsKey(key);
    }
    /**
     * Use {@link #getInternalNodesMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getInternalNodes() {
      return getInternalNodesMap();
    }
    /**
     * <pre>
     * Map of suffix (within subtree) to subtree-internal node hash.
     * This structure is usually used in RAM as a cache, the internal nodes of
     * the subtree are not generally stored. However internal nodes are stored for
     * partially filled log subtrees.
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
     */

    public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getInternalNodesMap() {
      return internalGetInternalNodes().getMap();
    }
    /**
     * <pre>
     * Map of suffix (within subtree) to subtree-internal node hash.
     * This structure is usually used in RAM as a cache, the internal nodes of
     * the subtree are not generally stored. However internal nodes are stored for
     * partially filled log subtrees.
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
     */

    public com.google.protobuf.ByteString getInternalNodesOrDefault(
        java.lang.String key,
        com.google.protobuf.ByteString defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
          internalGetInternalNodes().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Map of suffix (within subtree) to subtree-internal node hash.
     * This structure is usually used in RAM as a cache, the internal nodes of
     * the subtree are not generally stored. However internal nodes are stored for
     * partially filled log subtrees.
     * </pre>
     *
     * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
     */

    public com.google.protobuf.ByteString getInternalNodesOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
          internalGetInternalNodes().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int INTERNAL_NODE_COUNT_FIELD_NUMBER = 6;
    private int internalNodeCount_;
    /**
     * <pre>
     * Used as a crosscheck on the internal node map by recording its expected
     * size after loading and repopulation.
     * </pre>
     *
     * <code>uint32 internal_node_count = 6;</code>
     */
    public int getInternalNodeCount() {
      return internalNodeCount_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!prefix_.isEmpty()) {
        output.writeBytes(1, prefix_);
      }
      if (depth_ != 0) {
        output.writeInt32(2, depth_);
      }
      if (!rootHash_.isEmpty()) {
        output.writeBytes(3, rootHash_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetLeaves(),
          LeavesDefaultEntryHolder.defaultEntry,
          4);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetInternalNodes(),
          InternalNodesDefaultEntryHolder.defaultEntry,
          5);
      if (internalNodeCount_ != 0) {
        output.writeUInt32(6, internalNodeCount_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!prefix_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, prefix_);
      }
      if (depth_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, depth_);
      }
      if (!rootHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, rootHash_);
      }
      for (java.util.Map.Entry<java.lang.String, com.google.protobuf.ByteString> entry
           : internalGetLeaves().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, com.google.protobuf.ByteString>
        leaves__ = LeavesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(4, leaves__);
      }
      for (java.util.Map.Entry<java.lang.String, com.google.protobuf.ByteString> entry
           : internalGetInternalNodes().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, com.google.protobuf.ByteString>
        internalNodes__ = InternalNodesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(5, internalNodes__);
      }
      if (internalNodeCount_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(6, internalNodeCount_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof storagepb.Storage.SubtreeProto)) {
        return super.equals(obj);
      }
      storagepb.Storage.SubtreeProto other = (storagepb.Storage.SubtreeProto) obj;

      boolean result = true;
      result = result && getPrefix()
          .equals(other.getPrefix());
      result = result && (getDepth()
          == other.getDepth());
      result = result && getRootHash()
          .equals(other.getRootHash());
      result = result && internalGetLeaves().equals(
          other.internalGetLeaves());
      result = result && internalGetInternalNodes().equals(
          other.internalGetInternalNodes());
      result = result && (getInternalNodeCount()
          == other.getInternalNodeCount());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + PREFIX_FIELD_NUMBER;
      hash = (53 * hash) + getPrefix().hashCode();
      hash = (37 * hash) + DEPTH_FIELD_NUMBER;
      hash = (53 * hash) + getDepth();
      hash = (37 * hash) + ROOT_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getRootHash().hashCode();
      if (!internalGetLeaves().getMap().isEmpty()) {
        hash = (37 * hash) + LEAVES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetLeaves().hashCode();
      }
      if (!internalGetInternalNodes().getMap().isEmpty()) {
        hash = (37 * hash) + INTERNAL_NODES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetInternalNodes().hashCode();
      }
      hash = (37 * hash) + INTERNAL_NODE_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + getInternalNodeCount();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static storagepb.Storage.SubtreeProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static storagepb.Storage.SubtreeProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static storagepb.Storage.SubtreeProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static storagepb.Storage.SubtreeProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static storagepb.Storage.SubtreeProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static storagepb.Storage.SubtreeProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static storagepb.Storage.SubtreeProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static storagepb.Storage.SubtreeProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static storagepb.Storage.SubtreeProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static storagepb.Storage.SubtreeProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static storagepb.Storage.SubtreeProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static storagepb.Storage.SubtreeProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(storagepb.Storage.SubtreeProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * SubtreeProto contains nodes of a subtree.
     * </pre>
     *
     * Protobuf type {@code storagepb.SubtreeProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:storagepb.SubtreeProto)
        storagepb.Storage.SubtreeProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return storagepb.Storage.internal_static_storagepb_SubtreeProto_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 4:
            return internalGetLeaves();
          case 5:
            return internalGetInternalNodes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 4:
            return internalGetMutableLeaves();
          case 5:
            return internalGetMutableInternalNodes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return storagepb.Storage.internal_static_storagepb_SubtreeProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                storagepb.Storage.SubtreeProto.class, storagepb.Storage.SubtreeProto.Builder.class);
      }

      // Construct using storagepb.Storage.SubtreeProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        prefix_ = com.google.protobuf.ByteString.EMPTY;

        depth_ = 0;

        rootHash_ = com.google.protobuf.ByteString.EMPTY;

        internalGetMutableLeaves().clear();
        internalGetMutableInternalNodes().clear();
        internalNodeCount_ = 0;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return storagepb.Storage.internal_static_storagepb_SubtreeProto_descriptor;
      }

      public storagepb.Storage.SubtreeProto getDefaultInstanceForType() {
        return storagepb.Storage.SubtreeProto.getDefaultInstance();
      }

      public storagepb.Storage.SubtreeProto build() {
        storagepb.Storage.SubtreeProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public storagepb.Storage.SubtreeProto buildPartial() {
        storagepb.Storage.SubtreeProto result = new storagepb.Storage.SubtreeProto(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.prefix_ = prefix_;
        result.depth_ = depth_;
        result.rootHash_ = rootHash_;
        result.leaves_ = internalGetLeaves();
        result.leaves_.makeImmutable();
        result.internalNodes_ = internalGetInternalNodes();
        result.internalNodes_.makeImmutable();
        result.internalNodeCount_ = internalNodeCount_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof storagepb.Storage.SubtreeProto) {
          return mergeFrom((storagepb.Storage.SubtreeProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(storagepb.Storage.SubtreeProto other) {
        if (other == storagepb.Storage.SubtreeProto.getDefaultInstance()) return this;
        if (other.getPrefix() != com.google.protobuf.ByteString.EMPTY) {
          setPrefix(other.getPrefix());
        }
        if (other.getDepth() != 0) {
          setDepth(other.getDepth());
        }
        if (other.getRootHash() != com.google.protobuf.ByteString.EMPTY) {
          setRootHash(other.getRootHash());
        }
        internalGetMutableLeaves().mergeFrom(
            other.internalGetLeaves());
        internalGetMutableInternalNodes().mergeFrom(
            other.internalGetInternalNodes());
        if (other.getInternalNodeCount() != 0) {
          setInternalNodeCount(other.getInternalNodeCount());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        storagepb.Storage.SubtreeProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (storagepb.Storage.SubtreeProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString prefix_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * subtree's prefix (must be a multiple of 8 bits)
       * </pre>
       *
       * <code>bytes prefix = 1;</code>
       */
      public com.google.protobuf.ByteString getPrefix() {
        return prefix_;
      }
      /**
       * <pre>
       * subtree's prefix (must be a multiple of 8 bits)
       * </pre>
       *
       * <code>bytes prefix = 1;</code>
       */
      public Builder setPrefix(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        prefix_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * subtree's prefix (must be a multiple of 8 bits)
       * </pre>
       *
       * <code>bytes prefix = 1;</code>
       */
      public Builder clearPrefix() {
        
        prefix_ = getDefaultInstance().getPrefix();
        onChanged();
        return this;
      }

      private int depth_ ;
      /**
       * <pre>
       * subtree's depth
       * </pre>
       *
       * <code>int32 depth = 2;</code>
       */
      public int getDepth() {
        return depth_;
      }
      /**
       * <pre>
       * subtree's depth
       * </pre>
       *
       * <code>int32 depth = 2;</code>
       */
      public Builder setDepth(int value) {
        
        depth_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * subtree's depth
       * </pre>
       *
       * <code>int32 depth = 2;</code>
       */
      public Builder clearDepth() {
        
        depth_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString rootHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>bytes root_hash = 3;</code>
       */
      public com.google.protobuf.ByteString getRootHash() {
        return rootHash_;
      }
      /**
       * <code>bytes root_hash = 3;</code>
       */
      public Builder setRootHash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        rootHash_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>bytes root_hash = 3;</code>
       */
      public Builder clearRootHash() {
        
        rootHash_ = getDefaultInstance().getRootHash();
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, com.google.protobuf.ByteString> leaves_;
      private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.ByteString>
      internalGetLeaves() {
        if (leaves_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              LeavesDefaultEntryHolder.defaultEntry);
        }
        return leaves_;
      }
      private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.ByteString>
      internalGetMutableLeaves() {
        onChanged();;
        if (leaves_ == null) {
          leaves_ = com.google.protobuf.MapField.newMapField(
              LeavesDefaultEntryHolder.defaultEntry);
        }
        if (!leaves_.isMutable()) {
          leaves_ = leaves_.copy();
        }
        return leaves_;
      }

      public int getLeavesCount() {
        return internalGetLeaves().getMap().size();
      }
      /**
       * <pre>
       * map of suffix (within subtree) to subtree-leaf node hash
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; leaves = 4;</code>
       */

      public boolean containsLeaves(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetLeaves().getMap().containsKey(key);
      }
      /**
       * Use {@link #getLeavesMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getLeaves() {
        return getLeavesMap();
      }
      /**
       * <pre>
       * map of suffix (within subtree) to subtree-leaf node hash
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; leaves = 4;</code>
       */

      public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getLeavesMap() {
        return internalGetLeaves().getMap();
      }
      /**
       * <pre>
       * map of suffix (within subtree) to subtree-leaf node hash
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; leaves = 4;</code>
       */

      public com.google.protobuf.ByteString getLeavesOrDefault(
          java.lang.String key,
          com.google.protobuf.ByteString defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
            internalGetLeaves().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * map of suffix (within subtree) to subtree-leaf node hash
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; leaves = 4;</code>
       */

      public com.google.protobuf.ByteString getLeavesOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
            internalGetLeaves().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearLeaves() {
        internalGetMutableLeaves().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * map of suffix (within subtree) to subtree-leaf node hash
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; leaves = 4;</code>
       */

      public Builder removeLeaves(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableLeaves().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, com.google.protobuf.ByteString>
      getMutableLeaves() {
        return internalGetMutableLeaves().getMutableMap();
      }
      /**
       * <pre>
       * map of suffix (within subtree) to subtree-leaf node hash
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; leaves = 4;</code>
       */
      public Builder putLeaves(
          java.lang.String key,
          com.google.protobuf.ByteString value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableLeaves().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * map of suffix (within subtree) to subtree-leaf node hash
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; leaves = 4;</code>
       */

      public Builder putAllLeaves(
          java.util.Map<java.lang.String, com.google.protobuf.ByteString> values) {
        internalGetMutableLeaves().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, com.google.protobuf.ByteString> internalNodes_;
      private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.ByteString>
      internalGetInternalNodes() {
        if (internalNodes_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              InternalNodesDefaultEntryHolder.defaultEntry);
        }
        return internalNodes_;
      }
      private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.ByteString>
      internalGetMutableInternalNodes() {
        onChanged();;
        if (internalNodes_ == null) {
          internalNodes_ = com.google.protobuf.MapField.newMapField(
              InternalNodesDefaultEntryHolder.defaultEntry);
        }
        if (!internalNodes_.isMutable()) {
          internalNodes_ = internalNodes_.copy();
        }
        return internalNodes_;
      }

      public int getInternalNodesCount() {
        return internalGetInternalNodes().getMap().size();
      }
      /**
       * <pre>
       * Map of suffix (within subtree) to subtree-internal node hash.
       * This structure is usually used in RAM as a cache, the internal nodes of
       * the subtree are not generally stored. However internal nodes are stored for
       * partially filled log subtrees.
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
       */

      public boolean containsInternalNodes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetInternalNodes().getMap().containsKey(key);
      }
      /**
       * Use {@link #getInternalNodesMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getInternalNodes() {
        return getInternalNodesMap();
      }
      /**
       * <pre>
       * Map of suffix (within subtree) to subtree-internal node hash.
       * This structure is usually used in RAM as a cache, the internal nodes of
       * the subtree are not generally stored. However internal nodes are stored for
       * partially filled log subtrees.
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
       */

      public java.util.Map<java.lang.String, com.google.protobuf.ByteString> getInternalNodesMap() {
        return internalGetInternalNodes().getMap();
      }
      /**
       * <pre>
       * Map of suffix (within subtree) to subtree-internal node hash.
       * This structure is usually used in RAM as a cache, the internal nodes of
       * the subtree are not generally stored. However internal nodes are stored for
       * partially filled log subtrees.
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
       */

      public com.google.protobuf.ByteString getInternalNodesOrDefault(
          java.lang.String key,
          com.google.protobuf.ByteString defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
            internalGetInternalNodes().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Map of suffix (within subtree) to subtree-internal node hash.
       * This structure is usually used in RAM as a cache, the internal nodes of
       * the subtree are not generally stored. However internal nodes are stored for
       * partially filled log subtrees.
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
       */

      public com.google.protobuf.ByteString getInternalNodesOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, com.google.protobuf.ByteString> map =
            internalGetInternalNodes().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearInternalNodes() {
        internalGetMutableInternalNodes().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Map of suffix (within subtree) to subtree-internal node hash.
       * This structure is usually used in RAM as a cache, the internal nodes of
       * the subtree are not generally stored. However internal nodes are stored for
       * partially filled log subtrees.
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
       */

      public Builder removeInternalNodes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableInternalNodes().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, com.google.protobuf.ByteString>
      getMutableInternalNodes() {
        return internalGetMutableInternalNodes().getMutableMap();
      }
      /**
       * <pre>
       * Map of suffix (within subtree) to subtree-internal node hash.
       * This structure is usually used in RAM as a cache, the internal nodes of
       * the subtree are not generally stored. However internal nodes are stored for
       * partially filled log subtrees.
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
       */
      public Builder putInternalNodes(
          java.lang.String key,
          com.google.protobuf.ByteString value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableInternalNodes().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Map of suffix (within subtree) to subtree-internal node hash.
       * This structure is usually used in RAM as a cache, the internal nodes of
       * the subtree are not generally stored. However internal nodes are stored for
       * partially filled log subtrees.
       * </pre>
       *
       * <code>map&lt;string, bytes&gt; internal_nodes = 5;</code>
       */

      public Builder putAllInternalNodes(
          java.util.Map<java.lang.String, com.google.protobuf.ByteString> values) {
        internalGetMutableInternalNodes().getMutableMap()
            .putAll(values);
        return this;
      }

      private int internalNodeCount_ ;
      /**
       * <pre>
       * Used as a crosscheck on the internal node map by recording its expected
       * size after loading and repopulation.
       * </pre>
       *
       * <code>uint32 internal_node_count = 6;</code>
       */
      public int getInternalNodeCount() {
        return internalNodeCount_;
      }
      /**
       * <pre>
       * Used as a crosscheck on the internal node map by recording its expected
       * size after loading and repopulation.
       * </pre>
       *
       * <code>uint32 internal_node_count = 6;</code>
       */
      public Builder setInternalNodeCount(int value) {
        
        internalNodeCount_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Used as a crosscheck on the internal node map by recording its expected
       * size after loading and repopulation.
       * </pre>
       *
       * <code>uint32 internal_node_count = 6;</code>
       */
      public Builder clearInternalNodeCount() {
        
        internalNodeCount_ = 0;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:storagepb.SubtreeProto)
    }

    // @@protoc_insertion_point(class_scope:storagepb.SubtreeProto)
    private static final storagepb.Storage.SubtreeProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new storagepb.Storage.SubtreeProto();
    }

    public static storagepb.Storage.SubtreeProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SubtreeProto>
        PARSER = new com.google.protobuf.AbstractParser<SubtreeProto>() {
      public SubtreeProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new SubtreeProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<SubtreeProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SubtreeProto> getParserForType() {
      return PARSER;
    }

    public storagepb.Storage.SubtreeProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_storagepb_NodeIDProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_storagepb_NodeIDProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_storagepb_SubtreeProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_storagepb_SubtreeProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_storagepb_SubtreeProto_LeavesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_storagepb_SubtreeProto_LeavesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_storagepb_SubtreeProto_InternalNodesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_storagepb_SubtreeProto_InternalNodesEntry_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\037storage/storagepb/storage.proto\022\tstora" +
      "gepb\"4\n\013NodeIDProto\022\014\n\004path\030\001 \001(\014\022\027\n\017pre" +
      "fix_len_bits\030\002 \001(\005\"\273\002\n\014SubtreeProto\022\016\n\006p" +
      "refix\030\001 \001(\014\022\r\n\005depth\030\002 \001(\005\022\021\n\troot_hash\030" +
      "\003 \001(\014\0223\n\006leaves\030\004 \003(\0132#.storagepb.Subtre" +
      "eProto.LeavesEntry\022B\n\016internal_nodes\030\005 \003" +
      "(\0132*.storagepb.SubtreeProto.InternalNode" +
      "sEntry\022\033\n\023internal_node_count\030\006 \001(\r\032-\n\013L" +
      "eavesEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\014:\002" +
      "8\001\0324\n\022InternalNodesEntry\022\013\n\003key\030\001 \001(\t\022\r\n" +
      "\005value\030\002 \001(\014:\0028\001b\006proto3"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
    internal_static_storagepb_NodeIDProto_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_storagepb_NodeIDProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_storagepb_NodeIDProto_descriptor,
        new java.lang.String[] { "Path", "PrefixLenBits", });
    internal_static_storagepb_SubtreeProto_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_storagepb_SubtreeProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_storagepb_SubtreeProto_descriptor,
        new java.lang.String[] { "Prefix", "Depth", "RootHash", "Leaves", "InternalNodes", "InternalNodeCount", });
    internal_static_storagepb_SubtreeProto_LeavesEntry_descriptor =
      internal_static_storagepb_SubtreeProto_descriptor.getNestedTypes().get(0);
    internal_static_storagepb_SubtreeProto_LeavesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_storagepb_SubtreeProto_LeavesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_storagepb_SubtreeProto_InternalNodesEntry_descriptor =
      internal_static_storagepb_SubtreeProto_descriptor.getNestedTypes().get(1);
    internal_static_storagepb_SubtreeProto_InternalNodesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_storagepb_SubtreeProto_InternalNodesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
