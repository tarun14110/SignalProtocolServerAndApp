// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trillian.proto

package com.google.trillian.proto;

public interface TreeOrBuilder extends
    // @@protoc_insertion_point(interface_extends:trillian.Tree)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * ID of the tree.
   * Readonly.
   * </pre>
   *
   * <code>int64 tree_id = 1;</code>
   */
  long getTreeId();

  /**
   * <pre>
   * State of the tree.
   * Trees are ACTIVE after creation. At any point the tree may transition
   * between ACTIVE, DRAINING and FROZEN states.
   * </pre>
   *
   * <code>.trillian.TreeState tree_state = 2;</code>
   */
  int getTreeStateValue();
  /**
   * <pre>
   * State of the tree.
   * Trees are ACTIVE after creation. At any point the tree may transition
   * between ACTIVE, DRAINING and FROZEN states.
   * </pre>
   *
   * <code>.trillian.TreeState tree_state = 2;</code>
   */
  com.google.trillian.proto.TreeState getTreeState();

  /**
   * <pre>
   * Type of the tree.
   * Readonly after Tree creation. Exception: Can be switched from
   * PREORDERED_LOG to LOG if the Tree is and remains in the FROZEN state.
   * </pre>
   *
   * <code>.trillian.TreeType tree_type = 3;</code>
   */
  int getTreeTypeValue();
  /**
   * <pre>
   * Type of the tree.
   * Readonly after Tree creation. Exception: Can be switched from
   * PREORDERED_LOG to LOG if the Tree is and remains in the FROZEN state.
   * </pre>
   *
   * <code>.trillian.TreeType tree_type = 3;</code>
   */
  com.google.trillian.proto.TreeType getTreeType();

  /**
   * <pre>
   * Hash strategy to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.trillian.HashStrategy hash_strategy = 4;</code>
   */
  int getHashStrategyValue();
  /**
   * <pre>
   * Hash strategy to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.trillian.HashStrategy hash_strategy = 4;</code>
   */
  com.google.trillian.proto.HashStrategy getHashStrategy();

  /**
   * <pre>
   * Hash algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.HashAlgorithm hash_algorithm = 5;</code>
   */
  int getHashAlgorithmValue();
  /**
   * <pre>
   * Hash algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.HashAlgorithm hash_algorithm = 5;</code>
   */
  sigpb.Sigpb.DigitallySigned.HashAlgorithm getHashAlgorithm();

  /**
   * <pre>
   * Signature algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.SignatureAlgorithm signature_algorithm = 6;</code>
   */
  int getSignatureAlgorithmValue();
  /**
   * <pre>
   * Signature algorithm to be used by the tree.
   * Readonly.
   * </pre>
   *
   * <code>.sigpb.DigitallySigned.SignatureAlgorithm signature_algorithm = 6;</code>
   */
  sigpb.Sigpb.DigitallySigned.SignatureAlgorithm getSignatureAlgorithm();

  /**
   * <pre>
   * Display name of the tree.
   * Optional.
   * </pre>
   *
   * <code>string display_name = 8;</code>
   */
  java.lang.String getDisplayName();
  /**
   * <pre>
   * Display name of the tree.
   * Optional.
   * </pre>
   *
   * <code>string display_name = 8;</code>
   */
  com.google.protobuf.ByteString
      getDisplayNameBytes();

  /**
   * <pre>
   * Description of the tree,
   * Optional.
   * </pre>
   *
   * <code>string description = 9;</code>
   */
  java.lang.String getDescription();
  /**
   * <pre>
   * Description of the tree,
   * Optional.
   * </pre>
   *
   * <code>string description = 9;</code>
   */
  com.google.protobuf.ByteString
      getDescriptionBytes();

  /**
   * <pre>
   * Identifies the private key used for signing tree heads and entry
   * timestamps.
   * This can be any type of message to accommodate different key management
   * systems, e.g. PEM files, HSMs, etc.
   * Private keys are write-only: they're never returned by RPCs.
   * The private_key message can be changed after a tree is created, but the
   * underlying key must remain the same - this is to enable migrating a key
   * from one provider to another.
   * </pre>
   *
   * <code>.google.protobuf.Any private_key = 12;</code>
   */
  boolean hasPrivateKey();
  /**
   * <pre>
   * Identifies the private key used for signing tree heads and entry
   * timestamps.
   * This can be any type of message to accommodate different key management
   * systems, e.g. PEM files, HSMs, etc.
   * Private keys are write-only: they're never returned by RPCs.
   * The private_key message can be changed after a tree is created, but the
   * underlying key must remain the same - this is to enable migrating a key
   * from one provider to another.
   * </pre>
   *
   * <code>.google.protobuf.Any private_key = 12;</code>
   */
  com.google.protobuf.Any getPrivateKey();
  /**
   * <pre>
   * Identifies the private key used for signing tree heads and entry
   * timestamps.
   * This can be any type of message to accommodate different key management
   * systems, e.g. PEM files, HSMs, etc.
   * Private keys are write-only: they're never returned by RPCs.
   * The private_key message can be changed after a tree is created, but the
   * underlying key must remain the same - this is to enable migrating a key
   * from one provider to another.
   * </pre>
   *
   * <code>.google.protobuf.Any private_key = 12;</code>
   */
  com.google.protobuf.AnyOrBuilder getPrivateKeyOrBuilder();

  /**
   * <pre>
   * Storage-specific settings.
   * Varies according to the storage implementation backing Trillian.
   * </pre>
   *
   * <code>.google.protobuf.Any storage_settings = 13;</code>
   */
  boolean hasStorageSettings();
  /**
   * <pre>
   * Storage-specific settings.
   * Varies according to the storage implementation backing Trillian.
   * </pre>
   *
   * <code>.google.protobuf.Any storage_settings = 13;</code>
   */
  com.google.protobuf.Any getStorageSettings();
  /**
   * <pre>
   * Storage-specific settings.
   * Varies according to the storage implementation backing Trillian.
   * </pre>
   *
   * <code>.google.protobuf.Any storage_settings = 13;</code>
   */
  com.google.protobuf.AnyOrBuilder getStorageSettingsOrBuilder();

  /**
   * <pre>
   * The public key used for verifying tree heads and entry timestamps.
   * Readonly.
   * </pre>
   *
   * <code>.keyspb.PublicKey public_key = 14;</code>
   */
  boolean hasPublicKey();
  /**
   * <pre>
   * The public key used for verifying tree heads and entry timestamps.
   * Readonly.
   * </pre>
   *
   * <code>.keyspb.PublicKey public_key = 14;</code>
   */
  keyspb.Keyspb.PublicKey getPublicKey();
  /**
   * <pre>
   * The public key used for verifying tree heads and entry timestamps.
   * Readonly.
   * </pre>
   *
   * <code>.keyspb.PublicKey public_key = 14;</code>
   */
  keyspb.Keyspb.PublicKeyOrBuilder getPublicKeyOrBuilder();

  /**
   * <pre>
   * Interval after which a new signed root is produced even if there have been
   * no submission.  If zero, this behavior is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_root_duration = 15;</code>
   */
  boolean hasMaxRootDuration();
  /**
   * <pre>
   * Interval after which a new signed root is produced even if there have been
   * no submission.  If zero, this behavior is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_root_duration = 15;</code>
   */
  com.google.protobuf.Duration getMaxRootDuration();
  /**
   * <pre>
   * Interval after which a new signed root is produced even if there have been
   * no submission.  If zero, this behavior is disabled.
   * </pre>
   *
   * <code>.google.protobuf.Duration max_root_duration = 15;</code>
   */
  com.google.protobuf.DurationOrBuilder getMaxRootDurationOrBuilder();

  /**
   * <pre>
   * Time of tree creation.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp create_time = 16;</code>
   */
  boolean hasCreateTime();
  /**
   * <pre>
   * Time of tree creation.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp create_time = 16;</code>
   */
  com.google.protobuf.Timestamp getCreateTime();
  /**
   * <pre>
   * Time of tree creation.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp create_time = 16;</code>
   */
  com.google.protobuf.TimestampOrBuilder getCreateTimeOrBuilder();

  /**
   * <pre>
   * Time of last tree update.
   * Readonly (automatically assigned on updates).
   * </pre>
   *
   * <code>.google.protobuf.Timestamp update_time = 17;</code>
   */
  boolean hasUpdateTime();
  /**
   * <pre>
   * Time of last tree update.
   * Readonly (automatically assigned on updates).
   * </pre>
   *
   * <code>.google.protobuf.Timestamp update_time = 17;</code>
   */
  com.google.protobuf.Timestamp getUpdateTime();
  /**
   * <pre>
   * Time of last tree update.
   * Readonly (automatically assigned on updates).
   * </pre>
   *
   * <code>.google.protobuf.Timestamp update_time = 17;</code>
   */
  com.google.protobuf.TimestampOrBuilder getUpdateTimeOrBuilder();

  /**
   * <pre>
   * If true, the tree has been deleted.
   * Deleted trees may be undeleted during a certain time window, after which
   * they're permanently deleted (and unrecoverable).
   * Readonly.
   * </pre>
   *
   * <code>bool deleted = 19;</code>
   */
  boolean getDeleted();

  /**
   * <pre>
   * Time of tree deletion, if any.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp delete_time = 20;</code>
   */
  boolean hasDeleteTime();
  /**
   * <pre>
   * Time of tree deletion, if any.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp delete_time = 20;</code>
   */
  com.google.protobuf.Timestamp getDeleteTime();
  /**
   * <pre>
   * Time of tree deletion, if any.
   * Readonly.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp delete_time = 20;</code>
   */
  com.google.protobuf.TimestampOrBuilder getDeleteTimeOrBuilder();
}
