// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trillian_log_api.proto

package com.google.trillian.proto;

public interface LogLeafOrBuilder extends
    // @@protoc_insertion_point(interface_extends:trillian.LogLeaf)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * merkle_leaf_hash holds the Merkle leaf hash over leaf_value.  This is
   * calculated by the Trillian server when leaves are added to the tree, using
   * the defined hashing algorithm and strategy for the tree; as such, the client
   * does not need to set it on leaf submissions.
   * </pre>
   *
   * <code>bytes merkle_leaf_hash = 1;</code>
   */
  com.google.protobuf.ByteString getMerkleLeafHash();

  /**
   * <pre>
   * leaf_value holds the data that forms the value of the Merkle tree leaf.
   * The client should set this field on all leaf submissions, and is
   * responsible for ensuring its validity (the Trillian server treats it as an
   * opaque blob).
   * </pre>
   *
   * <code>bytes leaf_value = 2;</code>
   */
  com.google.protobuf.ByteString getLeafValue();

  /**
   * <pre>
   * extra_data holds additional data associated with the Merkle tree leaf.
   * The client may set this data on leaf submissions, and the Trillian server
   * will return it on subsequent read operations. However, the contents of
   * this field are not covered by and do not affect the Merkle tree hash
   * calculations.
   * </pre>
   *
   * <code>bytes extra_data = 3;</code>
   */
  com.google.protobuf.ByteString getExtraData();

  /**
   * <pre>
   * leaf_index indicates the index of this leaf in the Merkle tree.
   * This field is returned on all read operations, but should only be
   * set for leaf submissions in PREORDERED_LOG mode (for a normal log
   * the leaf index is assigned by Trillian when the submitted leaf is
   * integrated into the Merkle tree).
   * </pre>
   *
   * <code>int64 leaf_index = 4;</code>
   */
  long getLeafIndex();

  /**
   * <pre>
   * leaf_identity_hash provides a hash value that indicates the client's
   * concept of which leaf entries should be considered identical.
   * This mechanism allows the client personality to indicate that two leaves
   * should be considered "duplicates" even though their `leaf_value`s differ.
   * If this is not set on leaf submissions, the Trillian server will take its
   * value to be the same as merkle_leaf_hash (and thus only leaves with
   * identical leaf_value contents will be considered identical).
   * For example, in Certificate Transparency each certificate submission is
   * associated with a submission timestamp, but subsequent submissions of the
   * same certificate should be considered identical.  This is achieved
   * by setting the leaf identity hash to a hash over (just) the certificate,
   * whereas the Merkle leaf hash encompasses both the certificate and its
   * submission time -- allowing duplicate certificates to be detected.
   * Continuing the CT example, for a CT mirror personality (which must allow
   * dupes since the source log could contain them), the part of the
   * personality which fetches and submits the entries might set
   * `leaf_identity_hash` to `H(leaf_index||cert)`.
   * TODO(pavelkalinnikov): Consider instead using `H(cert)` and allowing
   * identity hash dupes in `PREORDERED_LOG` mode, for it can later be
   * upgraded to `LOG` which will need to correctly detect duplicates with
   * older entries when new ones get queued.
   * </pre>
   *
   * <code>bytes leaf_identity_hash = 5;</code>
   */
  com.google.protobuf.ByteString getLeafIdentityHash();

  /**
   * <pre>
   * queue_timestamp holds the time at which this leaf was queued for
   * inclusion in the Log, or zero if the entry was submitted without
   * queuing. Clients should not set this field on submissions.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp queue_timestamp = 6;</code>
   */
  boolean hasQueueTimestamp();
  /**
   * <pre>
   * queue_timestamp holds the time at which this leaf was queued for
   * inclusion in the Log, or zero if the entry was submitted without
   * queuing. Clients should not set this field on submissions.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp queue_timestamp = 6;</code>
   */
  com.google.protobuf.Timestamp getQueueTimestamp();
  /**
   * <pre>
   * queue_timestamp holds the time at which this leaf was queued for
   * inclusion in the Log, or zero if the entry was submitted without
   * queuing. Clients should not set this field on submissions.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp queue_timestamp = 6;</code>
   */
  com.google.protobuf.TimestampOrBuilder getQueueTimestampOrBuilder();

  /**
   * <pre>
   * integrate_timestamp holds the time at which this leaf was integrated into
   * the tree.  Clients should not set this field on submissions.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp integrate_timestamp = 7;</code>
   */
  boolean hasIntegrateTimestamp();
  /**
   * <pre>
   * integrate_timestamp holds the time at which this leaf was integrated into
   * the tree.  Clients should not set this field on submissions.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp integrate_timestamp = 7;</code>
   */
  com.google.protobuf.Timestamp getIntegrateTimestamp();
  /**
   * <pre>
   * integrate_timestamp holds the time at which this leaf was integrated into
   * the tree.  Clients should not set this field on submissions.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp integrate_timestamp = 7;</code>
   */
  com.google.protobuf.TimestampOrBuilder getIntegrateTimestampOrBuilder();
}
